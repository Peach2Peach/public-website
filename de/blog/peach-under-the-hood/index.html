<!DOCTYPE html><html lang="de"><head><meta charset="UTF-8"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><meta http-equiv="X-Frame-Options" content="DENY"/><meta http-equiv="X-XSS-Protection" content="1; mode=block"/><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/><meta name="keywords" content="[&quot;Produkt&quot;,&quot;P2P&quot;,&quot;Tutorial&quot;,&quot;Programmierung&quot;,&quot;JavaScript&quot;,&quot;Bitcoin&quot;]"/><meta name="description" content="Aaaaah Bitcoin, diese wunderbare Form von Geld, die durch ihre Kernfunktionen gedeiht. Wir alle lieben es, aber wir erkennen auch, dass es Risiken im Bereich der Selbstsouveränität gibt: du teilst deine Seeds und verlierst alles. Du schickst etwas an die falsche Adresse und bekommst es nie zurück."/><meta property="og:locale" content="de"/><meta property="og:site_name"/><meta property="og:title" content="Peach Bitcoin Exchange - Buy and Sell Bitcoin Anonymously and Without KYC"/><meta property="og:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta property="og:type" content="website"/><meta property="og:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:secure_url" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:width" content="1296"/><meta property="og:image:height" content="678"/><meta name="twitter:site" content="@peachbitcoin"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Peach Bitcoin Under the Hood: ein technischer Blick darauf, warum es die sicherste P2P-Börse ist · Peach Bitcoin"/><meta name="twitter:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and  without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta name="twitter:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta name="msapplication-TileColor" content="#F56522"/><meta name="cf-2fa-verify" content="e22767e30dc139c"/><meta name="theme-color" content="#F56522"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-regular.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-600.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-800.woff2"/><link rel="apple-touch-icon" href="/img/favicon/apple-touch-icon.png"/><link rel="icon" href="/img/favicon/favicon.svg"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/img/favicon/safari-pinned-tab.svg" color="#F56522"/><link rel="stylesheet" href="/css/main-fadd3e7623af117338aa3005f4c1cd65.css"/><title>Peach Bitcoin Under the Hood: ein technischer Blick darauf, warum es die sicherste P2P-Börse ist · Peach Bitcoin</title><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KQHJRQKH');</script></head><body id="blog-peach-under-the-hood"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KQHJRQKH" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><header class="header header-container" id="header"><div class="wrap"><a class="logo-link brand" href="/de/"><img class="logo logo" src="/img/peach-bitcoin-145cd6c0079ccacc9c70c892060964d1.svg" alt="Peach Bitcoin"/></a><input id="show-menu" type="checkbox"/><label class="nav-toggle-label" id="nav-toggle" for="show-menu"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path class="line--1" d="M0 70l28-28c2-2 2-2 7-2h64"></path><path class="line--2" d="M0 50h99"></path><path class="line--3" d="M0 30l28 28c2 2 2 2 7 2h64"></path></svg></label><nav class="nav"><a href="/de/how-it-works/">BTC kaufen ohne KYC</a><a href="/de/for-meetups/">BTC mit Bargeld kaufen</a><a href="/de/for-businesses/">BTC verkaufen</a><a href="/de/blog/">Blog</a><a href="/de/support/">Support</a><div class="language-selector"><input class="checkbox" type="checkbox" id="language-toggle"/><label class="language-label" for="language-toggle"><span class="language-text">Deutsch</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="white" style="margin-left: .25rem;"><path d="M7 10l5 5 5-5z"></path></svg></label><ul class="language-dropdown"><li><a href="/"> <span>English</span></a></li><li><a href="/es"> <span>Español</span></a></li><li><a href="/de"> <span>Deutsch</span></a></li><li><a href="/it"> <span>Italiano</span></a></li><li><a href="/fr"> <span>Français</span></a></li><li><a href="/pt"> <span>Português</span></a></li></ul></div></nav></div></header><main class="main" id="main"><div id="header-anchor"></div><section class="wrap"><div class="content-wrap post"><h1 id="peach-bitcoin-under-the-hood-ein-technischer-blick-darauf-warum-es-die-sicherste-p2p-boerse-ist">Peach Bitcoin Under the Hood: ein technischer Blick darauf, warum es die sicherste P2P-Börse ist</h1>
<div class="video-wrapper">
  <iframe
    src="https://www.youtube.com/embed/UvdbHlsPmK0"
    title="PEACH VIDEO OF Under the Hood"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>
<p>Aaaaah Bitcoin, diese wunderbare Form von Geld, die durch ihre Kernfunktionen gedeiht. Wir alle lieben es, aber wir erkennen auch, dass es Risiken im Bereich der Selbstsouveränität gibt: du teilst deine Seeds und verlierst alles. Du schickst etwas an die falsche Adresse und bekommst es nie zurück.</p>
<p>Deshalb ist es sehr wichtig, Bitcoin-bezogene Software als Open Source zur Verfügung zu stellen, und die Peach-App ist auf Github für alle einsehbar!</p>
<p>Natürlich bedeutet Open Source nicht, dass jeder den Code sorgfältig liest und den Mechanismus rückentwickelt. Deshalb schreibe ich diesen Artikel: um <strong>zu zeigen, wie sicher Peach ist</strong> und welche Schritte unternommen werden, um dies zu erreichen.</p>
<h2 id="schritt-1-erstellen-eines-no-kyc-kontos-auf-peach">Schritt 1: Erstellen eines No-KYC-Kontos auf Peach</h2>
<p>Um ganz klar zu sein: Dein Bitcoin-Seed ist dein Peach-Konto.</p>
<p>Wenn du Peach nutzen möchtest, musst du ein Konto erstellen, das darin besteht, den Public Key deines Kontos zu teilen und zu beweisen, dass du der Eigentümer bist.</p>
<p>Dazu musst du:</p>
<ul>
<li>
<p>1 - das aktuelle Datum und die Uhrzeit (in Millisekunden) als Text erhalten</p>
</li>
<li>
<p>2 - deinen Private Key verwenden, um eine Signatur des vorherigen Textes zu erzeugen</p>
</li>
<li>
<p>3 - den Public Key, das aktuelle Datum und die Signatur einreichen.</p>
</li>
</ul>
<p>Du musst außerdem eine uniqueId generieren, die verwendet wird, um zu verhindern, dass andere Benutzer sich als du ausgeben. Dies ist nützlich in Fällen wie dem Verlust der Seeds und der Beibehaltung desselben Kontos. Aber konzentrieren wir uns nicht zu sehr darauf.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood01.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<p>Hier ist der Code, um dies in Javascript auszuführen:</p>
<pre><code class="language-j">
  const seed = randomBytes(64);

  const root = bip32.fromSeed(seed, bitcoin);
  const child = root.derivePath(&quot;m/0&quot;);
  const keyPair = ECPair.fromPrivateKey(child.privateKey, { network: bitcoin });

  const publicKeyHex = Buffer.from(keyPair.publicKey).toString(&quot;hex&quot;);

  const session = axios.create({
    baseURL: &quot;https://api.peachbitcoin.com/&quot;,
    httpAgent: new http.Agent({ keepAlive: false }),
    httpsAgent: new https.Agent({ keepAlive: false }),
  });

  const registerMessage = String(Date.now());
  const registerMessageSignature = signWithBtcPrivKey(registerMessage, keyPair);

  const resp = await session.post(&quot;v1/user/register&quot;, {
    publicKey: publicKeyHex,
    message: registerMessage,
    signature: registerMessageSignature,
    uniqueId: &quot;my_own_unique_id_random_12345&quot;,
  });

  const accessToken = resp.data.accessToken;

  session.defaults.headers.common[&quot;authorization&quot;] = accessToken;

</code></pre>
<p>Herzlichen Glückwunsch! Du hast gerade ein Konto auf Peach erstellt! Der Server hat überprüft, dass du in diesem Moment der Eigentümer des Bitcoin-Schlüsselpaares bist, das dem eingereichten Public Key entspricht.</p>
<h2 id="schritt-2-einreichen-deines-oeffentlichen-pgp-schluessels">Schritt 2: Einreichen deines öffentlichen PGP-Schlüssels</h2>
<p>Es wird viel Verschlüsselung, aber auch etwas Entschlüsselung geben. Die Bitcoin-Schlüssel erlauben nur Einweg-Verschlüsselung, daher benötigen wir PGP-Schlüssel, um eine Zwei-Wege-Verschlüsselung durchzuführen. Dies ist grundlegend, um Bankkontodaten, Chatnachrichten usw. zu verschlüsseln und zu entschlüsseln. Das Einreichen des öffentlichen PGP-Schlüssels ist ähnlich wie das Einreichen des öffentlichen Bitcoin-Schlüssels. Allerdings gibt es einen zusätzlichen Schritt: der öffentliche PGP-Schlüssel muss mit dem Bitcoin-Private-Key signiert werden, um sicherzustellen, dass der Benutzer sowohl Eigentümer der Bitcoin- als auch der PGP-Schlüssel ist.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood02.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<pre><code class="language-j">
const { privateKey: pgpPrivateKey, publicKey: pgpPublicKey } =
    await createPGPKey();

  const pgpPublicKeyMessageSignature = signWithBtcPrivKey(
    pgpPublicKey,
    keyPair
  );
  const setPgpKeysMessage = String(Date.now());

  const setPgpKeysMessageSignature = await signPGPMessage(
    pgpPrivateKey,
    setPgpKeysMessage
  );

  await session.patch(&quot;v1/user&quot;, {
    pgpPublicKey: pgpPublicKey, // the PGP Pub key
    signature: pgpPublicKeyMessageSignature, // the above signed by the BTC Key
    message: setPgpKeysMessage, // the current timestamp
    pgpSignature: setPgpKeysMessageSignature, // the above signed by the PGP Key
  });

</code></pre>
<p>In diesem Moment hat Peach sowohl deinen öffentlichen Bitcoin- als auch deinen PGP-Schlüssel! Dies wird für den Handel auf Peach äußerst relevant sein.</p>
<h2 id="naechste-schritte">Nächste Schritte</h2>
<p>Ab diesem Punkt zeigt das Tutorial beide Seiten: die Käuferseite und die Verkäuferseite.</p>
<p>Die Schritte sind die folgenden:</p>
<ul>
<li>
<p>3.S Der Verkäufer erstellt ein Verkaufsangebot</p>
</li>
<li>
<p>4.S Der Verkäufer hinterlegt die Bitcoin im Peach-Escrow</p>
</li>
<li>
<p>5.B Der Käufer stellt eine Handelsanfrage zu dem Verkaufsangebot</p>
</li>
<li>
<p>5.S Der Verkäufer akzeptiert die Handelsanfrage des Käufers</p>
</li>
<li>
<p>6.B Der Käufer gibt an, dass die Fiat-Überweisung durchgeführt wurde</p>
</li>
<li>
<p>6.S Der Verkäufer bestätigt, dass er die Zahlung erhalten hat</p>
</li>
</ul>
<h2 id="schritt-3s-verkaeufer-erstellt-ein-verkaufsangebot">Schritt 3.S: Verkäufer erstellt ein Verkaufsangebot</h2>
<p>Ein Verkaufsangebot zu erstellen bedeutet, dass du ankündigst, bereit zu sein, eine bestimmte Menge Bitcoin zu verkaufen. Aber das ist nicht alles: Der Verkäufer muss etwas als Gegenleistung akzeptieren. Genauer gesagt, ein Verkaufsangebot besteht aus:</p>
<ul>
<li>
<p>einer Menge Bitcoin, die verkauft werden soll</p>
</li>
<li>
<p>den Währungen, die der Verkäufer akzeptiert</p>
</li>
<li>
<p>den Zahlungsmethoden, die der Verkäufer akzeptiert (Bargeld, Banküberweisung, Revolut-Transaktion usw.)</p>
</li>
<li>
<p>dem Aufpreis (wie teuer die Bitcoin im Vergleich zum aktuellen Marktwert sind)</p>
</li>
</ul>
<p>Wenn alles gut läuft, wird ein Käufer an dem Angebot interessiert sein und eine Handelsanfrage stellen. In diesem Moment muss er eine einzelne Währung und Zahlungsmethode aus den verfügbaren auswählen. Je mehr Optionen der Verkäufer jedoch anbietet, desto größer sind seine Chancen, einen Käufer anzuziehen.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood03.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">
const sats_to_sell = 21000;
  const sell_premium = 1; // 1%
  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

  const { address: returnAddress } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });
  const sellOfferPaymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@myWiseIdTradingBot&quot;,
  });

  const paymentDataEncryptSHA256 = await sha256(sellOfferPaymentDataToEncrypt);

  const offerCreateRes = await session.post(&quot;v1/offer&quot;, {
    type: &quot;ask&quot;,
    amount: sats_to_sell,
    meansOfPayment: { [payment_data_currency]: [payment_data_method] }, // {&quot;EUR&quot;: [&quot;wise&quot;]}
    paymentData: {
      [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
    },
    returnAddress: returnAddress,
    premium: sell_premium,
  });

</code></pre>
<p>Wie im Code zu sehen ist, kündigt der Verkäufer an, dass er 21.000 Sats (0,00021 Bitcoin) mit einem Aufpreis von 1 % verkauft. Er möchte Euro über sein Wise-Konto erhalten.<br>
Wenn man genau hinsieht, übermittelt er NICHT seine Wise-Konto-ID, sondern nur einen Hash. Peach wird niemals die Details seiner Zahlungsmethode erfahren, um die Anonymität zu wahren.<br>
Außerdem wird eine Rücksendeadresse übermittelt. Diese wird im Falle einer Rückerstattung verwendet: kein Käufer möchte deine Bitcoin, sodass du sie zurückbekommen kannst.</p>
<h2 id="schritt-4s-verkaeufer-hinterlegt-die-bitcoin-im-peach-escrow">Schritt 4.S: Verkäufer hinterlegt die Bitcoin im Peach-Escrow</h2>
<p>Nach einer erfolgreichen Anfrage an die Peach-API zur Erstellung des Verkaufsangebots erhält der Verkäufer die Sell-Offer-ID:</p>
<pre><code class="language-j">const sellOfferId = offerCreateRes.data.id;

</code></pre>
<p>Dieser Wert ist wichtig, behalte ihn. Es gibt andere Möglichkeiten, ihn zu erhalten, aber behalte ihn vorerst. Das Verkaufsangebot wurde erstellt, ist jedoch noch nicht öffentlich: keine Käufer können damit interagieren. Zuerst muss der Verkäufer den Escrow finanzieren.</p>
<p>Der Escrow ist wie ein Tresor, der sowohl die Autorisierung des Verkäufers als auch von Peach benötigt, um geöffnet zu werden. Die Bitcoin werden in den Tresor gelegt und bleiben dort sicher bis zum Ende des Handels. Da die Autorisierung des Verkäufers erforderlich ist und der Escrow ein Skript auf der Bitcoin-Blockchain ist (eine P2WSH-Adresse), benötigt Peach den Public Key des Verkäufers, um diesen Escrow zu erstellen.</p>
<p>In diesem Moment übermittelt der Verkäufer den Public Key, den er für den Escrow verwenden möchte, an Peach. Peach wählt seinen eigenen Public Key für den Tresor und konstruiert ihn, wodurch eine Adresse entsteht.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood04.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">const childSell = root.derivePath(`m/84'/0'/0'/${sellOfferId}'`);

  const keyPairSellOffer = ECPair.fromPrivateKey(childSell.privateKey, {
    network: bitcoin,
  });

  const sellOfferPublicKey = Buffer.from(keyPairSellOffer.publicKey).toString(
    &quot;hex&quot;
  );

  const escrowCreateRes = await session.post(
    &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;,
    {
      publicKey: sellOfferPublicKey,
    }
  );

  const escrowAddress = escrowCreateRes.data.escrows.bitcoin;

  const escrowPeachPublicKey =
    escrowCreateRes.data.escrowPeachPublicKey.bitcoin;

</code></pre>
<p>Wie im Code zu sehen ist, hat der Verkäufer beschlossen, ein neues Schlüsselpaar unter Verwendung der Sell-Offer-ID auf dem Ableitungspfad abzuleiten. Dies ist ein sicherer Ansatz, da er leicht reproduzierbar ist.<br>
Nach der Übermittlung des Public Keys gibt die Peach-API die Adresse zurück, an die der Verkäufer die 21.000 Sats senden soll. Du musst jedoch nicht darauf vertrauen, dass diese Adresse gültig ist: du kannst sie überprüfen.</p>
<p>Also lassen wir uns das überprüfen!</p>
<p>Die Peach-API gibt auch den Public Key zurück, den Peach für diesen speziellen Escrow verwendet hat, und das ermöglicht uns, die Adresse durch das Schreiben des Bitcoin-Skripts selbst zu rekonstruieren:</p>
<pre><code class="language-j">   OP_IF
       ${script.number.encode(4320).toString(&quot;hex&quot;)}
       OP_CHECKSEQUENCEVERIFY
       OP_DROP
   OP_ELSE
       ${sellerPublicKey}
       OP_CHECKSIGVERIFY
   OP_ENDIF
   ${peachPublicKey}
   OP_CHECKSIG
</code></pre>
<p>Dies ist das Skript, das wir für den Escrow verwenden:</p>
<ul>
<li>
<p>es erfordert immer die Signatur von Peach</p>
</li>
<li>
<p>es erfordert entweder:</p>
<ul>
<li>
<ul>
<li>die Signatur des Verkäufers</li>
</ul>
</li>
<li>
<ul>
<li>dass seit der Überweisung der Bitcoin an diese Adresse 4320 Blöcke gemined wurden</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Warum 4320 Blöcke? Das entspricht 30 Tagen, bei einem Durchschnitt von 1 Block alle 10 Minuten. Warum haben wir diese Alternative, dass nach einem Monat nur noch die Signatur von Peach erforderlich ist? Weil Verkäufer möglicherweise nicht kooperativ sind, ihre Schlüssel verlieren usw. Eines ist sicher: Peach hat einen einwandfreien Ruf, wenn es um die Verwaltung der Gelder der Verkäufer geht.</p>
<p>Nachdem du das Skript erstellt hast, kannst du die P2WSH-Adresse überprüfen, die es generiert, und sehen, dass sie mit der Adresse übereinstimmt, die die Peach-API als Antwort auf die Erstellung des Escrows gesendet hat.</p>
<pre><code class="language-j">  const multisigScript = bitcoin.script.compile([
    Buffer.from(sellOfferPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIGVERIFY,
  ]);

  const timelockScript = bitcoin.script.compile([
    bitcoin.script.number.encode(4320),
    bitcoin.opcodes.OP_CHECKSEQUENCEVERIFY,
    bitcoin.opcodes.OP_DROP,
  ]);

  const redeemScript = bitcoin.script.compile([
    bitcoin.opcodes.OP_IF,
    ...timelockScript,
    bitcoin.opcodes.OP_ELSE,
    ...multisigScript,
    bitcoin.opcodes.OP_ENDIF,
    Buffer.from(escrowPeachPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIG,
  ]);

  const escrowPayment = bitcoin.payments.p2wsh({
    redeem: { output: redeemScript },
    network: bitcoin,
  });

  console.log(&quot;Addresses Match:&quot;, escrowPayment.address === escrowAddress);

</code></pre>
<p>Perfekt! Führe nun einfach eine Bitcoin-Transaktion an diese Adresse aus und warte, bis der Escrow als finanziert deklariert wird.</p>
<pre><code class="language-j">  while (true) {
    const fundingStatusRes = await session.get(
      &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;
    );
    if (fundingStatusRes.data.funding.status === &quot;FUNDED&quot;) {
      break;
    }
  }

</code></pre>
<p>Sobald er als finanziert deklariert ist (nach dem Mining eines Blocks), wird das Verkaufsangebot öffentlich und Käufer können beginnen, damit zu interagieren!</p>
<h2 id="schritt-5b-kaeufer-stellt-eine-handelsanfrage-zu-dem-verkaufsangebot">Schritt 5.B: Käufer stellt eine Handelsanfrage zu dem Verkaufsangebot</h2>
<p>Jetzt ist es Zeit für den Käufer, aktiv zu werden!</p>
<p>Zuerst überprüfen wir alle verfügbaren Verkaufsangebote:</p>
<pre><code class="language-j">const sellOffers = await session.get(&quot;v069/sellOffer&quot;);
</code></pre>
<p>Der Einfachheit halber wird der Käufer am ersten verfügbaren Verkaufsangebot interessiert sein.</p>
<pre><code class="language-j">const sellOfferToTradeRequestId = sellOffers.data.offers[0].id;
</code></pre>
<p>Nun möchte der Käufer eine Handelsanfrage stellen und dem Verkäufer mitteilen, dass er unter seinen Bedingungen handeln möchte. Klingt einfach, oder? Aber dies ist der komplexeste Schritt des gesamten Prozesses.</p>
<p>Schauen wir uns an, was der Käufer einreichen muss:</p>
<ul>
<li>
<p>die bevorzugte Zahlungsmethode (eine der vom Verkäufer erlaubten)</p>
</li>
<li>
<p>die bevorzugte Währung (wie oben)</p>
</li>
<li>
<p>einen symmetrischen Schlüssel (für die direkte Kommunikation zwischen Käufer und Verkäufer) verschlüsselt</p>
</li>
<li>
<p>die Signatur des symmetrischen Schlüssels</p>
</li>
<li>
<p>die Zahlungsdaten, verschlüsselt mit dem symmetrischen Schlüssel</p>
</li>
<li>
<p>eine Signatur der Zahlungsdaten</p>
</li>
<li>
<p>die Release-Adresse: wohin der Käufer die gekauften Bitcoin erhalten möchte</p>
</li>
<li>
<p>die Signatur der Release-Adressnachricht: ein Nachweis, dass der Käufer diese Adresse besitzt, unter Verwendung von BIP 322</p>
</li>
<li>
<p>die maximale Mining-Gebühr: wie viel der Käufer von seinen endgültigen Bitcoin für die Miner-Gebühren der finalen Transaktion opfern möchte</p>
</li>
</ul>
<p>Das ist eine Menge, oder? Aber genau deshalb ist Peach super sicher! Gehen wir Schritt für Schritt vor.</p>
<h3 id="die-bevorzugte-zahlungsmethode-und-waehrung">Die bevorzugte Zahlungsmethode und Währung:</h3>
<p>Dies ist der einfachste Teil:</p>
<pre><code class="language-j">  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

</code></pre>
<h3 id="der-symmetrische-schluessel">Der symmetrische Schlüssel:</h3>
<p>Der symmetrische Schlüssel wird mit AES256 Bidirectional Encryption verwendet: du kannst eine Nachricht verschlüsseln und anschließend mit demselben Schlüssel wieder entschlüsseln:</p>
<pre><code class="language-j">async function decryptDataWithSymmetricKey(encryptedMessage, symmetricKey) {
  const message = await openpgp.readMessage({
    armoredMessage: encryptedMessage,
  });

  const { data: decrypted } = await openpgp.decrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;utf8&quot;,
  });

  return decrypted;
}

async function encryptDataWithSymmetricKey(data, symmetricKey) {
  const message = await openpgp.createMessage({ text: data });
  const encrypted = await openpgp.encrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;armored&quot;,
    config: {
      preferredSymmetricAlgorithm: openpgp.enums.symmetric.aes256,
    },
  });
  return encrypted;
}

</code></pre>
<p>Um einen zu erstellen, generiere einfach eine Zufallszahl:</p>
<pre><code class="language-j">  const symmetricKey = randomBytes(32);
  const symmetricKeyHex = symmetricKey.toString(&quot;hex&quot;);

</code></pre>
<p>Du wirst diesen Schlüssel nicht unverschlüsselt einreichen: das würde seinen Zweck zunichte machen. Er muss so verschlüsselt werden, dass nur der Käufer und der Verkäufer ihn entschlüsseln können. Da beide Benutzer ihre öffentlichen PGP-Schlüssel eingereicht haben, müssen wir ihn so verschlüsseln, dass nur die Entschlüsselung mit einem der entsprechenden privaten PGP-Schlüssel möglich ist:</p>
<pre><code class="language-j">async function encryptForMultipleRecipients(secret, publicKeysArmored) {
  const publicKeys = await Promise.all(
    publicKeysArmored.map((armored) =&gt; openpgp.readKey({ armoredKey: armored }))
  );
  const message = await openpgp.createMessage({ text: secret });

  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: publicKeys,
  });

  return encrypted;
}

  const matchingUserPgpPubKey = sellOffers.data.offers[0].user.pgpPublicKey;

  const symmetricKeyEncrypted = await encryptForMultipleRecipients(
    symmetricKeyHex,
    [pgpPublicKey, matchingUserPgpPubKey]
  );

</code></pre>
<p>Und damit der Verkäufer sicher sein kann, dass der symmetrische Schlüssel vom Käufer erstellt wurde, muss er ihn außerdem mit seinem PGP-Schlüssel signieren:</p>
<pre><code class="language-j">  const symmetricKeySignature = await signPGPMessage(
    pgpPrivateKey,
    symmetricKeyHex
  );

</code></pre>
<h3 id="die-zahlungsdaten">Die Zahlungsdaten:</h3>
<p>Dies ist das wertvollste Informationsstück: deine Zahlungsdaten. Das können deine Bankkontodaten (IBAN), dein Revolut-Benutzername oder alles sein, was die Herkunft deiner Fiat-Zahlung identifiziert. Der Verkäufer wird später seine Informationen mit dem Käufer teilen.</p>
<p>Da wir nun einen symmetrischen Schlüssel haben, können wir ihn verwenden, um die Zahlungsdaten zu verschlüsseln. Diese werden später vom Verkäufer zur Entschlüsselung verwendet.</p>
<pre><code class="language-j">const paymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@buyerWiseId&quot;,
  });

const paymentDataEncrypted = await encryptDataWithSymmetricKey(
paymentDataToEncrypt,
symmetricKeyHex
);

const paymentDataSignature = await signPGPMessage(
pgpPrivateKey,
paymentDataToEncrypt
);

</code></pre>
<h3 id="definition-der-release-adresse-und-eigentumsnachweis">Definition der Release-Adresse und Eigentumsnachweis:</h3>
<p>Du musst festlegen, wohin die Bitcoin aus dem Handel danach gesendet werden sollen. Eine Adresse zu erstellen ist der einfache Teil. Der schwierige Teil ist der Nachweis des Eigentums an der Adresse. Dies machen wir aus regulatorischen Gründen, um sicherzustellen, dass der Käufer tatsächlich der Eigentümer ist. Glücklicherweise dient es auch als zusätzliche Sicherheitsmaßnahme (allein dies macht Peach immun gegen den Address-Replacement-Angriff unter Verwendung von Javascript-Bibliotheken aus dem September 2025).</p>
<p>Der Eigentumsnachweis erfolgt unter Verwendung von BIP-322, das es dir ermöglicht, deine Bitcoin-Privatschlüssel zu verwenden, um eine Nachricht zu signieren, die mit der Adresse überprüft werden kann.</p>
<pre><code class="language-j">  const { address } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });

  const ownershipMessage =
    &quot;I confirm that only I, peach&quot; +
    publicKeyHex.slice(0, 8) +
    &quot;, control the address &quot; +
    address;

  const releaseAddressSignature = signWithBIP322(
    wif,
    address,
    ownershipMessage
  );

</code></pre>
<h3 id="ein-letztes-detail-die-maximale-mining-gebuehr">Ein letztes Detail: die maximale Mining-Gebühr</h3>
<p>Als Käufer möchtest du möglicherweise nicht so viel für Gebühren ausgeben, um deine Bitcoin zu erhalten, und wartest lieber, bis die Gebühren sinken, bevor du die Mittel erhältst. In diesem Fall kannst du die maximale Mining-Gebühr festlegen, die du bereit bist zu „zahlen“, um die Bitcoin zu erhalten.</p>
<h3 id="schlielich-erstellen-der-handelsanfrage-zum-verkaufsangebot">Schließlich: Erstellen der Handelsanfrage zum Verkaufsangebot</h3>
<p>Was für ein Abenteuer, oder? Aber hier ist sie, und du kannst sie einreichen.</p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; + sellOfferToTradeRequestId + &quot;/tradeRequestPerformed&quot;,
    {
      paymentMethod: payment_data_method,
      currency: payment_data_currency,
      paymentDataHashed: paymentDataToEncryptSHA256,
      paymentDataEncrypted: paymentDataEncrypted,
      paymentDataSignature: paymentDataSignature,
      symmetricKeyEncrypted: symmetricKeyEncrypted,
      symmetricKeySignature: symmetricKeySignature,
      maxMiningFeeRate: 2, // sats/vb
      releaseAddress: address,
      releaseAddressMessageSignature: releaseAddressSignature,
    }
  );

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood05.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Nun ist der Verkäufer an der Reihe, sie zu akzeptieren.</p>
<h2 id="schritt-5s-verkaeufer-akzeptiert-die-handelsanfrage">Schritt 5.S: Verkäufer akzeptiert die Handelsanfrage</h2>
<p>Der Verkäufer hat darauf gewartet, dass ein Käufer mit seinem Verkaufsangebot interagiert. Er überprüft die Liste der Handelsanfragen:</p>
<pre><code class="language-j">const receivedTradeRequestRequest = await session.get(
    &quot;v069/sellOffer/&quot; + sellOfferId + &quot;/tradeRequestReceived&quot;
  );

  const tradeReq = receivedTradeRequestRequest.data[0];

</code></pre>
<p>Wenn der Verkäufer die Handelsanfrage akzeptieren möchte, muss er seine Zahlungsdaten mit dem Käufer teilen, damit der Käufer weiß, wohin das Fiat gesendet werden soll.</p>
<p>Da der Käufer bereits einen symmetrischen Schlüssel erstellt und eingereicht hat, kann der Verkäufer diesen entschlüsseln (da er mit seinem eigenen PGP-Öffentlichen Schlüssel verschlüsselt wurde) und ihn verwenden, um seine eigenen Zahlungsdaten zu verschlüsseln.</p>
<pre><code class="language-j">  const receivedSymmetricKey = await decryptWithPrivateKey(
    tradeReq.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  const sellOfferPaymentDataEncrypted = await encryptDataWithSymmetricKey(
    sellOfferPaymentDataToEncrypt,
    receivedSymmetricKey
  );

  const sellOfferPaymentDataSignature = await signPGPMessage(
    pgpPrivateKey,
    sellOfferPaymentDataToEncrypt
  );

</code></pre>
<p>Und das war’s! Jetzt kann der Verkäufer die Handelsanfrage akzeptieren und ein offizieller Handel beginnt!</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood06.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; +
      sellOfferId +
      &quot;/tradeRequestReceived/&quot; +
      tradeReq.userId +
      &quot;/accept&quot;,
    {
      paymentDataEncrypted: sellOfferPaymentDataEncrypted,
      paymentDataSignature: sellOfferPaymentDataSignature,
      paymentData: {
        [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
      },
    }
  );

</code></pre>
<p>Wenn es schwierig war, den gesamten Prozess zu verstehen, hier ist ein Bild zur Veranschaulichung:</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood07.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 90%;">
<br><br></p>
<h2 id="schritt-6b-kaeufer-erklaert-die-zahlung-als-durchgefuehrt">Schritt 6.B: Käufer erklärt die Zahlung als durchgeführt</h2>
<p>Der Käufer kann überprüfen, ob er Verträge (Trades, die von Käufer und Verkäufer vereinbart wurden) hat, indem er das Endpoint für Contract-Summaries abfragt:</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data.find((obj) =&gt;
    obj.id.startsWith(sellOfferToTradeRequestId + &quot;-&quot;)
  );

  if (contract.tradeStatus !== &quot;paymentRequired&quot;) throw Error;
</code></pre>
<p>Dies gibt ihm eine Liste aller Verträge, an denen er beteiligt ist. Wenn ein Vertrag den Handelsstatus „paymentRequired“ hat, ist er an der Reihe, die Fiat-Zahlung vorzunehmen.</p>
<p>Dazu muss er die Zahlungsdaten des Verkäufers mit dem symmetrischen Schlüssel entschlüsseln, der bei der ursprünglichen Handelsanfrage erstellt wurde. Wenn er ihn nicht gespeichert hat, ist das in Ordnung, da er mit seinem PGP-Privatschlüssel entschlüsselt werden kann.</p>
<pre><code class="language-j">
  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

  const receivedSymmetricKey = await decryptWithPrivateKey(
    contractRes.data.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  if (receivedSymmetricKey !== symmetricKeyHex) throw Error;

  const decryptedSellerPaymentData = await decryptDataWithSymmetricKey(
    contractRes.data.paymentDataEncrypted,
    receivedSymmetricKey
  );

  console.log(&quot;Seller Payment Data &quot;, JSON.parse(decryptedSellerPaymentData));
</code></pre>
<p>Dies soll außerhalb von Peach geschehen: Der Käufer öffnet seine Banking-App (oder Ähnliches) und führt eine Fiat-Überweisung an den Empfänger der Zahlungsdaten des Verkäufers durch.</p>
<p>Wenn dir als Leser dieser Schritt unsicher erscheint, denke daran: Die Bitcoin befinden sich bereits im Escrow, der von Peach und dem Verkäufer kontrolliert wird. Du kannst sogar auf die Escrow-Adresse zugreifen, die in den Vertragsdaten der API verfügbar ist, und einen Blockchain-Explorer verwenden, um zu prüfen, ob die Bitcoin dort sind.<br>
Nach der Durchführung der Fiat-Überweisung muss der Käufer erklären, dass die Zahlung erfolgt ist:</p>
<pre><code class="language-j">  const confirmPaymentRes = await session.post(
    &quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;
  );
</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood08.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Das war der letzte Schritt des Käufers. Nun muss der Verkäufer bestätigen, dass er das Fiat erhalten hat, und die Bitcoin im Escrow an die Adresse des Käufers freigeben.</p>
<h2 id="schritt-6s-verkaeufer-bestaetigt-den-zahlungseingang">Schritt 6.S: Verkäufer bestätigt den Zahlungseingang</h2>
<p>Ähnlich wie der Käufer überprüft der Verkäufer die ihm zugewiesenen Verträge.</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data[0];

  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

</code></pre>
<p>In der API-Antwort des Vertrags erhält der Verkäufer eine teilweise signierte Bitcoin-Transaktion (PSBT), bei der es sich um eine Transaktion der Bitcoin im Escrow zur Adresse des Käufers handelt, mit einer Signatur von Peach. Das bedeutet, dass nur noch die Signatur des Verkäufers benötigt wird, damit sie gültig wird:</p>
<pre><code class="language-j">  const releasePSBTBase64 = contractRes.data.releasePsbt;

  const parsedPSBT = bitcoin.Psbt.fromBase64(releasePSBTBase64, {
    network: bitcoin,
  });

  parsedPSBT.signInput(0, childSell);

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood09.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Nun kann der Verkäufer die Transaktion finalisieren, indem er die beiden Signaturen und das Escrow-Bitcoin-Skript übergibt. Da wir den MultiSig-Pfad des Skripts durchlaufen (als 2. Pfad geschrieben), müssen wir OP_FALSE an den Stack übergeben, um die IF-Bedingung korrekt zu beeinflussen.</p>
<pre><code class="language-j">export const getFinalScript = (_inputIndex, input, bitcoinScript) =&gt; {
  const network = bitcoin;

  const payment = payments.p2wsh({
    network,
    redeem: {
      network,
      output: bitcoinScript,
      input: bitcoin.script.compile([
        input.partialSig[0].signature,
        input.partialSig[1].signature,
        opcodes.OP_FALSE,
      ]),
    },
  });

  parsedPSBT.finalizeInput(0, getFinalScript);

  const tx = parsedPSBT.extractTransaction().toHex();

</code></pre>
<p>Der letzte Schritt: die finalisierte Transaktion an die Peach-API übermitteln:</p>
<pre><code class="language-j">  await session.post(&quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;, {
    releaseTransaction: tx,
  });

</code></pre>
<p>Meine Damen und Herren, so handeln wir bei Peach mit maximaler Sicherheit und Privatsphäre!</p>
<p class="date">October 23rd, 2025</p><p class="tags">Tagged with:<a href="/de/blog/tag/produkt">Produkt</a><a href="/de/blog/tag/p2p">P2P</a><a href="/de/blog/tag/tutorial">Tutorial</a></p><p><a href="/de/blog/">All blog posts</a></p></div></section></main><footer class="footer" id="footer"><div class="wrap"><div class="logo-section"><div class="logo"><img class="logo-image" src="/img/peach-footer-logo-e28fd7e07f654f43afd63c9b6ace3cdb.svg" alt="Peach logo"/><span>Made in Switzerland <img src="/img/flags/switzerland-icon.svg" style="width: 1rem; margin-left .5rem;"/></span></div><div class="company-info"> <img class="polyreg-image" src="/img/polyreg-52ec37fb80d0312b219110c05567ad3d.png" alt="Polyreg logo" width="120"/><p>Peach ist ein SRO-Mitglied (Selbstregulierungsorganisation) von Polyreg </p><p>Peach ist ein lizenzierter Finanzdienstleister in der Schweiz und vollständig konform mit dem Schweizer Geldwäschereigesetz. </p></div></div><div class="content"><div class="footer-box"><h6>Unternehmen</h6><a href="/de/join-us/">Treten Sie uns bei</a><a href="/de/terms-and-conditions/">AGB</a><a href="/de/privacy-policy/">Datenschutzrichtlinie</a><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Cookie-Einstellungen verwalten</a></div><div class="footer-box"><h6>Kontakt</h6><a href="mailto:hello@peachbitcoin.com">E-Mail</a><a href="https://keys.openpgp.org/vks/v1/by-fingerprint/48339A19645E2E53488E0E5479E1B270FACD1BD2">PGP-Schlüssel</a></div><div class="footer-box"><h6>Herunterladen</h6><span>0.69.0 (312)</span><a href="/de/apk/">APK</a><a href="https://testflight.apple.com/join/wfSPFEWG">iPhone</a><a href="https://play.google.com/store/apps/details?id=com.peachbitcoin.peach.mainnet">Android</a></div><div class="footer-box"><h6>Community</h6><a href="https://twitter.com/peachbitcoin" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://t.me/peachtopeach" target="_blank" rel="noreferrer noopener">Telegram</a><a href="https://discord.gg/ypeHz3SW54" target="_blank" rel="noreferrer noopener">Discord</a><a href="https://www.instagram.com/peachbitcoin/" target="_blank" rel="noreferrer noopener">Instagram</a><a href="https://snort.social/p/npub15369wu3wzzar5fclhecyqfv683x69n6nhlg7rxqnsg2dydgxflpq3apswl" target="_blank" rel="noreferrer noopener">Nostr</a><a href="https://github.com/Peach2Peach" target="_blank" rel="noreferrer noopener">Github</a><a href="https://www.youtube.com/@peachbitcoin" target="_blank" rel="noreferrer noopener">YouTube</a></div><div class="footer-box"><h6>Bitcoin</h6><a href="/bitcoin.pdf">Whitepaper</a><a href="https://docs.peachbitcoin.com">API-Dokumentation</a></div><div class="footer-box"><h6>Verdiene Bitcoin</h6><a href="/de/new-users/">Empfehlungscode</a><a href="/de/for-businesses/">Affiliate werden</a></div></div></div></footer><style>#cookie-banner {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: #120A07;
  color: #fff;
  padding: 15px 0;
  z-index: 9999;
  font-size: 14px;
}
#cookie-banner .cookie-container {
  width: 90%;
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
}
#cookie-banner p {
  margin: 0;
  line-height: 1.4;
}
#cookie-banner .cookie-actions {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}
#cookie-banner button {
  padding: 10px 16px;
  color: #fff;
  background-color: #65A519;
  border: none;
  cursor: pointer;
  border-radius: 4px;
  font-size: 14px;
  transition: background-color 0.3s ease;
}
#cookie-banner button:hover {
  background-color: #65A519;
}
#cookie-banner button.reject {
  background-color: #DF321F;
}
#cookie-banner button.reject:hover {
  background-color: #DF321F;
}
#cookie-banner a.cookie-link {
  color: #fff;
  text-decoration: underline;
  font-size: 14px;
  margin-left: 8px;
  cursor: pointer;
}
#cookie-banner a.cookie-link:hover {
  text-decoration: none;
}
/* Popup overlay */
#cookie-popup {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  z-index: 10000;
  justify-content: center;
  align-items: center;
  color: #fff;
}
/* Contenitore del popup */
#cookie-popup-content {
  position: relative;
  background-color: #120A07;
  color:rgb(255, 255, 255);
  padding: 30px 20px 20px;
  border-radius: 10px;
  width: 80%;
  max-width: 600px;
  box-sizing: border-box;
}
/* Pulsante di chiusura */
#cookie-popup-content .close-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  color: #fff;
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  padding: 0 5px;
}
#cookie-popup-content .close-btn:hover {
  color: #ccc;
}
/* Stile per ciascuna categoria di cookie */
.cookie-category {
  margin-bottom: 20px;
}
/* Migliora i checkbox e le label */
.cookie-category label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 15px;
}
.cookie-category input[type="checkbox"] {
  accent-color: #4CAF50;
  margin: 0;
  cursor: pointer;
}
.cookie-category p {
  margin: 4px 0 0 28px;
  font-size: 14px;
  line-height: 1.4;
  color: #ccc;
}
/* Bottone "Salva Preferenze" */
#cookie-popup-content button.save-btn {
  background-color: #4CAF50;
  border: none;
  padding: 10px 16px;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}
#cookie-popup-content button.save-btn:hover {
  background-color: #43a047;
}
/* Media query per schermi più piccoli */
@media (max-width: 768px) {
  #cookie-banner .cookie-container {
    flex-direction: column;
    align-items: flex-start;
  }
  #cookie-banner .cookie-actions {
    margin-top: 10px;
    width: 100%;
    justify-content: flex-start;
    gap: 8px;
    flex-wrap: wrap;
  }
}

</style><div id="cookie-banner" style="display: none;"><div class="cookie-container"><p>Wir verwenden Cookies, um Ihre Erfahrung zu verbessern. <a href="/privacy-policy" style="color: #4CAF50;">Mehr erfahren</a></p><div class="cookie-actions"><button class="cookie-btn" onclick="acceptCookies()">Cookies akzeptieren &amp; fortfahren</button><button class="cookie-btn reject" onclick="rejectCookies()">Cookies ablehnen</button><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Cookies verwalten</a></div></div></div><div id="cookie-popup"><div id="cookie-popup-content"><button class="close-btn" type="button" onclick="closeCookiePopup()">×</button><h2>Cookie-Einstellungen verwalten</h2><div class="cookie-category"><div class="switch-container"><span class="label-text">Notwendige Cookies</span><label class="switch" for="necessary-cookies"><input type="checkbox" id="necessary-cookies" checked="checked" disabled="disabled"/><span class="slider"></span></label></div><p>Diese Cookies sind für den Betrieb der Website unerlässlich.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Analyse-Cookies</span><label class="switch" for="analytics-cookies"><input type="checkbox" id="analytics-cookies"/><span class="slider"></span></label></div><p>Analyse-Cookies helfen uns zu verstehen, wie Nutzer mit der Website interagieren.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Marketing-Cookies</span><label class="switch" for="marketing-cookies"><input type="checkbox" id="marketing-cookies"/><span class="slider"></span></label></div><p>Marketing-Cookies werden verwendet, um Nutzerdaten zu sammeln</p></div><div style="text-align: right; margin-top: 20px;"><button class="save-btn" type="button" onclick="savePreferences()">Einstellungen speichern</button></div></div></div><script src="/js/main-15c0432b5e5f06cbab9e3fedcaae3032.js"></script><script>if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/service-worker.js')
      .then(function(registration) {
        console.log('Service Worker registrato con successo:', registration);
      })
      .catch(function(error) {
        console.log('Registrazione del Service Worker fallita:', error);
      });
  });
} else {
  console.log('Service Worker non supportato in questo browser.');
}
</script><script>document.addEventListener('DOMContentLoaded', function () {
  // Map of language codes to display names
  const languageMap = {
    en: 'English',
    es: 'Español',
    de: 'Deutsch',
    it: 'Italiano',
    fr: 'Français',
    el: 'Ελληνικά',
    hu: 'Magyar',
    nl: 'Nederlands',
    pl: 'Polski',
    pt: 'Português',
    sw: 'Kiswahili',
    uk: 'Українська'
  };

  // Detect current lang from path
  const path = window.location.pathname.replace(/\/+$/, ''); // trim trailing slash
  let currentLang = 'en';
  for (const code in languageMap) {
    if (path === '/' && code === 'en') { currentLang = 'en'; break; }
    if (path === `/${code}` || path.startsWith(`/${code}/`)) { currentLang = code; break; }
  }

  const label = document.querySelector('.language-label');
  if (!label) return;

  // Ensure there is a span.language-text, create it if missing
  let textNode = label.querySelector('.language-text');
  if (!textNode) {
    textNode = document.createElement('span');
    textNode.className = 'language-text';
    // insert before the dropdown chevron if present
    // const chevron = Array.from(label.querySelectorAll('img')).find(img => /dropdown_icon\.svg(\?.*)?$/i.test(img.getAttribute('src') || ''));
    label.insertBefore(textNode, chevron || null);
  }

  // Set the text
  textNode.textContent = languageMap[currentLang] || currentLang.toUpperCase();

  // Remove any flag images inside the label (keep the chevron)
  //- Array.from(label.querySelectorAll('img')).forEach(img => {
  //-   const src = img.getAttribute('src') || '';
  //-   const isChevron = /dropdown_icon\.svg(\?.*)?$/i.test(src);
  //-   if (!isChevron) {
  //-     img.remove();
  //-   }
  //- });

  // Also nuke any pseudo-element flags applied via CSS (belt & suspenders)
  label.style.backgroundImage = 'none';
});

</script><script>(function() {
  // Funzioni di utilità per gestire i cookie
  function setCookie(name, value, days) {
    var expires = "";
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
      expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "") + expires + "; path=/";
  }

  function getCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  }

  // Controlla se il consenso è già stato dato per nascondere il banner
  function checkConsent() {
    if (getCookie('consent_necessary') === "true") {
      document.getElementById('cookie-banner').style.display = 'none';
    } else {
      document.getElementById('cookie-banner').style.display = 'flex';
    }
  }

  // Funzione per accettare tutti i cookie
  window.acceptCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'true', 365);
    setCookie('consent_marketing', 'true', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: true, consent_marketing: true});
  };

  // Funzione per rifiutare cookie opzionali (analytics e marketing)
  window.rejectCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'false', 365);
    setCookie('consent_marketing', 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: false, consent_marketing: false});
  };

  // Mostra il popup per gestire le preferenze dei cookie
  window.showCookiePopup = function(event) {
    event.preventDefault();
    document.getElementById('cookie-popup').style.display = 'flex';
  };
  window.closeCookiePopup = function() {
  document.getElementById('cookie-popup').style.display = 'none';
  };

  // Salva le preferenze impostate nel popup
  window.savePreferences = function() {
    var analyticsConsent = document.getElementById('analytics-cookies').checked;
    var marketingConsent = document.getElementById('marketing-cookies').checked;
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', analyticsConsent ? 'true' : 'false', 365);
    setCookie('consent_marketing', marketingConsent ? 'true' : 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: analyticsConsent, consent_marketing: marketingConsent});
  };

  // Inizializza il controllo del consenso al caricamento della pagina
  checkConsent();
})();</script></body></html>