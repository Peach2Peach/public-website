<!DOCTYPE html><html lang="it"><head><meta charset="UTF-8"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><meta http-equiv="X-Frame-Options" content="DENY"/><meta http-equiv="X-XSS-Protection" content="1; mode=block"/><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/><meta name="keywords" content="[&quot;Prodotto&quot;,&quot;P2P&quot;,&quot;tutorial&quot;,&quot;programmazione&quot;,&quot;javascript&quot;,&quot;bitcoin&quot;]"/><meta name="description" content="Aaaaah Bitcoin — questa meravigliosa forma di denaro che prospera grazie alle sue caratteristiche fondamentali.  
Tutti lo amiamo, ma sappiamo anche che ci sono rischi legati alla sovranità individuale: se condividi i tuoi seed, perdi tutto.  
Se invii fondi all’indirizzo sbagliato, non li rivedrai mai."/><meta property="og:locale" content="it"/><meta property="og:site_name"/><meta property="og:title" content="Peach Bitcoin Marketplace - Buy and Sell Bitcoin Anonymously and Without KYC"/><meta property="og:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Marketplace peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta property="og:type" content="website"/><meta property="og:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:secure_url" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:width" content="1296"/><meta property="og:image:height" content="678"/><meta name="twitter:site" content="@peachbitcoin"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Peach Bitcoin sotto il cofano: uno sguardo tecnico sul perché è lo scambio P2P più sicuro · Peach Bitcoin"/><meta name="twitter:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Marketplace peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and  without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta name="twitter:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta name="msapplication-TileColor" content="#F56522"/><meta name="cf-2fa-verify" content="e22767e30dc139c"/><meta name="theme-color" content="#F56522"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-regular.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-600.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-800.woff2"/><link rel="apple-touch-icon" href="/img/favicon/apple-touch-icon.png"/><link rel="icon" href="/img/favicon/favicon.svg"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/img/favicon/safari-pinned-tab.svg" color="#F56522"/><link rel="stylesheet" href="/css/main-97baa8fc56d9ccead3e5dd2528ce1a15.css"/><title>Peach Bitcoin sotto il cofano: uno sguardo tecnico sul perché è lo scambio P2P più sicuro · Peach Bitcoin</title><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KQHJRQKH');</script></head><body id="blog-peach-under-the-hood"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KQHJRQKH" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><header class="header header-container" id="header"><div class="wrap"><a class="logo-link brand" href="/it/"><img class="logo logo" src="/img/peach-bitcoin-145cd6c0079ccacc9c70c892060964d1.svg" alt="Peach Bitcoin"/></a><input id="show-menu" type="checkbox"/><label class="nav-toggle-label" id="nav-toggle" for="show-menu"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path class="line--1" d="M0 70l28-28c2-2 2-2 7-2h64"></path><path class="line--2" d="M0 50h99"></path><path class="line--3" d="M0 30l28 28c2 2 2 2 7 2h64"></path></svg></label><nav class="nav"><a href="/it/how-it-works/">Acquista BTC senza KYC</a><a href="/it/for-meetups/">Acquista BTC con contanti</a><a href="/it/for-businesses/">Vendi BTC</a><a href="/it/blog/">Blog</a><a href="/it/support/">Supporto</a><div class="language-selector"><input class="checkbox" type="checkbox" id="language-toggle"/><label class="language-label" for="language-toggle"><span class="language-text">Italiano</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="white" style="margin-left: .25rem;"><path d="M7 10l5 5 5-5z"></path></svg></label><ul class="language-dropdown"><li><a href="/"> <span>English</span></a></li><li><a href="/es"> <span>Español</span></a></li><li><a href="/de"> <span>Deutsch</span></a></li><li><a href="/it"> <span>Italiano</span></a></li><li><a href="/fr"> <span>Français</span></a></li><li><a href="/pt"> <span>Português</span></a></li></ul></div></nav></div></header><main class="main" id="main"><div id="header-anchor"></div><section class="wrap"><div class="content-wrap post"><h1 id="peach-bitcoin-sotto-il-cofano-uno-sguardo-tecnico-sul-perch-lo-scambio-p2p-pi-sicuro">Peach Bitcoin sotto il cofano: uno sguardo tecnico sul perché è lo scambio P2P più sicuro</h1>
<div class="video-wrapper">
  <iframe
    src="https://www.youtube.com/embed/UvdbHlsPmK0"
    title="PEACH VIDEO OF Under the Hood"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>
<p>Aaaaah Bitcoin — questa meravigliosa forma di denaro che prospera grazie alle sue caratteristiche fondamentali.<br>
Tutti lo amiamo, ma sappiamo anche che ci sono rischi legati alla sovranità individuale: se condividi i tuoi seed, perdi tutto.<br>
Se invii fondi all’indirizzo sbagliato, non li rivedrai mai.</p>
<p>Per questo è così importante il codice open source nell’ecosistema Bitcoin — l’app Peach è disponibile su Github per chiunque voglia controllarla!</p>
<p>Certo, open source non significa che tutti leggeranno il codice con attenzione o capiranno come funziona.<br>
Per questo scrivo questo articolo: per <strong>mostrare quanto Peach sia sicuro</strong> e quali passaggi garantiscono questa sicurezza.</p>
<h2 id="passo-1-creare-un-account-no-kyc-su-peach">Passo 1: Creare un account No-KYC su Peach</h2>
<p>Per essere chiari: il tuo seed Bitcoin <strong>è il tuo account Peach</strong>.</p>
<p>Se vuoi usare Peach, devi creare un account, il che consiste nel condividere la tua chiave pubblica e dimostrare di esserne il proprietario.</p>
<p>Per farlo, devi:</p>
<ul>
<li>1 - ottenere la data e l’ora correnti (in millisecondi) come testo</li>
<li>2 - usare la tua chiave privata per generare una firma di quel testo</li>
<li>3 - inviare la chiave pubblica, la data/ora corrente e la firma</li>
</ul>
<p>Devi anche generare un <code>uniqueId</code> per evitare che altri utenti si fingano te.<br>
Questo è utile, ad esempio, in caso di perdita dei seed mantenendo lo stesso account.<br>
Ma non soffermiamoci troppo su questo.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood01.png" alt="this is the power of p2p Marketplace" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<p>Ecco il codice in JavaScript:</p>
<pre><code class="language-j">
  const seed = randomBytes(64);

  const root = bip32.fromSeed(seed, bitcoin);
  const child = root.derivePath(&quot;m/0&quot;);
  const keyPair = ECPair.fromPrivateKey(child.privateKey, { network: bitcoin });

  const publicKeyHex = Buffer.from(keyPair.publicKey).toString(&quot;hex&quot;);

  const session = axios.create({
    baseURL: &quot;https://api.peachbitcoin.com/&quot;,
    httpAgent: new http.Agent({ keepAlive: false }),
    httpsAgent: new https.Agent({ keepAlive: false }),
  });

  const registerMessage = String(Date.now());
  const registerMessageSignature = signWithBtcPrivKey(registerMessage, keyPair);

  const resp = await session.post(&quot;v1/user/register&quot;, {
    publicKey: publicKeyHex,
    message: registerMessage,
    signature: registerMessageSignature,
    uniqueId: &quot;my_own_unique_id_random_12345&quot;,
  });

  const accessToken = resp.data.accessToken;

  session.defaults.headers.common[&quot;authorization&quot;] = accessToken;

</code></pre>
<p>Congratulazioni! Hai appena creato un account su Peach!<br>
Il server ha verificato che tu, in questo momento, sei il proprietario della coppia di chiavi Bitcoin corrispondente alla chiave pubblica inviata.</p>
<h2 id="passo-2-inviare-la-chiave-pubblica-pgp">Passo 2: Inviare la chiave pubblica PGP</h2>
<p>Ci sarà molta crittografia… ma anche un po’ di decrittazione.<br>
Le chiavi Bitcoin permettono solo crittografia unidirezionale, quindi useremo chiavi PGP per una crittografia bidirezionale.<br>
Questo è fondamentale per proteggere dati bancari, messaggi chat, ecc.</p>
<p>Inviare la chiave pubblica PGP è simile all’invio della chiave pubblica Bitcoin, ma con un passo in più:<br>
la chiave pubblica PGP deve essere <strong>firmata con la chiave privata Bitcoin</strong>, per confermare che l’utente possiede entrambe le chiavi.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood02.png" alt="this is the power of p2p Marketplace" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<pre><code class="language-j">
const { privateKey: pgpPrivateKey, publicKey: pgpPublicKey } =
    await createPGPKey();

  const pgpPublicKeyMessageSignature = signWithBtcPrivKey(
    pgpPublicKey,
    keyPair
  );
  const setPgpKeysMessage = String(Date.now());

  const setPgpKeysMessageSignature = await signPGPMessage(
    pgpPrivateKey,
    setPgpKeysMessage
  );

  await session.patch(&quot;v1/user&quot;, {
    pgpPublicKey: pgpPublicKey, // the PGP Pub key
    signature: pgpPublicKeyMessageSignature, // the above signed by the BTC Key
    message: setPgpKeysMessage, // the current timestamp
    pgpSignature: setPgpKeysMessageSignature, // the above signed by the PGP Key
  });

</code></pre>
<p>A questo punto, Peach ha entrambe le tue chiavi pubbliche — Bitcoin e PGP!<br>
Questo sarà molto rilevante per il trading su Peach.</p>
<h2 id="passaggi-successivi">Passaggi successivi</h2>
<p>Da questo punto in poi, il tutorial mostrerà entrambi i lati: Acquirente e Venditore.</p>
<p>I passaggi saranno:</p>
<ul>
<li>3.S Il Venditore crea un’offerta di vendita</li>
<li>4.S Il Venditore finanzia l’Escrow di Peach</li>
<li>5.B L’Acquirente fa una richiesta di scambio sull’offerta</li>
<li>5.S Il Venditore accetta la richiesta dell’Acquirente</li>
<li>6.B L’Acquirente dichiara di aver effettuato il pagamento Fiat</li>
<li>6.S Il Venditore conferma di aver ricevuto il pagamento</li>
</ul>
<h2 id="passo-3s-il-venditore-crea-unofferta-di-vendita">Passo 3.S: Il Venditore crea un’offerta di vendita</h2>
<p>Creare un’offerta di vendita significa annunciare che sei disposto a vendere una certa quantità di Bitcoin.<br>
Ma non è tutto: il Venditore deve anche accettare qualcosa in cambio.</p>
<p>Un’offerta di vendita include:</p>
<ul>
<li>la quantità di Bitcoin da vendere</li>
<li>le valute accettate dal Venditore</li>
<li>i metodi di pagamento accettati (contanti, bonifico bancario, Revolut, ecc.)</li>
<li>il premio (quanto il Bitcoin è più costoso rispetto al prezzo di mercato attuale)</li>
</ul>
<p>Se tutto va bene, un Acquirente sarà interessato e richiederà di scambiare.<br>
A quel punto dovrà selezionare <strong>una sola valuta e un solo metodo di pagamento</strong> tra quelli disponibili.<br>
Più il Venditore mostra opzioni, più probabilità ha di attirare un Acquirente.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood03.png" alt="this is the power of p2p Marketplace" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">
const sats_to_sell = 21000;
  const sell_premium = 1; // 1%
  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

  const { address: returnAddress } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });
  const sellOfferPaymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@myWiseIdTradingBot&quot;,
  });

  const paymentDataEncryptSHA256 = await sha256(sellOfferPaymentDataToEncrypt);

  const offerCreateRes = await session.post(&quot;v1/offer&quot;, {
    type: &quot;ask&quot;,
    amount: sats_to_sell,
    meansOfPayment: { [payment_data_currency]: [payment_data_method] }, // {&quot;EUR&quot;: [&quot;wise&quot;]}
    paymentData: {
      [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
    },
    returnAddress: returnAddress,
    premium: sell_premium,
  });

</code></pre>
<p>Nel codice, il Venditore annuncia la vendita di 21.000 sats (0,00021 Bitcoin) con un premio dell’1%.<br>
Vuole ricevere Euro tramite il suo account Wise.<br>
Non sta inviando il suo ID Wise, solo un hash.<br>
Peach non conoscerà mai i dettagli del metodo di pagamento, per mantenere l’anonimato.<br>
Viene anche inviata un’<strong>indirizzo di ritorno</strong>, utilizzato in caso di rimborso.</p>
<h2 id="passo-4s-il-venditore-finanzia-lescrow-di-peach">Passo 4.S: Il Venditore finanzia l’Escrow di Peach</h2>
<p>Dopo una richiesta API riuscita per creare l’offerta, il Venditore ottiene l’ID dell’offerta:</p>
<pre><code class="language-j">const sellOfferId = offerCreateRes.data.id;

</code></pre>
<p>Questo valore è importante — conservalo.<br>
L’offerta è stata creata ma non è ancora pubblica: nessun Acquirente può interagire.<br>
Prima il Venditore deve finanziare l’Escrow.</p>
<p>L’Escrow è come una cassaforte che richiede l’autorizzazione sia del Venditore che di Peach.<br>
Il Bitcoin viene inserito nella cassaforte e rimane al sicuro fino alla fine del Trade.<br>
Poiché richiede l’autorizzazione del Venditore e l’Escrow è uno script sulla Blockchain Bitcoin (un indirizzo P2WSH), Peach ha bisogno della chiave pubblica del Venditore per creare l’Escrow.</p>
<p>A questo punto, il Venditore invia la chiave pubblica da usare per l’Escrow.<br>
Peach seleziona la propria chiave pubblica e costruisce l’indirizzo.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood04.png" alt="this is the power of p2p Marketplace" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">const childSell = root.derivePath(`m/84'/0'/0'/${sellOfferId}'`);

  const keyPairSellOffer = ECPair.fromPrivateKey(childSell.privateKey, {
    network: bitcoin,
  });

  const sellOfferPublicKey = Buffer.from(keyPairSellOffer.publicKey).toString(
    &quot;hex&quot;
  );

  const escrowCreateRes = await session.post(
    &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;,
    {
      publicKey: sellOfferPublicKey,
    }
  );

  const escrowAddress = escrowCreateRes.data.escrows.bitcoin;

  const escrowPeachPublicKey =
    escrowCreateRes.data.escrowPeachPublicKey.bitcoin;

</code></pre>
<p>Nel codice, il Venditore ha derivato una nuova coppia di chiavi dall’ID dell’offerta.<br>
Questo è un approccio sicuro e riproducibile.</p>
<p>Dopo l’invio della chiave pubblica, l’API Peach restituisce l’indirizzo dove inviare i 21.000 sats.<br>
Ma non devi fidarti ciecamente: puoi verificarlo tu stesso.</p>
<p>Verifichiamolo!</p>
<p>L’API restituisce anche la chiave pubblica che Peach ha usato per quell’Escrow, così possiamo <strong>ricreare l’indirizzo</strong> scrivendo lo script Bitcoin.</p>
<pre><code class="language-j">   OP_IF
       ${script.number.encode(4320).toString(&quot;hex&quot;)}
       OP_CHECKSEQUENCEVERIFY
       OP_DROP
   OP_ELSE
       ${sellerPublicKey}
       OP_CHECKSIGVERIFY
   OP_ENDIF
   ${peachPublicKey}
   OP_CHECKSIG
</code></pre>
<p>Lo script per l’Escrow:</p>
<ul>
<li>richiede sempre la firma di Peach</li>
<li>e poi:
<ul>
<li>richiede la firma del Venditore</li>
<li>oppure che siano stati minati 4320 blocchi dopo l’invio del Bitcoin</li>
</ul>
</li>
</ul>
<p>Perché 4320 blocchi?<br>
Sono circa 30 giorni di blocchi (1 blocco ogni 10 minuti).<br>
Dopo un mese Peach può firmare da sola, in caso il Venditore non sia collaborativo o perda le chiavi.</p>
<p>Peach ha una reputazione impeccabile nella gestione dei fondi dei Venditori.</p>
<p>Una volta costruito lo script, puoi verificare che l’indirizzo P2WSH generato corrisponda a quello restituito dall’API Peach.</p>
<pre><code class="language-j">  const multisigScript = bitcoin.script.compile([
    Buffer.from(sellOfferPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIGVERIFY,
  ]);

  const timelockScript = bitcoin.script.compile([
    bitcoin.script.number.encode(4320),
    bitcoin.opcodes.OP_CHECKSEQUENCEVERIFY,
    bitcoin.opcodes.OP_DROP,
  ]);

  const redeemScript = bitcoin.script.compile([
    bitcoin.opcodes.OP_IF,
    ...timelockScript,
    bitcoin.opcodes.OP_ELSE,
    ...multisigScript,
    bitcoin.opcodes.OP_ENDIF,
    Buffer.from(escrowPeachPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIG,
  ]);

  const escrowPayment = bitcoin.payments.p2wsh({
    redeem: { output: redeemScript },
    network: bitcoin,
  });

  console.log(&quot;Addresses Match:&quot;, escrowPayment.address === escrowAddress);

</code></pre>
<p>Perfetto! Ora invia una transazione Bitcoin a quell’indirizzo e aspetta che l’Escrow sia dichiarato finanziato.</p>
<pre><code class="language-j">  while (true) {
    const fundingStatusRes = await session.get(
      &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;
    );
    if (fundingStatusRes.data.funding.status === &quot;FUNDED&quot;) {
      break;
    }
  }

</code></pre>
<p>Dopo un blocco, l’offerta diventa pubblica e gli Acquirenti possono interagire.</p>
<h2 id="passo-5b-lacquirente-fa-una-richiesta-di-scambio">Passo 5.B: L’Acquirente fa una richiesta di scambio</h2>
<p>Ora è il turno dell’Acquirente!</p>
<p>Per prima cosa, controlla tutte le offerte disponibili:</p>
<pre><code class="language-j">const sellOffers = await session.get(&quot;v069/sellOffer&quot;);
</code></pre>
<p>Per semplicità, l’Acquirente sceglie la prima offerta disponibile.</p>
<pre><code class="language-j">const sellOfferToTradeRequestId = sellOffers.data.offers[0].id;
</code></pre>
<p>L’Acquirente invia la richiesta di scambio, indicando di voler acquistare secondo le condizioni del Venditore.<br>
Sembra semplice, ma è <strong>il passo più complesso</strong> di tutto il processo.</p>
<p>L’Acquirente deve inviare:</p>
<ul>
<li>metodo di pagamento preferito</li>
<li>valuta preferita</li>
<li>chiave simmetrica (per comunicare con il Venditore) crittografata</li>
<li>firma della chiave simmetrica</li>
<li>dati di pagamento crittografati con la chiave simmetrica</li>
<li>firma dei dati di pagamento</li>
<li>indirizzo di ricezione del Bitcoin acquistato</li>
<li>firma di possesso dell’indirizzo (BIP-322)</li>
<li>fee massima di mining che l’Acquirente è disposto a pagare</li>
</ul>
<p>Molto, vero?<br>
Ma è ciò che rende Peach super sicuro!<br>
Procediamo passo passo.</p>
<h3 id="metodo-di-pagamento-e-valuta">Metodo di pagamento e valuta</h3>
<p>È la parte più semplice:</p>
<pre><code class="language-j">  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

</code></pre>
<h3 id="chiave-simmetrica">Chiave simmetrica</h3>
<p>La chiave simmetrica sarà usata con crittografia bidirezionale AES256: puoi criptare e decriptare con la stessa chiave.</p>
<pre><code class="language-j">async function decryptDataWithSymmetricKey(encryptedMessage, symmetricKey) {
  const message = await openpgp.readMessage({
    armoredMessage: encryptedMessage,
  });

  const { data: decrypted } = await openpgp.decrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;utf8&quot;,
  });

  return decrypted;
}

async function encryptDataWithSymmetricKey(data, symmetricKey) {
  const message = await openpgp.createMessage({ text: data });
  const encrypted = await openpgp.encrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;armored&quot;,
    config: {
      preferredSymmetricAlgorithm: openpgp.enums.symmetric.aes256,
    },
  });
  return encrypted;
}

</code></pre>
<p>Generane una casuale:</p>
<pre><code class="language-j">  const symmetricKey = randomBytes(32);
  const symmetricKeyHex = symmetricKey.toString(&quot;hex&quot;);

</code></pre>
<p>Non inviare questa chiave in chiaro!<br>
Deve essere crittografata in modo che solo Acquirente e Venditore possano decriptarla, usando le chiavi pubbliche PGP.</p>
<pre><code class="language-j">async function encryptForMultipleRecipients(secret, publicKeysArmored) {
  const publicKeys = await Promise.all(
    publicKeysArmored.map((armored) =&gt; openpgp.readKey({ armoredKey: armored }))
  );
  const message = await openpgp.createMessage({ text: secret });

  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: publicKeys,
  });

  return encrypted;
}

  const matchingUserPgpPubKey = sellOffers.data.offers[0].user.pgpPublicKey;

  const symmetricKeyEncrypted = await encryptForMultipleRecipients(
    symmetricKeyHex,
    [pgpPublicKey, matchingUserPgpPubKey]
  );

</code></pre>
<p>Il Venditore firma la chiave per confermare che proviene dall’Acquirente:</p>
<pre><code class="language-j">  const symmetricKeySignature = await signPGPMessage(
    pgpPrivateKey,
    symmetricKeyHex
  );

</code></pre>
<h3 id="dati-di-pagamento">Dati di pagamento</h3>
<p>Qui ci sono le informazioni più sensibili: IBAN, username Revolut, ecc.<br>
L’Acquirente le cripta con la chiave simmetrica, così solo il Venditore può leggerle.</p>
<pre><code class="language-j">const paymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@buyerWiseId&quot;,
  });

const paymentDataEncrypted = await encryptDataWithSymmetricKey(
paymentDataToEncrypt,
symmetricKeyHex
);

const paymentDataSignature = await signPGPMessage(
pgpPrivateKey,
paymentDataToEncrypt
);

</code></pre>
<h3 id="indirizzo-di-ricezione-e-prova-di-propriet">Indirizzo di ricezione e prova di proprietà</h3>
<p>Definisci dove vuoi ricevere il Bitcoin.<br>
Creare un indirizzo è facile; provare la proprietà è più complesso.<br>
Questo serve a scopi regolatori e di sicurezza (protezione contro l’attacco “address replacement”).</p>
<p>La prova avviene tramite <strong>BIP-322</strong>: firmi un messaggio con la tua chiave privata Bitcoin, verificabile dall’indirizzo.</p>
<pre><code class="language-j">  const { address } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });

  const ownershipMessage =
    &quot;I confirm that only I, peach&quot; +
    publicKeyHex.slice(0, 8) +
    &quot;, control the address &quot; +
    address;

  const releaseAddressSignature = signWithBIP322(
    wif,
    address,
    ownershipMessage
  );

</code></pre>
<h3 id="fee-massima-di-mining">Fee massima di mining</h3>
<p>L’Acquirente può limitare quanto è disposto a spendere di fee per ottenere il Bitcoin.</p>
<h3 id="invia-la-richiesta-di-scambio">Invia la richiesta di scambio</h3>
<p>Ora tutto è pronto, e l’Acquirente invia la richiesta.</p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; + sellOfferToTradeRequestId + &quot;/tradeRequestPerformed&quot;,
    {
      paymentMethod: payment_data_method,
      currency: payment_data_currency,
      paymentDataHashed: paymentDataToEncryptSHA256,
      paymentDataEncrypted: paymentDataEncrypted,
      paymentDataSignature: paymentDataSignature,
      symmetricKeyEncrypted: symmetricKeyEncrypted,
      symmetricKeySignature: symmetricKeySignature,
      maxMiningFeeRate: 2, // sats/vb
      releaseAddress: address,
      releaseAddressMessageSignature: releaseAddressSignature,
    }
  );

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood05.png" alt="this is the power of p2p Marketplace" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Il turno passa al Venditore.</p>
<h2 id="passo-5s-il-venditore-accetta-la-richiesta">Passo 5.S: Il Venditore accetta la richiesta</h2>
<p>Il Venditore controlla le richieste ricevute:</p>
<pre><code class="language-j">const receivedTradeRequestRequest = await session.get(
    &quot;v069/sellOffer/&quot; + sellOfferId + &quot;/tradeRequestReceived&quot;
  );

  const tradeReq = receivedTradeRequestRequest.data[0];

</code></pre>
<p>Se decide di accettare, condivide i propri dati di pagamento con l’Acquirente.<br>
Poiché l’Acquirente ha già inviato una chiave simmetrica, il Venditore può decriptarla e usarla per criptare i propri dati di pagamento.</p>
<pre><code class="language-j">  const receivedSymmetricKey = await decryptWithPrivateKey(
    tradeReq.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  const sellOfferPaymentDataEncrypted = await encryptDataWithSymmetricKey(
    sellOfferPaymentDataToEncrypt,
    receivedSymmetricKey
  );

  const sellOfferPaymentDataSignature = await signPGPMessage(
    pgpPrivateKey,
    sellOfferPaymentDataToEncrypt
  );

</code></pre>
<p>A questo punto, l’offerta è ufficialmente accettata e inizia lo scambio.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood06.png" alt="this is the power of p2p Marketplace" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; +
      sellOfferId +
      &quot;/tradeRequestReceived/&quot; +
      tradeReq.userId +
      &quot;/accept&quot;,
    {
      paymentDataEncrypted: sellOfferPaymentDataEncrypted,
      paymentDataSignature: sellOfferPaymentDataSignature,
      paymentData: {
        [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
      },
    }
  );

</code></pre>
<p>Se tutto il processo è complesso, ecco un’immagine che lo illustra:</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood07.png" alt="this is the power of p2p Marketplace" style="display:block; margin: auto; width: 90%;">
<br><br></p>
<h2 id="passo-6b-lacquirente-dichiara-il-pagamento">Passo 6.B: L’Acquirente dichiara il pagamento</h2>
<p>L’Acquirente può controllare i contratti attivi tramite l’endpoint API <code>contract summaries</code>:</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data.find((obj) =&gt;
    obj.id.startsWith(sellOfferToTradeRequestId + &quot;-&quot;)
  );

  if (contract.tradeStatus !== &quot;paymentRequired&quot;) throw Error;
</code></pre>
<p>Se lo stato di un contratto è <strong>“paymentRequired”</strong>, deve procedere al pagamento Fiat.</p>
<p>Per farlo, decripta i dati del Venditore usando la chiave simmetrica.<br>
Se ha perso la chiave, può usare la propria chiave privata PGP.</p>
<pre><code class="language-j">
  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

  const receivedSymmetricKey = await decryptWithPrivateKey(
    contractRes.data.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  if (receivedSymmetricKey !== symmetricKeyHex) throw Error;

  const decryptedSellerPaymentData = await decryptDataWithSymmetricKey(
    contractRes.data.paymentDataEncrypted,
    receivedSymmetricKey
  );

  console.log(&quot;Seller Payment Data &quot;, JSON.parse(decryptedSellerPaymentData));
</code></pre>
<p>Questo avviene al di fuori di Peach: l’Acquirente apre la propria app bancaria e invia il pagamento Fiat ai dati del Venditore.</p>
<p>Il Bitcoin è già nell’Escrow, controllato da Peach e dal Venditore.<br>
Puoi verificare l’indirizzo Escrow con un Blockchain Explorer.</p>
<p>Dopo il pagamento, l’Acquirente dichiara l’avvenuto pagamento:</p>
<pre><code class="language-j">  const confirmPaymentRes = await session.post(
    &quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;
  );
</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood08.png" alt="this is the power of p2p Marketplace" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Questo conclude il passo dell’Acquirente.<br>
Ora il Venditore conferma il pagamento e rilascia il Bitcoin.</p>
<h2 id="passo-6s-il-venditore-conferma-il-pagamento">Passo 6.S: Il Venditore conferma il pagamento</h2>
<p>Il Venditore controlla i contratti a lui assegnati:</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data[0];

  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

</code></pre>
<p>La risposta API include una <strong>PSBT</strong> (Partial Signed Bitcoin Transaction)<br>
che invia il Bitcoin dell’Escrow all’indirizzo dell’Acquirente.<br>
È già firmata da Peach, manca solo la firma del Venditore.</p>
<pre><code class="language-j">  const releasePSBTBase64 = contractRes.data.releasePsbt;

  const parsedPSBT = bitcoin.Psbt.fromBase64(releasePSBTBase64, {
    network: bitcoin,
  });

  parsedPSBT.signInput(0, childSell);

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood09.png" alt="this is the power of p2p Marketplace" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Il Venditore aggiunge la firma e lo script dell’Escrow.<br>
Usiamo la MultiSig: inseriamo <code>OP_FALSE</code> nello stack per influenzare correttamente l’IF.</p>
<pre><code class="language-j">export const getFinalScript = (_inputIndex, input, bitcoinScript) =&gt; {
  const network = bitcoin;

  const payment = payments.p2wsh({
    network,
    redeem: {
      network,
      output: bitcoinScript,
      input: bitcoin.script.compile([
        input.partialSig[0].signature,
        input.partialSig[1].signature,
        opcodes.OP_FALSE,
      ]),
    },
  });

  parsedPSBT.finalizeInput(0, getFinalScript);

  const tx = parsedPSBT.extractTransaction().toHex();

</code></pre>
<p>Infine, l’Elvatore invia la transazione completa all’API Peach:</p>
<pre><code class="language-j">  await session.post(&quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;, {
    releaseTransaction: tx,
  });

</code></pre>
<p>Signore e signori, ecco come si fa trading su Peach con <strong>massima sicurezza e privacy!</strong></p>
<p class="date">October 23rd, 2025</p><p class="tags">Tagged with:<a href="/it/blog/tag/prodotto">Prodotto</a><a href="/it/blog/tag/p2p">P2P</a><a href="/it/blog/tag/tutorial">Tutorial</a></p><p><a href="/it/blog/">All blog posts</a></p></div></section></main><footer class="footer" id="footer"><div class="wrap"><div class="logo-section"><div class="logo"><img class="logo-image" src="/img/peach-footer-logo-e28fd7e07f654f43afd63c9b6ace3cdb.svg" alt="Peach logo"/><span>Made in Switzerland <img src="/img/flags/switzerland-icon.svg" style="width: 1rem; margin-left .5rem;"/></span></div><div class="company-info"> <img class="polyreg-image" src="/img/polyreg-52ec37fb80d0312b219110c05567ad3d.png" alt="Polyreg logo" width="120"/><p>Peach è un membro SRO (Organizzazione di Autoregolamentazione) di Polyreg </p><p>Peach è un fornitore di servizi finanziari autorizzato in Svizzera ed è pienamente conforme alla Legge Svizzera contro il Riciclaggio di Denaro. </p></div></div><div class="content"><div class="footer-box"><h6>Azienda</h6><a href="/it/join-us/">Unisciti a noi</a><a href="/it/terms-and-conditions/">Termini e Condizioni</a><a href="/it/privacy-policy/">Informativa sulla Privacy</a><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Gestisci le preferenze dei cookie</a></div><div class="footer-box"><h6>Contatto</h6><a href="mailto:hello@peachbitcoin.com">Email</a><a href="https://keys.openpgp.org/vks/v1/by-fingerprint/48339A19645E2E53488E0E5479E1B270FACD1BD2">Chiave PGP</a></div><div class="footer-box"><h6>Download</h6><span>0.69.0 (321)</span><a href="/it/apk/">APK</a><a href="https://testflight.apple.com/join/wfSPFEWG">iPhone</a><a href="https://play.google.com/store/apps/details?id=com.peachbitcoin.peach.mainnet">Android</a></div><div class="footer-box"><h6>Comunità</h6><a href="https://twitter.com/peachbitcoin" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://t.me/peachtopeach" target="_blank" rel="noreferrer noopener">Telegram</a><a href="https://discord.gg/ypeHz3SW54" target="_blank" rel="noreferrer noopener">Discord</a><a href="https://www.instagram.com/peachbitcoin/" target="_blank" rel="noreferrer noopener">Instagram</a><a href="https://snort.social/p/npub15369wu3wzzar5fclhecyqfv683x69n6nhlg7rxqnsg2dydgxflpq3apswl" target="_blank" rel="noreferrer noopener">Nostr</a><a href="https://github.com/Peach2Peach" target="_blank" rel="noreferrer noopener">Github</a><a href="https://www.youtube.com/@peachbitcoin" target="_blank" rel="noreferrer noopener">YouTube</a></div><div class="footer-box"><h6>Bitcoin</h6><a href="/bitcoin.pdf">Whitepaper</a><a href="https://docs.peachbitcoin.com">API Docs</a></div><div class="footer-box"><h6>Guadagna Bitcoin</h6><a href="/it/new-users/">Codice di Riferimento</a><a href="/it/for-businesses/">Diventa un Affiliato</a></div></div></div></footer><style>#cookie-banner {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: #120A07;
  color: #fff;
  padding: 15px 0;
  z-index: 9999;
  font-size: 14px;
}
#cookie-banner .cookie-container {
  width: 90%;
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
}
#cookie-banner p {
  margin: 0;
  line-height: 1.4;
}
#cookie-banner .cookie-actions {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}
#cookie-banner button {
  padding: 10px 16px;
  color: #fff;
  background-color: #65A519;
  border: none;
  cursor: pointer;
  border-radius: 4px;
  font-size: 14px;
  transition: background-color 0.3s ease;
}
#cookie-banner button:hover {
  background-color: #65A519;
}
#cookie-banner button.reject {
  background-color: #DF321F;
}
#cookie-banner button.reject:hover {
  background-color: #DF321F;
}
#cookie-banner a.cookie-link {
  color: #fff;
  text-decoration: underline;
  font-size: 14px;
  margin-left: 8px;
  cursor: pointer;
}
#cookie-banner a.cookie-link:hover {
  text-decoration: none;
}
/* Popup overlay */
#cookie-popup {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  z-index: 10000;
  justify-content: center;
  align-items: center;
  color: #fff;
}
/* Contenitore del popup */
#cookie-popup-content {
  position: relative;
  background-color: #120A07;
  color:rgb(255, 255, 255);
  padding: 30px 20px 20px;
  border-radius: 10px;
  width: 80%;
  max-width: 600px;
  box-sizing: border-box;
}
/* Pulsante di chiusura */
#cookie-popup-content .close-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  color: #fff;
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  padding: 0 5px;
}
#cookie-popup-content .close-btn:hover {
  color: #ccc;
}
/* Stile per ciascuna categoria di cookie */
.cookie-category {
  margin-bottom: 20px;
}
/* Migliora i checkbox e le label */
.cookie-category label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 15px;
}
.cookie-category input[type="checkbox"] {
  accent-color: #4CAF50;
  margin: 0;
  cursor: pointer;
}
.cookie-category p {
  margin: 4px 0 0 28px;
  font-size: 14px;
  line-height: 1.4;
  color: #ccc;
}
/* Bottone "Salva Preferenze" */
#cookie-popup-content button.save-btn {
  background-color: #4CAF50;
  border: none;
  padding: 10px 16px;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}
#cookie-popup-content button.save-btn:hover {
  background-color: #43a047;
}
/* Media query per schermi più piccoli */
@media (max-width: 768px) {
  #cookie-banner .cookie-container {
    flex-direction: column;
    align-items: flex-start;
  }
  #cookie-banner .cookie-actions {
    margin-top: 10px;
    width: 100%;
    justify-content: flex-start;
    gap: 8px;
    flex-wrap: wrap;
  }
}

</style><div id="cookie-banner" style="display: none;"><div class="cookie-container"><p>Utilizziamo i cookie per migliorare la tua esperienza. <a href="/privacy-policy" style="color: #4CAF50;">Scopri di più</a></p><div class="cookie-actions"><button class="cookie-btn" onclick="acceptCookies()">Accetta i Cookie &amp; Continua</button><button class="cookie-btn reject" onclick="rejectCookies()">Rifiuta i Cookie</button><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Gestisci i Cookie</a></div></div></div><div id="cookie-popup"><div id="cookie-popup-content"><button class="close-btn" type="button" onclick="closeCookiePopup()">×</button><h2>Gestisci le preferenze dei cookie</h2><div class="cookie-category"><div class="switch-container"><span class="label-text">Cookie Necessari</span><label class="switch" for="necessary-cookies"><input type="checkbox" id="necessary-cookies" checked="checked" disabled="disabled"/><span class="slider"></span></label></div><p>Questi cookie sono essenziali per il funzionamento del sito.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Cookie di Analisi</span><label class="switch" for="analytics-cookies"><input type="checkbox" id="analytics-cookies"/><span class="slider"></span></label></div><p>I cookie di analisi ci aiutano a capire come gli utenti interagiscono con il sito.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Cookie di Marketing</span><label class="switch" for="marketing-cookies"><input type="checkbox" id="marketing-cookies"/><span class="slider"></span></label></div><p>I cookie di marketing vengono utilizzati per raccogliere le informazioni degli utenti</p></div><div style="text-align: right; margin-top: 20px;"><button class="save-btn" type="button" onclick="savePreferences()">Salva Preferenze</button></div></div></div><script src="/js/main-15c0432b5e5f06cbab9e3fedcaae3032.js"></script><!-- Service worker registration--><script>if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/service-worker.js')
      .then(function(registration) {
        console.log('Service Worker registrato con successo:', registration);
      })
      .catch(function(error) {
        console.log('Registrazione del Service Worker fallita:', error);
      });
  });
} else {
  console.log('Service Worker non supportato in questo browser.');
}
</script><!-- Language selector JS--><script>document.addEventListener('DOMContentLoaded', function () {
  const languageMap = {
    en: 'English',
    es: 'Español',
    de: 'Deutsch',
    it: 'Italiano',
    fr: 'Français',
    pt: 'Português',
  };

  const path = window.location.pathname.replace(/\/+$/, '');
  let currentLang = 'en';
  for (const code in languageMap) {
    if (path === '/' && code === 'en') { currentLang = 'en'; break; }
    if (path === `/${code}` || path.startsWith(`/${code}/`)) { currentLang = code; break; }
  }

  const label = document.querySelector('.language-label');
  if (!label) return;

  let textNode = label.querySelector('.language-text');
  if (!textNode) {
    textNode = document.createElement('span');
    textNode.className = 'language-text';
    label.insertBefore(textNode, label.firstChild || null);
  }

  textNode.textContent = languageMap[currentLang] || currentLang.toUpperCase();
  label.style.backgroundImage = 'none';
});
</script><!-- Cookie banner / popup JS--><script>(function() {
  function setCookie(name, value, days) {
    var expires = "";
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
      expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "") + expires + "; path=/";
  }

  function getCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  }

  function checkConsent() {
    if (getCookie('consent_necessary') === "true") {
      document.getElementById('cookie-banner').style.display = 'none';
    } else {
      document.getElementById('cookie-banner').style.display = 'flex';
    }
  }

  window.acceptCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'true', 365);
    setCookie('consent_marketing', 'true', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: true, consent_marketing: true});
  };

  window.rejectCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'false', 365);
    setCookie('consent_marketing', 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: false, consent_marketing: false});
  };

  window.showCookiePopup = function(event) {
    event.preventDefault();
    document.getElementById('cookie-popup').style.display = 'flex';
  };
  window.closeCookiePopup = function() {
    document.getElementById('cookie-popup').style.display = 'none';
  };

  window.savePreferences = function() {
    var analyticsConsent = document.getElementById('analytics-cookies').checked;
    var marketingConsent = document.getElementById('marketing-cookies').checked;
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', analyticsConsent ? 'true' : 'false', 365);
    setCookie('consent_marketing', marketingConsent ? 'true' : 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: analyticsConsent, consent_marketing: marketingConsent});
  };

  checkConsent();
})();</script></body></html>