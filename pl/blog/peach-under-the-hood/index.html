<!DOCTYPE html><html lang="pl"><head><meta charset="UTF-8"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><meta http-equiv="X-Frame-Options" content="DENY"/><meta http-equiv="X-XSS-Protection" content="1; mode=block"/><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/><meta name="keywords" content="[&quot;Produkt&quot;,&quot;P2P&quot;,&quot;poradnik&quot;,&quot;programowanie&quot;,&quot;javascript&quot;,&quot;bitcoin&quot;]"/><meta name="description" content="Aaaaah Bitcoin — ta wspaniała forma pieniędzy, która rozwija się dzięki swoim podstawowym funkcjom.  
Wszyscy go kochamy, ale wiemy też, że istnieją ryzyka związane z samostanowieniem: jeśli udostępnisz swoje seed, tracisz wszystko.  
Wyślesz na niewłaściwy adres, i nigdy tego nie odzyskasz."/><meta property="og:locale" content="pl"/><meta property="og:site_name"/><meta property="og:title" content="Peach Bitcoin Exchange - Buy and Sell Bitcoin Anonymously and Without KYC"/><meta property="og:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta property="og:type" content="website"/><meta property="og:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:secure_url" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:width" content="1296"/><meta property="og:image:height" content="678"/><meta name="twitter:site" content="@peachbitcoin"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Peach Bitcoin „pod maską”: techniczne spojrzenie na to, dlaczego jest najbezpieczniejszą giełdą P2P · Peach Bitcoin"/><meta name="twitter:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and  without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta name="twitter:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta name="msapplication-TileColor" content="#F56522"/><meta name="theme-color" content="#F56522"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-regular.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-600.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-800.woff2"/><link rel="apple-touch-icon" href="/img/favicon/apple-touch-icon.png"/><link rel="icon" href="/img/favicon/favicon.svg"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/img/favicon/safari-pinned-tab.svg" color="#F56522"/><link rel="stylesheet" href="/css/main-8c7d0a0965d37fafcf6e9215d363177f.css"/><title>Peach Bitcoin „pod maską”: techniczne spojrzenie na to, dlaczego jest najbezpieczniejszą giełdą P2P · Peach Bitcoin</title><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KQHJRQKH');</script></head><body id="blog-peach-under-the-hood"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KQHJRQKH" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><header class="header header-container" id="header"><div class="wrap"><a class="logo-link brand" href="/pl/"><img class="logo logo" src="/img/peach-bitcoin-145cd6c0079ccacc9c70c892060964d1.svg" alt="Peach Bitcoin"/></a><input id="show-menu" type="checkbox"/><label class="nav-toggle-label" id="nav-toggle" for="show-menu"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path class="line--1" d="M0 70l28-28c2-2 2-2 7-2h64"></path><path class="line--2" d="M0 50h99"></path><path class="line--3" d="M0 30l28 28c2 2 2 2 7 2h64"></path></svg></label><nav class="nav"><a href="/pl/how-it-works/">Kupuj BTC bez KYC</a><a href="/pl/for-meetups/">Kupuj BTC za gotówkę</a><a href="/pl/for-businesses/">Sprzedawaj BTC</a><a href="/pl/blog/">Blog</a><a href="/pl/support/">Wsparcie</a><div class="language-selector"><input class="checkbox" type="checkbox" id="language-toggle"/><label class="language-label" for="language-toggle"><img class="flag-icon" src="/img/en-872bf10f0d1ed191b502494534bb329a.png" alt="UK Flag"/><img src="/img/dropdown_icon-fcd9aa7055472ef4a4e83b593450c048.svg" style="width: 1rem;" alt="Dropdown icon"/></label><ul class="language-dropdown"><li><a href="/"><img class="flag-icon" src="/img/en-872bf10f0d1ed191b502494534bb329a.png" alt="EN Flag"/><span>English</span></a></li><li><a href="/es"><img class="flag-icon" src="/img/es-b17fc8846b93c5446b10cd7824434504.png" alt="ES Flag"/><span>Español</span></a></li><li><a href="/de"><img class="flag-icon" src="/img/de-0da84d0f3850d6e25088debeb3ade32c.png" alt="DE Flag"/><span>Deutsch</span></a></li><li><a href="/it"><img class="flag-icon" src="/img/it-299996a0097e49e1bc4f312e380d3faa.png" alt="IT Flag"/><span>Italiano</span></a></li><li><a href="/fr"><img class="flag-icon" src="/img/fr-75a63faa5728ac4175214da6cd3c47f1.png" alt="FR Flag"/><span>Français</span></a></li><li><a href="/el"><img class="flag-icon" src="/img/el-27d234921e954ed945c93bef880a07b6.png" alt="GR Flag"/><span>Ελληνικά</span></a></li><li><a href="/hu"><img class="flag-icon" src="/img/hu-fc4c517f481932d60d59b56a8f0c322d.png" alt="HU Flag"/><span>Magyar</span></a></li><li><a href="/nl"><img class="flag-icon" src="/img/nl-83a65573b2d26cdce16cab98f8c38db1.png" alt="NL Flag"/><span>Nederlands</span></a></li><li><a href="/pl"><img class="flag-icon" src="/img/pl-f7c03eb5351f5b2e33c9b29f1e200e38.png" alt="PL Flag"/><span>Polski</span></a></li><li><a href="/pt"><img class="flag-icon" src="/img/pt-997fb3879120a45e1ba507a9e060a662.png" alt="PT Flag"/><span>Português</span></a></li><li><a href="/sw"><img class="flag-icon" src="/img/sw-cdf6e2b06778f5ac662fb25f3ca8eac0.png" alt="SW Flag"/><span>Kiswahili</span></a></li><li><a href="/uk"><img class="flag-icon" src="/img/ua-f7a81ef67d0931a29f7e358bb99ef521.png" alt="UA Flag"/><span>Українська</span></a></li></ul></div></nav></div></header><main class="main" id="main"><div id="header-anchor"></div><section class="wrap"><div class="content-wrap post"><h1 id="peach-bitcoin-pod-mask-techniczne-spojrzenie-na-to-dlaczego-jest-najbezpieczniejsz-gied-p2p">Peach Bitcoin „pod maską”: techniczne spojrzenie na to, dlaczego jest najbezpieczniejszą giełdą P2P</h1>
<div class="video-wrapper">
  <iframe
    src="https://www.youtube.com/embed/UvdbHlsPmK0"
    title="PEACH VIDEO OF Under the Hood"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>
<p>Aaaaah Bitcoin — ta wspaniała forma pieniędzy, która rozwija się dzięki swoim podstawowym funkcjom.<br>
Wszyscy go kochamy, ale wiemy też, że istnieją ryzyka związane z samostanowieniem: jeśli udostępnisz swoje seed, tracisz wszystko.<br>
Wyślesz na niewłaściwy adres, i nigdy tego nie odzyskasz.</p>
<p>Dlatego open-source’owe oprogramowanie w ekosystemie Bitcoin jest tak ważne — aplikacja Peach jest dostępna na GitHub dla każdego, kto chce ją sprawdzić!</p>
<p>Oczywiście bycie open-source nie oznacza, że wszyscy będą dokładnie czytać kod i analizować jego mechanizmy.<br>
Dlatego piszę ten artykuł: aby <strong>pokazać, jak bezpieczna jest Peach</strong> i jakie kroki zapewniają to bezpieczeństwo.</p>
<h2 id="krok-1-tworzenie-konta-bez-kyc-w-peach">Krok 1: Tworzenie konta bez KYC w Peach</h2>
<p>Dla jasności: Twój Bitcoin Seed <strong>jest Twoim kontem Peach</strong>.</p>
<p>Aby korzystać z Peach, musisz utworzyć konto, co polega na udostępnieniu klucza publicznego konta i udowodnieniu, że jest on Twój.</p>
<p>Aby to zrobić:</p>
<ul>
<li>1 - pobierz aktualną datę i godzinę (w milisekundach) jako tekst</li>
<li>2 - użyj swojego klucza prywatnego, aby wygenerować podpis tego tekstu</li>
<li>3 - prześlij klucz publiczny, aktualną datę/godzinę oraz podpis</li>
</ul>
<p>Musisz także wygenerować <code>uniqueId</code>, aby inni użytkownicy nie mogli podszywać się pod Ciebie.<br>
Jest to przydatne np. w przypadku utraty seed, przy zachowaniu tego samego konta.<br>
Nie będziemy się jednak teraz nad tym zbytnio rozwodzić.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood01.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<p>Oto kod w JavaScript:</p>
<pre><code class="language-j">
  const seed = randomBytes(64);

  const root = bip32.fromSeed(seed, bitcoin);
  const child = root.derivePath(&quot;m/0&quot;);
  const keyPair = ECPair.fromPrivateKey(child.privateKey, { network: bitcoin });

  const publicKeyHex = Buffer.from(keyPair.publicKey).toString(&quot;hex&quot;);

  const session = axios.create({
    baseURL: &quot;https://api.peachbitcoin.com/&quot;,
    httpAgent: new http.Agent({ keepAlive: false }),
    httpsAgent: new https.Agent({ keepAlive: false }),
  });

  const registerMessage = String(Date.now());
  const registerMessageSignature = signWithBtcPrivKey(registerMessage, keyPair);

  const resp = await session.post(&quot;v1/user/register&quot;, {
    publicKey: publicKeyHex,
    message: registerMessage,
    signature: registerMessageSignature,
    uniqueId: &quot;my_own_unique_id_random_12345&quot;,
  });

  const accessToken = resp.data.accessToken;

  session.defaults.headers.common[&quot;authorization&quot;] = accessToken;

</code></pre>
<p>Gratulacje! Właśnie utworzyłeś konto w Peach!<br>
Serwer zweryfikował, że w tym momencie jesteś właścicielem pary kluczy Bitcoin odpowiadającej przesłanemu kluczowi publicznemu.</p>
<h2 id="krok-2-przesyanie-publicznego-klucza-pgp">Krok 2: Przesyłanie publicznego klucza PGP</h2>
<p>Będzie dużo szyfrowania… ale także trochę deszyfrowania.<br>
Klucze Bitcoin pozwalają tylko na szyfrowanie jednokierunkowe, więc potrzebujemy kluczy PGP do szyfrowania dwukierunkowego.<br>
Jest to kluczowe do szyfrowania/odszyfrowywania danych bankowych, wiadomości czatu itp.</p>
<p>Przesyłanie publicznego klucza PGP jest podobne do przesyłania publicznego klucza Bitcoin, ale istnieje dodatkowy krok:<br>
publiczny klucz PGP musi być podpisany przy użyciu prywatnego klucza Bitcoin, aby upewnić się, że użytkownik posiada oba klucze.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood02.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<pre><code class="language-j">
const { privateKey: pgpPrivateKey, publicKey: pgpPublicKey } =
    await createPGPKey();

  const pgpPublicKeyMessageSignature = signWithBtcPrivKey(
    pgpPublicKey,
    keyPair
  );
  const setPgpKeysMessage = String(Date.now());

  const setPgpKeysMessageSignature = await signPGPMessage(
    pgpPrivateKey,
    setPgpKeysMessage
  );

  await session.patch(&quot;v1/user&quot;, {
    pgpPublicKey: pgpPublicKey, // the PGP Pub key
    signature: pgpPublicKeyMessageSignature, // the above signed by the BTC Key
    message: setPgpKeysMessage, // the current timestamp
    pgpSignature: setPgpKeysMessageSignature, // the above signed by the PGP Key
  });

</code></pre>
<p>W tym momencie Peach posiada zarówno Twój klucz publiczny Bitcoin, jak i PGP!<br>
Będzie to niezwykle istotne dla handlu na Peach.</p>
<h2 id="kolejne-kroki">Kolejne kroki</h2>
<p>Od tego momentu poradnik pokaże obie strony: stronę Kupującego i Sprzedającego.</p>
<p>Kroki są następujące:</p>
<ul>
<li>3.S Sprzedający tworzy ofertę sprzedaży</li>
<li>4.S Sprzedający finansuje Peach Escrow</li>
<li>5.B Kupujący składa Trade Request na ofertę sprzedaży</li>
<li>5.S Sprzedający akceptuje Trade Request Kupującego</li>
<li>6.B Kupujący deklaruje, że przelew fiat został wykonany</li>
<li>6.S Sprzedający potwierdza otrzymanie płatności</li>
</ul>
<h2 id="krok-3s-sprzedajcy-tworzy-ofert-sprzeday">Krok 3.S: Sprzedający tworzy ofertę sprzedaży</h2>
<p>Tworzenie oferty sprzedaży oznacza, że Sprzedający ogłasza gotowość sprzedaży określonej ilości Bitcoin.<br>
Ale to nie wszystko: Sprzedający musi zaakceptować coś w zamian.</p>
<p>Oferta sprzedaży obejmuje:</p>
<ul>
<li>ilość Bitcoin do sprzedaży</li>
<li>waluty akceptowane przez Sprzedającego</li>
<li>metody płatności akceptowane przez Sprzedającego (gotówka, przelew bankowy, Revolut itp.)</li>
<li>premium (jak drogie jest Bitcoin względem aktualnej wartości rynkowej)</li>
</ul>
<p>Jeżeli wszystko pójdzie dobrze, Kupujący będzie zainteresowany i złoży Trade Request.<br>
W tym momencie musi wybrać <strong>jedną walutę i jedną metodę płatności</strong> spośród dostępnych.<br>
Im więcej opcji pokazuje Sprzedający, tym większa szansa na przyciągnięcie Kupującego.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood03.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">
const sats_to_sell = 21000;
  const sell_premium = 1; // 1%
  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

  const { address: returnAddress } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });
  const sellOfferPaymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@myWiseIdTradingBot&quot;,
  });

  const paymentDataEncryptSHA256 = await sha256(sellOfferPaymentDataToEncrypt);

  const offerCreateRes = await session.post(&quot;v1/offer&quot;, {
    type: &quot;ask&quot;,
    amount: sats_to_sell,
    meansOfPayment: { [payment_data_currency]: [payment_data_method] }, // {&quot;EUR&quot;: [&quot;wise&quot;]}
    paymentData: {
      [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
    },
    returnAddress: returnAddress,
    premium: sell_premium,
  });

</code></pre>
<p>W kodzie Sprzedający ogłasza sprzedaż 21.000 sats (0,00021 Bitcoin) z 1% premią.<br>
Chce otrzymać euro na konto Wise.<br>
Nie przesyła ID konta Wise, tylko hash.<br>
Peach nigdy nie pozna danych płatności, aby zachować anonimowość.<br>
Przesyłany jest także <strong>adres zwrotny</strong> na wypadek zwrotu.</p>
<h2 id="krok-4s-sprzedajcy-finansuje-peach-escrow">Krok 4.S: Sprzedający finansuje Peach Escrow</h2>
<p>Po udanym żądaniu do API Peach w celu utworzenia oferty, Sprzedający otrzymuje ID oferty sprzedaży:</p>
<pre><code class="language-j">const sellOfferId = offerCreateRes.data.id;

</code></pre>
<p>Zachowaj to ID.<br>
Oferta została utworzona, ale nie jest jeszcze publiczna: żaden Kupujący nie może wchodzić w interakcję.<br>
Najpierw Sprzedający musi sfinansować Escrow.</p>
<p>Escrow jest jak sejf, który wymaga autoryzacji zarówno Sprzedającego, jak i Peach.<br>
Bitcoin trafia do sejfu i pozostaje tam bezpieczny aż do zakończenia transakcji.<br>
Ponieważ wymagana jest autoryzacja Sprzedającego, a Escrow to skrypt na blockchain Bitcoin (adres P2WSH), Peach potrzebuje klucza publicznego Sprzedającego do utworzenia Escrow.</p>
<p>W tym momencie Sprzedający przesyła klucz publiczny, który chce użyć dla Escrow.<br>
Peach wybiera własny klucz publiczny i buduje adres.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood04.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">const childSell = root.derivePath(`m/84'/0'/0'/${sellOfferId}'`);

  const keyPairSellOffer = ECPair.fromPrivateKey(childSell.privateKey, {
    network: bitcoin,
  });

  const sellOfferPublicKey = Buffer.from(keyPairSellOffer.publicKey).toString(
    &quot;hex&quot;
  );

  const escrowCreateRes = await session.post(
    &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;,
    {
      publicKey: sellOfferPublicKey,
    }
  );

  const escrowAddress = escrowCreateRes.data.escrows.bitcoin;

  const escrowPeachPublicKey =
    escrowCreateRes.data.escrowPeachPublicKey.bitcoin;

</code></pre>
<p>W kodzie Sprzedający generuje nową parę kluczy na podstawie ID oferty.<br>
Jest to bezpieczne i możliwe do odtworzenia.</p>
<p>Po przesłaniu klucza publicznego, API Peach zwraca adres, na który Sprzedający powinien wysłać 21.000 sats.<br>
Nie trzeba jednak ufać w ciemno — można to zweryfikować.</p>
<p>Zweryfikujmy!</p>
<p>API Peach zwraca również publiczny klucz użyty do tego Escrow, co pozwala <strong>odtworzyć adres za pomocą Bitcoin Script</strong>.</p>
<pre><code class="language-j">   OP_IF
       ${script.number.encode(4320).toString(&quot;hex&quot;)}
       OP_CHECKSEQUENCEVERIFY
       OP_DROP
   OP_ELSE
       ${sellerPublicKey}
       OP_CHECKSIGVERIFY
   OP_ENDIF
   ${peachPublicKey}
   OP_CHECKSIG
</code></pre>
<p>Skrypt Escrow:</p>
<ul>
<li>zawsze wymaga podpisu Peach</li>
<li>oraz dodatkowo:
<ul>
<li>wymaga podpisu Sprzedającego</li>
<li>lub że od wysłania Bitcoin na ten adres wydobyto 4320 bloków</li>
</ul>
</li>
</ul>
<p>Dlaczego 4320 bloków?<br>
To około 30 dni bloków (średnio 1 blok co 10 minut).<br>
Po miesiącu Peach może podpisać sama w przypadku, gdy Sprzedający nie współpracuje lub utraci klucze.</p>
<p>Peach ma nienaganną reputację w zarządzaniu środkami Sprzedających.</p>
<p>Po zbudowaniu skryptu możesz zweryfikować generowany adres P2WSH i sprawdzić, że jest taki sam jak adres zwrócony przez API Peach.</p>
<pre><code class="language-j">  const multisigScript = bitcoin.script.compile([
    Buffer.from(sellOfferPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIGVERIFY,
  ]);

  const timelockScript = bitcoin.script.compile([
    bitcoin.script.number.encode(4320),
    bitcoin.opcodes.OP_CHECKSEQUENCEVERIFY,
    bitcoin.opcodes.OP_DROP,
  ]);

  const redeemScript = bitcoin.script.compile([
    bitcoin.opcodes.OP_IF,
    ...timelockScript,
    bitcoin.opcodes.OP_ELSE,
    ...multisigScript,
    bitcoin.opcodes.OP_ENDIF,
    Buffer.from(escrowPeachPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIG,
  ]);

  const escrowPayment = bitcoin.payments.p2wsh({
    redeem: { output: redeemScript },
    network: bitcoin,
  });

  console.log(&quot;Addresses Match:&quot;, escrowPayment.address === escrowAddress);

</code></pre>
<p>Świetnie! Teraz wykonaj transakcję Bitcoin na ten adres i poczekaj, aż Escrow zostanie uznany za sfinansowany.</p>
<pre><code class="language-j">  while (true) {
    const fundingStatusRes = await session.get(
      &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;
    );
    if (fundingStatusRes.data.funding.status === &quot;FUNDED&quot;) {
      break;
    }
  }

</code></pre>
<p>Po jednym bloku oferta staje się publiczna i Kupujący mogą zacząć wchodzić w interakcje.</p>
<h2 id="krok-5b-kupujcy-skada-trade-request-na-ofert-sprzeday">Krok 5.B: Kupujący składa Trade Request na ofertę sprzedaży</h2>
<p>Teraz czas na działanie Kupującego!</p>
<p>Najpierw sprawdzamy wszystkie dostępne oferty sprzedaży:</p>
<pre><code class="language-j">const sellOffers = await session.get(&quot;v069/sellOffer&quot;);
</code></pre>
<p>Dla uproszczenia, Kupujący wybiera pierwszą dostępną ofertę.</p>
<pre><code class="language-j">const sellOfferToTradeRequestId = sellOffers.data.offers[0].id;
</code></pre>
<p>Kupujący chce złożyć Trade Request, informując Sprzedającego, że chce handlować na jego warunkach.<br>
Brzmi prosto, ale jest to <strong>najbardziej skomplikowany krok</strong> całego procesu.</p>
<p>Kupujący musi przesłać:</p>
<ul>
<li>preferowana metoda płatności (jedna z dozwolonych przez Sprzedającego)</li>
<li>preferowana waluta (jak wyżej)</li>
<li>klucz symetryczny (do bezpośredniej komunikacji z Sprzedającym) zaszyfrowany</li>
<li>podpis klucza symetrycznego</li>
<li>dane płatności zaszyfrowane kluczem symetrycznym</li>
<li>podpis danych płatności</li>
<li>adres docelowy (Release Address), gdzie Kupujący chce otrzymać zakupione Bitcoin</li>
<li>podpis adresu docelowego (BIP-322) – dowód własności adresu</li>
<li>maksymalna opłata minerska: ile Kupujący jest gotów zapłacić za opłaty transakcyjne</li>
</ul>
<p>Dużo, prawda?<br>
Ale dlatego Peach jest superbezpieczna!<br>
Przejdźmy krok po kroku.</p>
<h3 id="preferowana-metoda-patnoci-i-waluta">Preferowana metoda płatności i waluta</h3>
<p>To najprostsze:</p>
<pre><code class="language-j">  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

</code></pre>
<h3 id="klucz-symetryczny">Klucz symetryczny</h3>
<p>Klucz symetryczny jest używany z <strong>AES256 szyfrowaniem dwukierunkowym</strong>: można zaszyfrować wiadomość i odszyfrować ją tym samym kluczem.</p>
<pre><code class="language-j">async function decryptDataWithSymmetricKey(encryptedMessage, symmetricKey) {
  const message = await openpgp.readMessage({
    armoredMessage: encryptedMessage,
  });

  const { data: decrypted } = await openpgp.decrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;utf8&quot;,
  });

  return decrypted;
}

async function encryptDataWithSymmetricKey(data, symmetricKey) {
  const message = await openpgp.createMessage({ text: data });
  const encrypted = await openpgp.encrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;armored&quot;,
    config: {
      preferredSymmetricAlgorithm: openpgp.enums.symmetric.aes256,
    },
  });
  return encrypted;
}

</code></pre>
<p>Wygeneruj losową liczbę:</p>
<pre><code class="language-j">  const symmetricKey = randomBytes(32);
  const symmetricKeyHex = symmetricKey.toString(&quot;hex&quot;);

</code></pre>
<p>Nie należy przesyłać klucza jawnie!<br>
Trzeba go zaszyfrować w taki sposób, aby tylko Kupujący i Sprzedający mogli go odszyfrować, korzystając z publicznych kluczy PGP.</p>
<pre><code class="language-j">async function encryptForMultipleRecipients(secret, publicKeysArmored) {
  const publicKeys = await Promise.all(
    publicKeysArmored.map((armored) =&gt; openpgp.readKey({ armoredKey: armored }))
  );
  const message = await openpgp.createMessage({ text: secret });

  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: publicKeys,
  });

  return encrypted;
}

  const matchingUserPgpPubKey = sellOffers.data.offers[0].user.pgpPublicKey;

  const symmetricKeyEncrypted = await encryptForMultipleRecipients(
    symmetricKeyHex,
    [pgpPublicKey, matchingUserPgpPubKey]
  );

</code></pre>
<p>Sprzedający musi również podpisać klucz symetryczny, aby upewnić się, że został wygenerowany przez Kupującego:</p>
<pre><code class="language-j">  const symmetricKeySignature = await signPGPMessage(
    pgpPrivateKey,
    symmetricKeyHex
  );

</code></pre>
<h3 id="dane-patnoci">Dane płatności</h3>
<p>To najbardziej wrażliwe informacje: IBAN, nazwa użytkownika Revolut, wszystko, co identyfikuje źródło płatności fiat.<br>
Kupujący szyfruje te dane kluczem symetrycznym, aby tylko Sprzedający mógł je odszyfrować.</p>
<pre><code class="language-j">const paymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@buyerWiseId&quot;,
  });

const paymentDataEncrypted = await encryptDataWithSymmetricKey(
paymentDataToEncrypt,
symmetricKeyHex
);

const paymentDataSignature = await signPGPMessage(
pgpPrivateKey,
paymentDataToEncrypt
);

</code></pre>
<h3 id="ustalenie-adresu-docelowego-i-dowd-wasnoci">Ustalenie adresu docelowego i dowód własności</h3>
<p>Musisz ustalić, gdzie Bitcoin z transakcji zostanie wysłany.<br>
Utworzenie adresu jest proste, trudniejsze jest udowodnienie własności.<br>
Robimy to ze względów regulacyjnych i jako dodatkowe zabezpieczenie.<br>
Używamy <strong>BIP-322</strong>: podpisujesz wiadomość swoim prywatnym kluczem Bitcoin, weryfikowalną za pomocą adresu.</p>
<pre><code class="language-j">  const { address } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });

  const ownershipMessage =
    &quot;I confirm that only I, peach&quot; +
    publicKeyHex.slice(0, 8) +
    &quot;, control the address &quot; +
    address;

  const releaseAddressSignature = signWithBIP322(
    wif,
    address,
    ownershipMessage
  );

</code></pre>
<h3 id="maksymalna-opata-minerska">Maksymalna opłata minerska</h3>
<p>Kupujący może ustalić, ile maksymalnie jest gotów zapłacić w opłatach minerskich za transakcję.</p>
<h3 id="zoenie-trade-request">Złożenie Trade Request</h3>
<p>Teraz wszystko jest gotowe i Kupujący składa Trade Request.</p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; + sellOfferToTradeRequestId + &quot;/tradeRequestPerformed&quot;,
    {
      paymentMethod: payment_data_method,
      currency: payment_data_currency,
      paymentDataHashed: paymentDataToEncryptSHA256,
      paymentDataEncrypted: paymentDataEncrypted,
      paymentDataSignature: paymentDataSignature,
      symmetricKeyEncrypted: symmetricKeyEncrypted,
      symmetricKeySignature: symmetricKeySignature,
      maxMiningFeeRate: 2, // sats/vb
      releaseAddress: address,
      releaseAddressMessageSignature: releaseAddressSignature,
    }
  );

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood05.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Teraz kolej na Sprzedającego, aby go zaakceptował.</p>
<h2 id="krok-5s-sprzedajcy-akceptuje-trade-request">Krok 5.S: Sprzedający akceptuje Trade Request</h2>
<p>Sprzedający sprawdza listę otrzymanych Trade Requests:</p>
<pre><code class="language-j">const receivedTradeRequestRequest = await session.get(
    &quot;v069/sellOffer/&quot; + sellOfferId + &quot;/tradeRequestReceived&quot;
  );

  const tradeReq = receivedTradeRequestRequest.data[0];

</code></pre>
<p>Jeżeli Sprzedający chce zaakceptować Trade Request, musi udostępnić swoje dane płatności Kupującemu, aby ten wiedział, gdzie wysłać fiat.</p>
<p>Ponieważ klucz symetryczny został już stworzony przez Kupującego, Sprzedający może go odszyfrować i użyć do zaszyfrowania swoich własnych danych płatności.</p>
<pre><code class="language-j">  const receivedSymmetricKey = await decryptWithPrivateKey(
    tradeReq.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  const sellOfferPaymentDataEncrypted = await encryptDataWithSymmetricKey(
    sellOfferPaymentDataToEncrypt,
    receivedSymmetricKey
  );

  const sellOfferPaymentDataSignature = await signPGPMessage(
    pgpPrivateKey,
    sellOfferPaymentDataToEncrypt
  );

</code></pre>
<p>I to wszystko! Teraz Sprzedający może zaakceptować Trade Request i rozpoczyna się oficjalna transakcja.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood06.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; +
      sellOfferId +
      &quot;/tradeRequestReceived/&quot; +
      tradeReq.userId +
      &quot;/accept&quot;,
    {
      paymentDataEncrypted: sellOfferPaymentDataEncrypted,
      paymentDataSignature: sellOfferPaymentDataSignature,
      paymentData: {
        [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
      },
    }
  );

</code></pre>
<p>Jeżeli proces wydaje się skomplikowany, oto ilustracja:</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood07.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 90%;">
<br><br></p>
<h2 id="krok-6b-kupujcy-deklaruje-wykonanie-patnoci">Krok 6.B: Kupujący deklaruje wykonanie płatności</h2>
<p>Kupujący może sprawdzić, czy ma jakieś kontrakty (Trades ustalone z Sprzedającym) za pomocą endpointu <code>contract summaries</code>:</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data.find((obj) =&gt;
    obj.id.startsWith(sellOfferToTradeRequestId + &quot;-&quot;)
  );

  if (contract.tradeStatus !== &quot;paymentRequired&quot;) throw Error;
</code></pre>
<p>Jeżeli kontrakt ma status <strong>“paymentRequired”</strong>, wtedy Kupujący musi dokonać płatności fiat.</p>
<p>W tym celu odszyfrowuje dane płatności Sprzedającego kluczem symetrycznym z momentu złożenia Trade Request.<br>
Jeśli ich nie zachował, może użyć swojego prywatnego klucza PGP.</p>
<pre><code class="language-j">
  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

  const receivedSymmetricKey = await decryptWithPrivateKey(
    contractRes.data.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  if (receivedSymmetricKey !== symmetricKeyHex) throw Error;

  const decryptedSellerPaymentData = await decryptDataWithSymmetricKey(
    contractRes.data.paymentDataEncrypted,
    receivedSymmetricKey
  );

  console.log(&quot;Seller Payment Data &quot;, JSON.parse(decryptedSellerPaymentData));
</code></pre>
<p>Proces ten odbywa się poza Peach: Kupujący otwiera aplikację bankową i wykonuje przelew fiat.</p>
<p>Bitcoin znajduje się już w Escrow, kontrolowany przez Peach i Sprzedającego.<br>
Można sprawdzić adres Escrow w eksploratorze blockchain.</p>
<p>Po dokonaniu płatności Kupujący deklaruje, że została wykonana:</p>
<pre><code class="language-j">  const confirmPaymentRes = await session.post(
    &quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;
  );
</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood08.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>To był ostatni krok Kupującego.<br>
Teraz Sprzedający musi potwierdzić, że otrzymał fiat i uwolnić Bitcoin na adres Kupującego.</p>
<h2 id="krok-6s-sprzedajcy-potwierdza-patno">Krok 6.S: Sprzedający potwierdza płatność</h2>
<p>Tak samo jak Kupujący, Sprzedający sprawdza kontrakty przypisane do niego.</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data[0];

  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

</code></pre>
<p>Odpowiedź API zawiera <strong>PSBT</strong> (Partially Signed Bitcoin Transaction)<br>
przesyłającą Bitcoin z Escrow na adres Kupującego.<br>
Podpis Peach jest już w transakcji, brakuje tylko podpisu Sprzedającego.</p>
<pre><code class="language-j">  const releasePSBTBase64 = contractRes.data.releasePsbt;

  const parsedPSBT = bitcoin.Psbt.fromBase64(releasePSBTBase64, {
    network: bitcoin,
  });

  parsedPSBT.signInput(0, childSell);

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood09.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Sprzedający może teraz sfinalizować transakcję, dodając dwa podpisy i Escrow Bitcoin Script.<br>
Używamy ścieżki MultiSig (druga ścieżka skryptu) i dodajemy <code>OP_FALSE</code> do stosu, aby poprawnie wpłynąć na instrukcję IF.</p>
<pre><code class="language-j">export const getFinalScript = (_inputIndex, input, bitcoinScript) =&gt; {
  const network = bitcoin;

  const payment = payments.p2wsh({
    network,
    redeem: {
      network,
      output: bitcoinScript,
      input: bitcoin.script.compile([
        input.partialSig[0].signature,
        input.partialSig[1].signature,
        opcodes.OP_FALSE,
      ]),
    },
  });

  parsedPSBT.finalizeInput(0, getFinalScript);

  const tx = parsedPSBT.extractTransaction().toHex();

</code></pre>
<p>Ostatni krok: przesłanie sfinalizowanej transakcji do API Peach:</p>
<pre><code class="language-j">  await session.post(&quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;, {
    releaseTransaction: tx,
  });

</code></pre>
<p>Drodzy Państwo, tak handlujemy na Peach z <strong>maksymalnym bezpieczeństwem i prywatnością!</strong></p>
<p class="date">October 23rd, 2025</p><p class="tags">Tagged with:<a href="/pl/blog/tag/produkt">Produkt</a><a href="/pl/blog/tag/p2p">P2P</a><a href="/pl/blog/tag/poradnik">Poradnik</a></p><p><a href="/pl/blog/">All blog posts</a></p></div></section></main><footer class="footer" id="footer"><div class="wrap"><div class="logo-section"><div class="logo"><img class="logo-image" src="/img/peach-footer-logo-e28fd7e07f654f43afd63c9b6ace3cdb.svg" alt="Peach logo"/><span>Made in Switzerland <img src="/img/flags/switzerland-icon.svg" style="width: 1rem; margin-left .5rem;"/></span></div><div class="company-info"> <img class="polyreg-image" src="/img/polyreg-52ec37fb80d0312b219110c05567ad3d.png" alt="Polyreg logo" width="120"/><p>Peach jest członkiem SRO (Organizacja Samoregulacyjna) Polyreg </p><p>Peach jest szwajcarskim licencjonowanym dostawcą usług finansowych i w pełni przestrzega szwajcarskiej ustawy o przeciwdziałaniu praniu pieniędzy. </p></div></div><div class="content"><div class="footer-box"><h6>Firma</h6><a href="/pl/join-us/">Dołącz do nas</a><a href="/pl/terms-and-conditions/">Regulamin</a><a href="/pl/privacy-policy/">Polityka prywatności</a><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Zarządzaj preferencjami cookie</a></div><div class="footer-box"><h6>Kontakt</h6><a href="mailto:hello@peachbitcoin.com">Email</a><a href="https://keys.openpgp.org/vks/v1/by-fingerprint/48339A19645E2E53488E0E5479E1B270FACD1BD2">Klucz PGP</a></div><div class="footer-box"><h6>Pobierz</h6><span>0.69.0 (294)</span><a href="/pl/apk/">APK</a><a href="https://testflight.apple.com/join/wfSPFEWG">iPhone</a><a href="https://play.google.com/store/apps/details?id=com.peachbitcoin.peach.mainnet">Android</a></div><div class="footer-box"><h6>Społeczność</h6><a href="https://twitter.com/peachbitcoin" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://t.me/peachtopeach" target="_blank" rel="noreferrer noopener">Telegram</a><a href="https://discord.gg/ypeHz3SW54" target="_blank" rel="noreferrer noopener">Discord</a><a href="https://www.instagram.com/peachbitcoin/" target="_blank" rel="noreferrer noopener">Instagram</a><a href="https://snort.social/p/npub15369wu3wzzar5fclhecyqfv683x69n6nhlg7rxqnsg2dydgxflpq3apswl" target="_blank" rel="noreferrer noopener">Nostr</a><a href="https://github.com/Peach2Peach" target="_blank" rel="noreferrer noopener">Github</a><a href="https://www.youtube.com/@peachbitcoin" target="_blank" rel="noreferrer noopener">YouTube</a></div><div class="footer-box"><h6>Bitcoin</h6><a href="/bitcoin.pdf">Biała księga</a><a href="https://docs.peachbitcoin.com">Dokumentacja API</a></div><div class="footer-box"><h6>Zarabiaj Bitcoin</h6><a href="/pl/new-users/">Kod polecający</a><a href="/pl/for-businesses/">Zostań partnerem</a></div></div></div></footer><style>#cookie-banner {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: #120A07;
  color: #fff;
  padding: 15px 0;
  z-index: 9999;
  font-size: 14px;
}
#cookie-banner .cookie-container {
  width: 90%;
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
}
#cookie-banner p {
  margin: 0;
  line-height: 1.4;
}
#cookie-banner .cookie-actions {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}
#cookie-banner button {
  padding: 10px 16px;
  color: #fff;
  background-color: #65A519;
  border: none;
  cursor: pointer;
  border-radius: 4px;
  font-size: 14px;
  transition: background-color 0.3s ease;
}
#cookie-banner button:hover {
  background-color: #65A519;
}
#cookie-banner button.reject {
  background-color: #DF321F;
}
#cookie-banner button.reject:hover {
  background-color: #DF321F;
}
#cookie-banner a.cookie-link {
  color: #fff;
  text-decoration: underline;
  font-size: 14px;
  margin-left: 8px;
  cursor: pointer;
}
#cookie-banner a.cookie-link:hover {
  text-decoration: none;
}
/* Popup overlay */
#cookie-popup {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  z-index: 10000;
  justify-content: center;
  align-items: center;
  color: #fff;
}
/* Contenitore del popup */
#cookie-popup-content {
  position: relative;
  background-color: #120A07;
  color:rgb(255, 255, 255);
  padding: 30px 20px 20px;
  border-radius: 10px;
  width: 80%;
  max-width: 600px;
  box-sizing: border-box;
}
/* Pulsante di chiusura */
#cookie-popup-content .close-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  color: #fff;
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  padding: 0 5px;
}
#cookie-popup-content .close-btn:hover {
  color: #ccc;
}
/* Stile per ciascuna categoria di cookie */
.cookie-category {
  margin-bottom: 20px;
}
/* Migliora i checkbox e le label */
.cookie-category label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 15px;
}
.cookie-category input[type="checkbox"] {
  accent-color: #4CAF50;
  margin: 0;
  cursor: pointer;
}
.cookie-category p {
  margin: 4px 0 0 28px;
  font-size: 14px;
  line-height: 1.4;
  color: #ccc;
}
/* Bottone "Salva Preferenze" */
#cookie-popup-content button.save-btn {
  background-color: #4CAF50;
  border: none;
  padding: 10px 16px;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}
#cookie-popup-content button.save-btn:hover {
  background-color: #43a047;
}
/* Media query per schermi più piccoli */
@media (max-width: 768px) {
  #cookie-banner .cookie-container {
    flex-direction: column;
    align-items: flex-start;
  }
  #cookie-banner .cookie-actions {
    margin-top: 10px;
    width: 100%;
    justify-content: flex-start;
    gap: 8px;
    flex-wrap: wrap;
  }
}

</style><div id="cookie-banner" style="display: none;"><div class="cookie-container"><p>Używamy plików cookie, aby ulepszyć Twoje wrażenia. <a href="/privacy-policy" style="color: #4CAF50;">Dowiedz się więcej</a></p><div class="cookie-actions"><button class="cookie-btn" onclick="acceptCookies()">Zaakceptuj pliki cookie i kontynuuj</button><button class="cookie-btn reject" onclick="rejectCookies()">Odrzuć pliki cookie</button><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Zarządzaj plikami cookie</a></div></div></div><div id="cookie-popup"><div id="cookie-popup-content"><button class="close-btn" type="button" onclick="closeCookiePopup()">×</button><h2>Zarządzaj ustawieniami plików cookie</h2><div class="cookie-category"><div class="switch-container"><span class="label-text">Niezbędne pliki cookie</span><label class="switch" for="necessary-cookies"><input type="checkbox" id="necessary-cookies" checked="checked" disabled="disabled"/><span class="slider"></span></label></div><p>Te pliki cookie są niezbędne do działania strony internetowej.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Pliki cookie analityczne</span><label class="switch" for="analytics-cookies"><input type="checkbox" id="analytics-cookies"/><span class="slider"></span></label></div><p>Pliki cookie analityczne pomagają nam zrozumieć, jak użytkownicy wchodzą w interakcję ze stroną.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Pliki cookie marketingowe</span><label class="switch" for="marketing-cookies"><input type="checkbox" id="marketing-cookies"/><span class="slider"></span></label></div><p>Pliki cookie marketingowe służą do gromadzenia informacji o użytkownikach</p></div><div style="text-align: right; margin-top: 20px;"><button class="save-btn" type="button" onclick="savePreferences()">Zapisz ustawienia</button></div></div></div><script src="/js/main-15c0432b5e5f06cbab9e3fedcaae3032.js"></script><script>if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/service-worker.js')
      .then(function(registration) {
        console.log('Service Worker registrato con successo:', registration);
      })
      .catch(function(error) {
        console.log('Registrazione del Service Worker fallita:', error);
      });
  });
} else {
  console.log('Service Worker non supportato in questo browser.');
}</script><script>window.onload = function() {
  setTimeout(function() {
    const languageLabel = document.querySelector('.language-label img');

    const languageMap = {
      'en': { text: 'English', flag: '/img/en-872bf10f0d1ed191b502494534bb329a.png' },
      'es': { text: 'Español', flag: '/img/es-b17fc8846b93c5446b10cd7824434504.png' },
      'de': { text: 'Deutsch', flag: '/img/de-0da84d0f3850d6e25088debeb3ade32c.png' },
      'it': { text: 'Italiano', flag: '/img/it-299996a0097e49e1bc4f312e380d3faa.png' },
      'fr': { text: 'Français', flag: '/img/fr-75a63faa5728ac4175214da6cd3c47f1.png' },
      'el': { text: 'Ελληνικά', flag: '/img/el-27d234921e954ed945c93bef880a07b6.png' },
      'hu': { text: 'Magyar', flag: '/img/hu-fc4c517f481932d60d59b56a8f0c322d.png' },
      'nl': { text: 'Nederlands', flag: '/img/nl-83a65573b2d26cdce16cab98f8c38db1.png' },
      'pl': { text: 'Polski', flag: '/img/pl-f7c03eb5351f5b2e33c9b29f1e200e38.png' },
      'pt': { text: 'Português', flag: '/img/pt-997fb3879120a45e1ba507a9e060a662.png' },
      'sw': { text: 'Kiswahili', flag: '/img/sw-cdf6e2b06778f5ac662fb25f3ca8eac0.png' },
      'uk': { text: 'Українська', flag: '/img/ua-f7a81ef67d0931a29f7e358bb99ef521.png' }
    };

    const currentPath = window.location.pathname;
    let currentLang = 'en';

    // Determinare la lingua corrente dal percorso
    for (const lang in languageMap) {
      if (currentPath.includes('/' + lang)) {
        currentLang = lang;
        break;
      }
    }

    // Aggiorna la bandiera e il testo dinamicamente
    if (languageLabel && languageMap[currentLang]) {
      languageLabel.src = languageMap[currentLang].flag;
    }
  }); // Ritardo per garantire che la pagina sia completamente caricata
};
</script><script>window.__ow = window.__ow || {};
window.__ow.organizationId = "8b099b27-4836-4896-9087-a7ed505dec79";
window.__ow.template_id = "b97be07a-7dcf-48af-8d69-a9dfae5dfc29";
window.__ow.integration_name = "manual_settings";
window.__ow.product_name = "chatbot";   
;(function(n,t,c){function i(n){return e._h?e._h.apply(null,n):e._q.push(n)}var e={_q:[],_h:null,_v:"2.0",on:function(){i(["on",c.call(arguments)])},once:function(){i(["once",c.call(arguments)])},off:function(){i(["off",c.call(arguments)])},get:function(){if(!e._h)throw new Error("[OpenWidget] You can't use getters before load.");return i(["get",c.call(arguments)])},call:function(){i(["call",c.call(arguments)])},init:function(){var n=t.createElement("script");n.async=!0,n.type="text/javascript",n.src="https://cdn.openwidget.com/openwidget.js",t.head.appendChild(n)}};!n.__ow.asyncInit&&e.init(),n.OpenWidget=n.OpenWidget||e}(window,document,[].slice))</script><noscript>You need to <a href="https://www.chatbot.com/help/chat-widget/enable-javascript-in-your-browser/" rel="noopener nofollow">enable JavaScript</a> in order to use the AI chatbot tool powered by <a href="https://www.chatbot.com/" rel="noopener nofollow" target="_blank">ChatBot</a></noscript><script>(function() {
  // Funzioni di utilità per gestire i cookie
  function setCookie(name, value, days) {
    var expires = "";
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
      expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "") + expires + "; path=/";
  }

  function getCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  }

  // Controlla se il consenso è già stato dato per nascondere il banner
  function checkConsent() {
    if (getCookie('consent_necessary') === "true") {
      document.getElementById('cookie-banner').style.display = 'none';
    } else {
      document.getElementById('cookie-banner').style.display = 'flex';
    }
  }

  // Funzione per accettare tutti i cookie
  window.acceptCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'true', 365);
    setCookie('consent_marketing', 'true', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: true, consent_marketing: true});
  };

  // Funzione per rifiutare cookie opzionali (analytics e marketing)
  window.rejectCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'false', 365);
    setCookie('consent_marketing', 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: false, consent_marketing: false});
  };

  // Mostra il popup per gestire le preferenze dei cookie
  window.showCookiePopup = function(event) {
    event.preventDefault();
    document.getElementById('cookie-popup').style.display = 'flex';
  };
  window.closeCookiePopup = function() {
  document.getElementById('cookie-popup').style.display = 'none';
  };

  // Salva le preferenze impostate nel popup
  window.savePreferences = function() {
    var analyticsConsent = document.getElementById('analytics-cookies').checked;
    var marketingConsent = document.getElementById('marketing-cookies').checked;
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', analyticsConsent ? 'true' : 'false', 365);
    setCookie('consent_marketing', marketingConsent ? 'true' : 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: analyticsConsent, consent_marketing: marketingConsent});
  };

  // Inizializza il controllo del consenso al caricamento della pagina
  checkConsent();
})();</script></body></html>