<!DOCTYPE html><html lang="nl"><head><meta charset="UTF-8"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><meta http-equiv="X-Frame-Options" content="DENY"/><meta http-equiv="X-XSS-Protection" content="1; mode=block"/><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/><meta name="keywords" content="[&quot;Product&quot;,&quot;P2P&quot;,&quot;tutorial&quot;,&quot;programmeren&quot;,&quot;javascript&quot;,&quot;bitcoin&quot;]"/><meta name="description" content="Aaaaah Bitcoin — dit prachtige geldsysteem dat floreert dankzij zijn kernfuncties.  
We houden er allemaal van, maar we weten ook dat er risico’s zijn met zelfsoevereiniteit: deel je je seed, dan verlies je alles.  
Stuur je het naar het verkeerde adres, dan krijg je het nooit terug."/><meta property="og:locale" content="nl"/><meta property="og:site_name"/><meta property="og:title" content="Peach Bitcoin Exchange - Buy and Sell Bitcoin Anonymously and Without KYC"/><meta property="og:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta property="og:type" content="website"/><meta property="og:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:secure_url" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:width" content="1296"/><meta property="og:image:height" content="678"/><meta name="twitter:site" content="@peachbitcoin"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Peach Bitcoin onder de motorkap: een technische blik op waarom het het veiligste P2P-platform is · Peach Bitcoin"/><meta name="twitter:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and  without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta name="twitter:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta name="msapplication-TileColor" content="#F56522"/><meta name="theme-color" content="#F56522"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-regular.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-600.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-800.woff2"/><link rel="apple-touch-icon" href="/img/favicon/apple-touch-icon.png"/><link rel="icon" href="/img/favicon/favicon.svg"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/img/favicon/safari-pinned-tab.svg" color="#F56522"/><link rel="stylesheet" href="/css/main-8c7d0a0965d37fafcf6e9215d363177f.css"/><title>Peach Bitcoin onder de motorkap: een technische blik op waarom het het veiligste P2P-platform is · Peach Bitcoin</title><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KQHJRQKH');</script></head><body id="blog-peach-under-the-hood"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KQHJRQKH" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><header class="header header-container" id="header"><div class="wrap"><a class="logo-link brand" href="/nl/"><img class="logo logo" src="/img/peach-bitcoin-145cd6c0079ccacc9c70c892060964d1.svg" alt="Peach Bitcoin"/></a><input id="show-menu" type="checkbox"/><label class="nav-toggle-label" id="nav-toggle" for="show-menu"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path class="line--1" d="M0 70l28-28c2-2 2-2 7-2h64"></path><path class="line--2" d="M0 50h99"></path><path class="line--3" d="M0 30l28 28c2 2 2 2 7 2h64"></path></svg></label><nav class="nav"><a href="/nl/how-it-works/">Koop BTC zonder KYC</a><a href="/nl/for-meetups/">Koop BTC met contant geld</a><a href="/nl/for-businesses/">Verkoop BTC</a><a href="/nl/blog/">Blog</a><a href="/nl/support/">Ondersteuning</a><div class="language-selector"><input class="checkbox" type="checkbox" id="language-toggle"/><label class="language-label" for="language-toggle"><img class="flag-icon" src="/img/en-872bf10f0d1ed191b502494534bb329a.png" alt="UK Flag"/><img src="/img/dropdown_icon-fcd9aa7055472ef4a4e83b593450c048.svg" style="width: 1rem;" alt="Dropdown icon"/></label><ul class="language-dropdown"><li><a href="/"><img class="flag-icon" src="/img/en-872bf10f0d1ed191b502494534bb329a.png" alt="EN Flag"/><span>English</span></a></li><li><a href="/es"><img class="flag-icon" src="/img/es-b17fc8846b93c5446b10cd7824434504.png" alt="ES Flag"/><span>Español</span></a></li><li><a href="/de"><img class="flag-icon" src="/img/de-0da84d0f3850d6e25088debeb3ade32c.png" alt="DE Flag"/><span>Deutsch</span></a></li><li><a href="/it"><img class="flag-icon" src="/img/it-299996a0097e49e1bc4f312e380d3faa.png" alt="IT Flag"/><span>Italiano</span></a></li><li><a href="/fr"><img class="flag-icon" src="/img/fr-75a63faa5728ac4175214da6cd3c47f1.png" alt="FR Flag"/><span>Français</span></a></li><li><a href="/el"><img class="flag-icon" src="/img/el-27d234921e954ed945c93bef880a07b6.png" alt="GR Flag"/><span>Ελληνικά</span></a></li><li><a href="/hu"><img class="flag-icon" src="/img/hu-fc4c517f481932d60d59b56a8f0c322d.png" alt="HU Flag"/><span>Magyar</span></a></li><li><a href="/nl"><img class="flag-icon" src="/img/nl-83a65573b2d26cdce16cab98f8c38db1.png" alt="NL Flag"/><span>Nederlands</span></a></li><li><a href="/pl"><img class="flag-icon" src="/img/pl-f7c03eb5351f5b2e33c9b29f1e200e38.png" alt="PL Flag"/><span>Polski</span></a></li><li><a href="/pt"><img class="flag-icon" src="/img/pt-997fb3879120a45e1ba507a9e060a662.png" alt="PT Flag"/><span>Português</span></a></li><li><a href="/sw"><img class="flag-icon" src="/img/sw-cdf6e2b06778f5ac662fb25f3ca8eac0.png" alt="SW Flag"/><span>Kiswahili</span></a></li><li><a href="/uk"><img class="flag-icon" src="/img/ua-f7a81ef67d0931a29f7e358bb99ef521.png" alt="UA Flag"/><span>Українська</span></a></li></ul></div></nav></div></header><main class="main" id="main"><div id="header-anchor"></div><section class="wrap"><div class="content-wrap post"><h1 id="peach-bitcoin-onder-de-motorkap-een-technische-blik-op-waarom-het-het-veiligste-p2p-platform-is">Peach Bitcoin onder de motorkap: een technische blik op waarom het het veiligste P2P-platform is</h1>
<div class="video-wrapper">
  <iframe
    src="https://www.youtube.com/embed/UvdbHlsPmK0"
    title="PEACH VIDEO OF Under the Hood"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>
<p>Aaaaah Bitcoin — dit prachtige geldsysteem dat floreert dankzij zijn kernfuncties.<br>
We houden er allemaal van, maar we weten ook dat er risico’s zijn met zelfsoevereiniteit: deel je je seed, dan verlies je alles.<br>
Stuur je het naar het verkeerde adres, dan krijg je het nooit terug.</p>
<p>Daarom is open-source software in het Bitcoin-ecosysteem zo belangrijk — de Peach-app is beschikbaar op GitHub voor iedereen die wil controleren!</p>
<p>Natuurlijk betekent open source niet dat iedereen de code zorgvuldig leest of begrijpt hoe het werkt.<br>
Daarom schrijf ik dit artikel: om <strong>te laten zien hoe veilig Peach is</strong> en welke stappen deze veiligheid garanderen.</p>
<h2 id="stap-1-een-no-kyc-account-aanmaken-op-peach">Stap 1: Een No-KYC-account aanmaken op Peach</h2>
<p>Om heel duidelijk te zijn: je Bitcoin Seed <strong>is je Peach-account</strong>.</p>
<p>Om Peach te gebruiken, moet je een account aanmaken, wat inhoudt dat je je publieke sleutel deelt en bewijst dat je deze bezit.</p>
<p>Om dit te doen:</p>
<ul>
<li>1 - haal de huidige datum en tijd op (in milliseconden) als tekst</li>
<li>2 - gebruik je private key om een handtekening van die tekst te genereren</li>
<li>3 - stuur de public key, de huidige datum/tijd en de handtekening</li>
</ul>
<p>Je moet ook een <code>uniqueId</code> genereren om te voorkomen dat andere gebruikers zich voordoen als jij.<br>
Dit is handig in gevallen zoals het verliezen van seeds maar hetzelfde account behouden.<br>
Maar laten we hier niet te diep op ingaan.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood01.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<p>Hier is de JavaScript-code:</p>
<pre><code class="language-j">
  const seed = randomBytes(64);

  const root = bip32.fromSeed(seed, bitcoin);
  const child = root.derivePath(&quot;m/0&quot;);
  const keyPair = ECPair.fromPrivateKey(child.privateKey, { network: bitcoin });

  const publicKeyHex = Buffer.from(keyPair.publicKey).toString(&quot;hex&quot;);

  const session = axios.create({
    baseURL: &quot;https://api.peachbitcoin.com/&quot;,
    httpAgent: new http.Agent({ keepAlive: false }),
    httpsAgent: new https.Agent({ keepAlive: false }),
  });

  const registerMessage = String(Date.now());
  const registerMessageSignature = signWithBtcPrivKey(registerMessage, keyPair);

  const resp = await session.post(&quot;v1/user/register&quot;, {
    publicKey: publicKeyHex,
    message: registerMessage,
    signature: registerMessageSignature,
    uniqueId: &quot;my_own_unique_id_random_12345&quot;,
  });

  const accessToken = resp.data.accessToken;

  session.defaults.headers.common[&quot;authorization&quot;] = accessToken;

</code></pre>
<p>Gefeliciteerd! Je hebt zojuist een account aangemaakt op Peach!<br>
De server heeft geverifieerd dat jij op dit moment de eigenaar bent van het Bitcoin Key-Pair dat overeenkomt met de ingediende public key.</p>
<h2 id="stap-2-je-publieke-pgp-sleutel-indienen">Stap 2: Je publieke PGP-sleutel indienen</h2>
<p>Er zal veel encryptie zijn… maar ook wat decryptie.<br>
Bitcoin-sleutels staan alleen éénrichtingsencryptie toe, dus we hebben PGP-sleutels nodig voor tweerichtingenencryptie.<br>
Dit is essentieel om bankgegevens, chatberichten, enz. te encrypten/decrypten.</p>
<p>Het indienen van de publieke PGP-sleutel lijkt op het indienen van de publieke Bitcoin-sleutel, maar er is een extra stap:<br>
de publieke PGP-sleutel moet worden ondertekend met de Bitcoin private key, om te dubbelchecken dat de gebruiker beide sleutels bezit.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood02.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<pre><code class="language-j">
const { privateKey: pgpPrivateKey, publicKey: pgpPublicKey } =
    await createPGPKey();

  const pgpPublicKeyMessageSignature = signWithBtcPrivKey(
    pgpPublicKey,
    keyPair
  );
  const setPgpKeysMessage = String(Date.now());

  const setPgpKeysMessageSignature = await signPGPMessage(
    pgpPrivateKey,
    setPgpKeysMessage
  );

  await session.patch(&quot;v1/user&quot;, {
    pgpPublicKey: pgpPublicKey, // the PGP Pub key
    signature: pgpPublicKeyMessageSignature, // the above signed by the BTC Key
    message: setPgpKeysMessage, // the current timestamp
    pgpSignature: setPgpKeysMessageSignature, // the above signed by the PGP Key
  });

</code></pre>
<p>Op dit moment heeft Peach zowel je Bitcoin- als PGP-public keys!<br>
Dit zal uiterst belangrijk zijn voor handelen op Peach.</p>
<h2 id="volgende-stappen">Volgende stappen</h2>
<p>Vanaf dit punt laat de tutorial beide kanten zien: de koperzijde en de verkoperszijde.</p>
<p>De stappen zijn:</p>
<ul>
<li>3.S Verkoper maakt een verkoopaanbod</li>
<li>4.S Verkoper financiert de Peach Escrow</li>
<li>5.B Koper doet een Trade Request op het verkoopaanbod</li>
<li>5.S Verkoper accepteert het Trade Request van de Koper</li>
<li>6.B Koper verklaart dat de Fiat-betaling is gedaan</li>
<li>6.S Verkoper bevestigt dat hij de betaling heeft ontvangen</li>
</ul>
<h2 id="stap-3s-verkoper-maakt-een-verkoopaanbod">Stap 3.S: Verkoper maakt een verkoopaanbod</h2>
<p>Een verkoopaanbod maken betekent dat je aankondigt dat je een bepaalde hoeveelheid Bitcoin wilt verkopen.<br>
Maar dat is niet alles: de Verkoper moet ook iets in ruil accepteren.</p>
<p>Een verkoopaanbod bevat:</p>
<ul>
<li>hoeveelheid Bitcoin te verkopen</li>
<li>de valuta’s die de Verkoper accepteert</li>
<li>de betalingsmethoden die de Verkoper accepteert (contant, bankoverschrijving, Revolut, etc.)</li>
<li>de premie (hoeveel duurder de Bitcoin is vergeleken met de huidige marktwaarde)</li>
</ul>
<p>Als alles goed gaat, zal een Koper geïnteresseerd zijn en een Trade Request indienen.<br>
Op dat moment moet hij <strong>één valuta en één betalingsmethode</strong> selecteren uit de beschikbare opties.<br>
Hoe meer opties de Verkoper toont, hoe groter de kans een Koper aan te trekken.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood03.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">
const sats_to_sell = 21000;
  const sell_premium = 1; // 1%
  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

  const { address: returnAddress } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });
  const sellOfferPaymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@myWiseIdTradingBot&quot;,
  });

  const paymentDataEncryptSHA256 = await sha256(sellOfferPaymentDataToEncrypt);

  const offerCreateRes = await session.post(&quot;v1/offer&quot;, {
    type: &quot;ask&quot;,
    amount: sats_to_sell,
    meansOfPayment: { [payment_data_currency]: [payment_data_method] }, // {&quot;EUR&quot;: [&quot;wise&quot;]}
    paymentData: {
      [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
    },
    returnAddress: returnAddress,
    premium: sell_premium,
  });

</code></pre>
<p>In de code kondigt de Verkoper aan dat hij 21.000 sats (0,00021 Bitcoin) verkoopt met een premie van 1%.<br>
Hij wil euro’s ontvangen via zijn Wise-account.<br>
Hij verstuurt zijn Wise-ID niet, alleen een hash.<br>
Peach zal de betalingsgegevens nooit kennen, om anonimiteit te behouden.<br>
Er wordt ook een <strong>terugkeeradres</strong> ingediend voor het geval van terugbetalingen.</p>
<h2 id="stap-4s-verkoper-financiert-de-peach-escrow">Stap 4.S: Verkoper financiert de Peach Escrow</h2>
<p>Na een succesvolle API-aanvraag om het verkoopaanbod te maken, ontvangt de Verkoper het verkoopaanbied-ID:</p>
<pre><code class="language-j">const sellOfferId = offerCreateRes.data.id;

</code></pre>
<p>Bewaar dit ID goed.<br>
Het verkoopaanbod is gemaakt, maar nog niet publiek: geen Koper kan ermee interacteren.<br>
Eerst moet de Verkoper de Escrow financieren.</p>
<p>De Escrow is als een kluis die zowel de toestemming van de Verkoper als Peach vereist.<br>
De Bitcoin wordt in de kluis geplaatst en blijft veilig tot het einde van de Trade.<br>
Omdat de toestemming van de Verkoper nodig is en de Escrow een Script op de Bitcoin Blockchain is (een P2WSH-adres), heeft Peach de publieke sleutel van de Verkoper nodig om deze Escrow te maken.</p>
<p>Op dit moment levert de Verkoper de publieke sleutel die hij wil gebruiken voor de Escrow.<br>
Peach selecteert haar eigen publieke sleutel en bouwt het adres.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood04.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">const childSell = root.derivePath(`m/84'/0'/0'/${sellOfferId}'`);

  const keyPairSellOffer = ECPair.fromPrivateKey(childSell.privateKey, {
    network: bitcoin,
  });

  const sellOfferPublicKey = Buffer.from(keyPairSellOffer.publicKey).toString(
    &quot;hex&quot;
  );

  const escrowCreateRes = await session.post(
    &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;,
    {
      publicKey: sellOfferPublicKey,
    }
  );

  const escrowAddress = escrowCreateRes.data.escrows.bitcoin;

  const escrowPeachPublicKey =
    escrowCreateRes.data.escrowPeachPublicKey.bitcoin;

</code></pre>
<p>In de code genereert de Verkoper een nieuw Key Pair vanaf het verkoopaanbied-ID.<br>
Dit is veilig en reproduceerbaar.</p>
<p>Na het indienen van de publieke sleutel, retourneert de Peach API het adres waar de Verkoper de 21.000 sats naartoe moet sturen.<br>
Maar je hoeft niet blind te vertrouwen — je kunt dit verifiëren.</p>
<p>Laten we het verifiëren!</p>
<p>De Peach API retourneert ook de publieke sleutel die Peach voor deze specifieke Escrow gebruikte, zodat we het adres kunnen <strong>recreëren via het Bitcoin Script</strong>.</p>
<pre><code class="language-j">   OP_IF
       ${script.number.encode(4320).toString(&quot;hex&quot;)}
       OP_CHECKSEQUENCEVERIFY
       OP_DROP
   OP_ELSE
       ${sellerPublicKey}
       OP_CHECKSIGVERIFY
   OP_ENDIF
   ${peachPublicKey}
   OP_CHECKSIG
</code></pre>
<p>Het script voor de Escrow:</p>
<ul>
<li>vereist altijd de handtekening van Peach</li>
<li>en verder:
<ul>
<li>vereist de handtekening van de Verkoper</li>
<li>of dat er 4320 blocks zijn gemined sinds de Bitcoin naar dat adres werd gestuurd</li>
</ul>
</li>
</ul>
<p>Waarom 4320 blocks?<br>
Dat zijn ongeveer 30 dagen blocks (1 block per 10 minuten gemiddeld).<br>
Na 1 maand kan Peach alleen ondertekenen in het geval de Verkoper niet meewerkt of zijn sleutels verliest.</p>
<p>Peach heeft een onberispelijke reputatie in het beheren van de fondsen van de Verkopers.</p>
<p>Na het bouwen van het script kun je het P2WSH-adres verifiëren en zien dat het overeenkomt met het adres dat Peach API terugstuurt.</p>
<pre><code class="language-j">  const multisigScript = bitcoin.script.compile([
    Buffer.from(sellOfferPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIGVERIFY,
  ]);

  const timelockScript = bitcoin.script.compile([
    bitcoin.script.number.encode(4320),
    bitcoin.opcodes.OP_CHECKSEQUENCEVERIFY,
    bitcoin.opcodes.OP_DROP,
  ]);

  const redeemScript = bitcoin.script.compile([
    bitcoin.opcodes.OP_IF,
    ...timelockScript,
    bitcoin.opcodes.OP_ELSE,
    ...multisigScript,
    bitcoin.opcodes.OP_ENDIF,
    Buffer.from(escrowPeachPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIG,
  ]);

  const escrowPayment = bitcoin.payments.p2wsh({
    redeem: { output: redeemScript },
    network: bitcoin,
  });

  console.log(&quot;Addresses Match:&quot;, escrowPayment.address === escrowAddress);

</code></pre>
<p>Perfect! Voer nu een Bitcoin-transactie uit naar dat adres en wacht tot de Escrow als gefinancierd wordt verklaard.</p>
<pre><code class="language-j">  while (true) {
    const fundingStatusRes = await session.get(
      &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;
    );
    if (fundingStatusRes.data.funding.status === &quot;FUNDED&quot;) {
      break;
    }
  }

</code></pre>
<p>Na 1 block wordt het verkoopaanbod publiek en kunnen kopers ermee interacteren.</p>
<h2 id="stap-5b-koper-doet-een-trade-request-op-het-verkoopaanbod">Stap 5.B: Koper doet een Trade Request op het verkoopaanbod</h2>
<p>Nu is het tijd voor actie door de Koper!</p>
<p>Eerst controleren we alle beschikbare verkoopaanbiedingen:</p>
<pre><code class="language-j">const sellOffers = await session.get(&quot;v069/sellOffer&quot;);
</code></pre>
<p>Voor eenvoud kiest de Koper de eerste beschikbare aanbieding.</p>
<pre><code class="language-j">const sellOfferToTradeRequestId = sellOffers.data.offers[0].id;
</code></pre>
<p>De Koper wil een Trade Request doen, waarmee hij aangeeft te willen handelen volgens de voorwaarden van de Verkoper.<br>
Klinkt eenvoudig, maar dit is <strong>de meest complexe stap</strong> van het hele proces.</p>
<p>De Koper moet het volgende indienen:</p>
<ul>
<li>Voorkeursbetalingsmethode (een van de door de Verkoper toegestane methoden)</li>
<li>Voorkeursvaluta (zoals hierboven)</li>
<li>Symmetrische sleutel (voor directe communicatie met de Verkoper) gecodeerd</li>
<li>Handtekening van de symmetrische sleutel</li>
<li>Betalingsgegevens gecodeerd met de symmetrische sleutel</li>
<li>Handtekening van de betalingsgegevens</li>
<li>Release-adres: waar de Koper de aangekochte Bitcoin wil ontvangen</li>
<li>Handtekening van het Release-adres: bewijs dat de Koper eigenaar is van dat adres (BIP-322)</li>
<li>Maximale mining fee: hoeveel de Koper bereid is op te offeren aan fees voor de uiteindelijke transactie</li>
</ul>
<p>Veel, toch?<br>
Maar dat is waarom Peach superveilig is!<br>
Laten we stap voor stap doorgaan.</p>
<h3 id="voorkeursbetalingsmethode-en-valuta">Voorkeursbetalingsmethode en valuta</h3>
<p>Dit is het eenvoudigst:</p>
<pre><code class="language-j">  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

</code></pre>
<h3 id="symmetrische-sleutel">Symmetrische sleutel</h3>
<p>De symmetrische sleutel wordt gebruikt met <strong>AES256 tweerichtingsencryptie</strong>: je kunt een bericht coderen en decoderen met dezelfde sleutel.</p>
<pre><code class="language-j">async function decryptDataWithSymmetricKey(encryptedMessage, symmetricKey) {
  const message = await openpgp.readMessage({
    armoredMessage: encryptedMessage,
  });

  const { data: decrypted } = await openpgp.decrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;utf8&quot;,
  });

  return decrypted;
}

async function encryptDataWithSymmetricKey(data, symmetricKey) {
  const message = await openpgp.createMessage({ text: data });
  const encrypted = await openpgp.encrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;armored&quot;,
    config: {
      preferredSymmetricAlgorithm: openpgp.enums.symmetric.aes256,
    },
  });
  return encrypted;
}

</code></pre>
<p>Genereer een willekeurig nummer:</p>
<pre><code class="language-j">  const symmetricKey = randomBytes(32);
  const symmetricKeyHex = symmetricKey.toString(&quot;hex&quot;);

</code></pre>
<p>Je mag deze sleutel niet in het openbaar indienen!<br>
Het moet zodanig worden gecodeerd dat alleen Koper en Verkoper het kunnen decoderen, met behulp van hun publieke PGP-sleutels.</p>
<pre><code class="language-j">async function encryptForMultipleRecipients(secret, publicKeysArmored) {
  const publicKeys = await Promise.all(
    publicKeysArmored.map((armored) =&gt; openpgp.readKey({ armoredKey: armored }))
  );
  const message = await openpgp.createMessage({ text: secret });

  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: publicKeys,
  });

  return encrypted;
}

  const matchingUserPgpPubKey = sellOffers.data.offers[0].user.pgpPublicKey;

  const symmetricKeyEncrypted = await encryptForMultipleRecipients(
    symmetricKeyHex,
    [pgpPublicKey, matchingUserPgpPubKey]
  );

</code></pre>
<p>De Verkoper moet ook de symmetrische sleutel ondertekenen om te bevestigen dat deze door de Koper is gegenereerd:</p>
<pre><code class="language-j">  const symmetricKeySignature = await signPGPMessage(
    pgpPrivateKey,
    symmetricKeyHex
  );

</code></pre>
<h3 id="betalingsgegevens">Betalingsgegevens</h3>
<p>Dit zijn de meest waardevolle gegevens: IBAN, Revolut-username, alles wat de oorsprong van de Fiat-betaling identificeert.<br>
De Koper codeert deze gegevens met de symmetrische sleutel zodat alleen de Verkoper ze kan decoderen.</p>
<pre><code class="language-j">const paymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@buyerWiseId&quot;,
  });

const paymentDataEncrypted = await encryptDataWithSymmetricKey(
paymentDataToEncrypt,
symmetricKeyHex
);

const paymentDataSignature = await signPGPMessage(
pgpPrivateKey,
paymentDataToEncrypt
);

</code></pre>
<h3 id="release-adres-definiren-en-eigendom-bewijzen">Release-adres definiëren en eigendom bewijzen</h3>
<p>Je moet definiëren waar de Bitcoin van de transactie naartoe gestuurd moet worden.<br>
Een adres creëren is eenvoudig; eigendom bewijzen is lastiger.<br>
Dit gebeurt voor regulatoire doeleinden en als extra veiligheidsmaatregel.<br>
We gebruiken <strong>BIP-322</strong>: je ondertekent een bericht met je private Bitcoin key, verifieerbaar via het adres.</p>
<pre><code class="language-j">  const { address } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });

  const ownershipMessage =
    &quot;I confirm that only I, peach&quot; +
    publicKeyHex.slice(0, 8) +
    &quot;, control the address &quot; +
    address;

  const releaseAddressSignature = signWithBIP322(
    wif,
    address,
    ownershipMessage
  );

</code></pre>
<h3 id="maximale-mining-fee">Maximale mining fee</h3>
<p>De Koper kan bepalen hoeveel hij bereid is te betalen aan miners voor de transactie.</p>
<h3 id="trade-request-indienen">Trade Request indienen</h3>
<p>Alles is nu klaar en de Koper dient het Trade Request in.</p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; + sellOfferToTradeRequestId + &quot;/tradeRequestPerformed&quot;,
    {
      paymentMethod: payment_data_method,
      currency: payment_data_currency,
      paymentDataHashed: paymentDataToEncryptSHA256,
      paymentDataEncrypted: paymentDataEncrypted,
      paymentDataSignature: paymentDataSignature,
      symmetricKeyEncrypted: symmetricKeyEncrypted,
      symmetricKeySignature: symmetricKeySignature,
      maxMiningFeeRate: 2, // sats/vb
      releaseAddress: address,
      releaseAddressMessageSignature: releaseAddressSignature,
    }
  );

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood05.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Nu is het de beurt aan de Verkoper om dit te accepteren.</p>
<h2 id="stap-5s-verkoper-accepteert-het-trade-request">Stap 5.S: Verkoper accepteert het Trade Request</h2>
<p>De Verkoper controleert de lijst met ontvangen Trade Requests:</p>
<pre><code class="language-j">const receivedTradeRequestRequest = await session.get(
    &quot;v069/sellOffer/&quot; + sellOfferId + &quot;/tradeRequestReceived&quot;
  );

  const tradeReq = receivedTradeRequestRequest.data[0];

</code></pre>
<p>Als de Verkoper het Trade Request wil accepteren, deelt hij zijn betalingsgegevens met de Koper, zodat deze weet waar de Fiat naartoe gestuurd moet worden.</p>
<p>Omdat de symmetrische sleutel al door de Koper is ingediend, kan de Verkoper deze decoderen en gebruiken om zijn eigen betalingsgegevens te coderen.</p>
<pre><code class="language-j">  const receivedSymmetricKey = await decryptWithPrivateKey(
    tradeReq.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  const sellOfferPaymentDataEncrypted = await encryptDataWithSymmetricKey(
    sellOfferPaymentDataToEncrypt,
    receivedSymmetricKey
  );

  const sellOfferPaymentDataSignature = await signPGPMessage(
    pgpPrivateKey,
    sellOfferPaymentDataToEncrypt
  );

</code></pre>
<p>En dat is het! Nu kan de Verkoper het Trade Request accepteren en begint de officiële transactie.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood06.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; +
      sellOfferId +
      &quot;/tradeRequestReceived/&quot; +
      tradeReq.userId +
      &quot;/accept&quot;,
    {
      paymentDataEncrypted: sellOfferPaymentDataEncrypted,
      paymentDataSignature: sellOfferPaymentDataSignature,
      paymentData: {
        [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
      },
    }
  );

</code></pre>
<p>Als het hele proces ingewikkeld lijkt, hier is een illustratie:</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood07.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 90%;">
<br><br></p>
<h2 id="stap-6b-koper-verklaart-de-betaling-gedaan-te-hebben">Stap 6.B: Koper verklaart de betaling gedaan te hebben</h2>
<p>De Koper kan controleren of hij contracten heeft (Trades overeengekomen met een Verkoper) via de endpoint <code>contract summaries</code>:</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data.find((obj) =&gt;
    obj.id.startsWith(sellOfferToTradeRequestId + &quot;-&quot;)
  );

  if (contract.tradeStatus !== &quot;paymentRequired&quot;) throw Error;
</code></pre>
<p>Als een contract de status <strong>“paymentRequired”</strong> heeft, is het zijn beurt om de Fiat-betaling te doen.</p>
<p>Hiervoor decodeert hij de betalingsgegevens van de Verkoper met de symmetrische sleutel van het moment dat het Trade Request werd gedaan.<br>
Als hij deze niet heeft opgeslagen, kan hij zijn eigen PGP private key gebruiken.</p>
<pre><code class="language-j">
  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

  const receivedSymmetricKey = await decryptWithPrivateKey(
    contractRes.data.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  if (receivedSymmetricKey !== symmetricKeyHex) throw Error;

  const decryptedSellerPaymentData = await decryptDataWithSymmetricKey(
    contractRes.data.paymentDataEncrypted,
    receivedSymmetricKey
  );

  console.log(&quot;Seller Payment Data &quot;, JSON.parse(decryptedSellerPaymentData));
</code></pre>
<p>Dit gebeurt buiten Peach: de Koper opent zijn bankapp en voert de Fiat-overdracht uit.</p>
<p>De Bitcoin staat al in de Escrow, beheerd door Peach en de Verkoper.<br>
Je kunt het Escrow-adres controleren via een Blockchain Explorer.</p>
<p>Na de betaling verklaart de Koper dat deze is voltooid:</p>
<pre><code class="language-j">  const confirmPaymentRes = await session.post(
    &quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;
  );
</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood08.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Dit was het laatste stap voor de Koper.<br>
Nu moet de Verkoper bevestigen dat hij de Fiat ontvangen heeft en de Bitcoin vrijgeven naar het adres van de Koper.</p>
<h2 id="stap-6s-verkoper-bevestigt-de-betaling">Stap 6.S: Verkoper bevestigt de betaling</h2>
<p>Net als de Koper controleert de Verkoper de contracten die aan hem zijn toegewezen.</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data[0];

  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

</code></pre>
<p>De API-respons bevat een <strong>PSBT</strong> (Partially Signed Bitcoin Transaction)<br>
die de Bitcoin uit de Escrow naar het adres van de Koper stuurt.<br>
Deze is al ondertekend door Peach, alleen de handtekening van de Verkoper ontbreekt.</p>
<pre><code class="language-j">  const releasePSBTBase64 = contractRes.data.releasePsbt;

  const parsedPSBT = bitcoin.Psbt.fromBase64(releasePSBTBase64, {
    network: bitcoin,
  });

  parsedPSBT.signInput(0, childSell);

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood09.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Nu kan de Verkoper de transactie voltooien door de 2 handtekeningen en het Escrow Bitcoin Script door te geven.<br>
We gebruiken het MultiSig-pad van het script (het tweede pad) en voegen <code>OP_FALSE</code> toe aan de stack om de IF-statement correct te beïnvloeden.</p>
<pre><code class="language-j">export const getFinalScript = (_inputIndex, input, bitcoinScript) =&gt; {
  const network = bitcoin;

  const payment = payments.p2wsh({
    network,
    redeem: {
      network,
      output: bitcoinScript,
      input: bitcoin.script.compile([
        input.partialSig[0].signature,
        input.partialSig[1].signature,
        opcodes.OP_FALSE,
      ]),
    },
  });

  parsedPSBT.finalizeInput(0, getFinalScript);

  const tx = parsedPSBT.extractTransaction().toHex();

</code></pre>
<p>De laatste stap: stuur de voltooide transactie naar de Peach API:</p>
<pre><code class="language-j">  await session.post(&quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;, {
    releaseTransaction: tx,
  });

</code></pre>
<p>Dames en heren, zo handelen we op Peach met <strong>maximale veiligheid en privacy!</strong></p>
<p class="date">October 23rd, 2025</p><p class="tags">Tagged with:<a href="/nl/blog/tag/product">Product</a><a href="/nl/blog/tag/p2p">P2P</a><a href="/nl/blog/tag/tutorial">Tutorial</a></p><p><a href="/nl/blog/">All blog posts</a></p></div></section></main><footer class="footer" id="footer"><div class="wrap"><div class="logo-section"><div class="logo"><img class="logo-image" src="/img/peach-footer-logo-e28fd7e07f654f43afd63c9b6ace3cdb.svg" alt="Peach logo"/><span>Made in Switzerland <img src="/img/flags/switzerland-icon.svg" style="width: 1rem; margin-left .5rem;"/></span></div><div class="company-info"> <img class="polyreg-image" src="/img/polyreg-52ec37fb80d0312b219110c05567ad3d.png" alt="Polyreg logo" width="120"/><p>Peach is een SRO-lid (Zelfregulerende Organisatie) van Polyreg </p><p>Peach is een erkende financiële dienstverlener in Zwitserland en voldoet volledig aan de Zwitserse Anti-Witwaswet. </p></div></div><div class="content"><div class="footer-box"><h6>Bedrijf</h6><a href="/nl/join-us/">Doe mee</a><a href="/nl/terms-and-conditions/">Algemene voorwaarden</a><a href="/nl/privacy-policy/">Privacybeleid</a><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Cookievoorkeuren beheren</a></div><div class="footer-box"><h6>Contact</h6><a href="mailto:hello@peachbitcoin.com">E-mail</a><a href="https://keys.openpgp.org/vks/v1/by-fingerprint/48339A19645E2E53488E0E5479E1B270FACD1BD2">PGP-sleutel</a></div><div class="footer-box"><h6>Downloaden</h6><span>0.69.0 (294)</span><a href="/nl/apk/">APK</a><a href="https://testflight.apple.com/join/wfSPFEWG">iPhone</a><a href="https://play.google.com/store/apps/details?id=com.peachbitcoin.peach.mainnet">Android</a></div><div class="footer-box"><h6>Gemeenschap</h6><a href="https://twitter.com/peachbitcoin" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://t.me/peachtopeach" target="_blank" rel="noreferrer noopener">Telegram</a><a href="https://discord.gg/ypeHz3SW54" target="_blank" rel="noreferrer noopener">Discord</a><a href="https://www.instagram.com/peachbitcoin/" target="_blank" rel="noreferrer noopener">Instagram</a><a href="https://snort.social/p/npub15369wu3wzzar5fclhecyqfv683x69n6nhlg7rxqnsg2dydgxflpq3apswl" target="_blank" rel="noreferrer noopener">Nostr</a><a href="https://github.com/Peach2Peach" target="_blank" rel="noreferrer noopener">Github</a><a href="https://www.youtube.com/@peachbitcoin" target="_blank" rel="noreferrer noopener">YouTube</a></div><div class="footer-box"><h6>Bitcoin</h6><a href="/bitcoin.pdf">Whitepaper</a><a href="https://docs.peachbitcoin.com">API-documentatie</a></div><div class="footer-box"><h6>Verdien Bitcoin</h6><a href="/nl/new-users/">Verwijzingscode</a><a href="/nl/for-businesses/">Word een affiliate</a></div></div></div></footer><style>#cookie-banner {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: #120A07;
  color: #fff;
  padding: 15px 0;
  z-index: 9999;
  font-size: 14px;
}
#cookie-banner .cookie-container {
  width: 90%;
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
}
#cookie-banner p {
  margin: 0;
  line-height: 1.4;
}
#cookie-banner .cookie-actions {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}
#cookie-banner button {
  padding: 10px 16px;
  color: #fff;
  background-color: #65A519;
  border: none;
  cursor: pointer;
  border-radius: 4px;
  font-size: 14px;
  transition: background-color 0.3s ease;
}
#cookie-banner button:hover {
  background-color: #65A519;
}
#cookie-banner button.reject {
  background-color: #DF321F;
}
#cookie-banner button.reject:hover {
  background-color: #DF321F;
}
#cookie-banner a.cookie-link {
  color: #fff;
  text-decoration: underline;
  font-size: 14px;
  margin-left: 8px;
  cursor: pointer;
}
#cookie-banner a.cookie-link:hover {
  text-decoration: none;
}
/* Popup overlay */
#cookie-popup {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  z-index: 10000;
  justify-content: center;
  align-items: center;
  color: #fff;
}
/* Contenitore del popup */
#cookie-popup-content {
  position: relative;
  background-color: #120A07;
  color:rgb(255, 255, 255);
  padding: 30px 20px 20px;
  border-radius: 10px;
  width: 80%;
  max-width: 600px;
  box-sizing: border-box;
}
/* Pulsante di chiusura */
#cookie-popup-content .close-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  color: #fff;
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  padding: 0 5px;
}
#cookie-popup-content .close-btn:hover {
  color: #ccc;
}
/* Stile per ciascuna categoria di cookie */
.cookie-category {
  margin-bottom: 20px;
}
/* Migliora i checkbox e le label */
.cookie-category label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 15px;
}
.cookie-category input[type="checkbox"] {
  accent-color: #4CAF50;
  margin: 0;
  cursor: pointer;
}
.cookie-category p {
  margin: 4px 0 0 28px;
  font-size: 14px;
  line-height: 1.4;
  color: #ccc;
}
/* Bottone "Salva Preferenze" */
#cookie-popup-content button.save-btn {
  background-color: #4CAF50;
  border: none;
  padding: 10px 16px;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}
#cookie-popup-content button.save-btn:hover {
  background-color: #43a047;
}
/* Media query per schermi più piccoli */
@media (max-width: 768px) {
  #cookie-banner .cookie-container {
    flex-direction: column;
    align-items: flex-start;
  }
  #cookie-banner .cookie-actions {
    margin-top: 10px;
    width: 100%;
    justify-content: flex-start;
    gap: 8px;
    flex-wrap: wrap;
  }
}

</style><div id="cookie-banner" style="display: none;"><div class="cookie-container"><p>We gebruiken cookies om uw ervaring te verbeteren. <a href="/privacy-policy" style="color: #4CAF50;">Lees meer</a></p><div class="cookie-actions"><button class="cookie-btn" onclick="acceptCookies()">Cookies accepteren &amp; doorgaan</button><button class="cookie-btn reject" onclick="rejectCookies()">Cookies weigeren</button><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Cookies beheren</a></div></div></div><div id="cookie-popup"><div id="cookie-popup-content"><button class="close-btn" type="button" onclick="closeCookiePopup()">×</button><h2>Cookievoorkeuren beheren</h2><div class="cookie-category"><div class="switch-container"><span class="label-text">Noodzakelijke cookies</span><label class="switch" for="necessary-cookies"><input type="checkbox" id="necessary-cookies" checked="checked" disabled="disabled"/><span class="slider"></span></label></div><p>Deze cookies zijn essentieel voor het functioneren van de website.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Analytische cookies</span><label class="switch" for="analytics-cookies"><input type="checkbox" id="analytics-cookies"/><span class="slider"></span></label></div><p>Analytische cookies helpen ons te begrijpen hoe gebruikers met de site omgaan.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Marketingcookies</span><label class="switch" for="marketing-cookies"><input type="checkbox" id="marketing-cookies"/><span class="slider"></span></label></div><p>Marketingcookies worden gebruikt om gebruikersinformatie te verzamelen</p></div><div style="text-align: right; margin-top: 20px;"><button class="save-btn" type="button" onclick="savePreferences()">Voorkeuren opslaan</button></div></div></div><script src="/js/main-15c0432b5e5f06cbab9e3fedcaae3032.js"></script><script>if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/service-worker.js')
      .then(function(registration) {
        console.log('Service Worker registrato con successo:', registration);
      })
      .catch(function(error) {
        console.log('Registrazione del Service Worker fallita:', error);
      });
  });
} else {
  console.log('Service Worker non supportato in questo browser.');
}</script><script>window.onload = function() {
  setTimeout(function() {
    const languageLabel = document.querySelector('.language-label img');

    const languageMap = {
      'en': { text: 'English', flag: '/img/en-872bf10f0d1ed191b502494534bb329a.png' },
      'es': { text: 'Español', flag: '/img/es-b17fc8846b93c5446b10cd7824434504.png' },
      'de': { text: 'Deutsch', flag: '/img/de-0da84d0f3850d6e25088debeb3ade32c.png' },
      'it': { text: 'Italiano', flag: '/img/it-299996a0097e49e1bc4f312e380d3faa.png' },
      'fr': { text: 'Français', flag: '/img/fr-75a63faa5728ac4175214da6cd3c47f1.png' },
      'el': { text: 'Ελληνικά', flag: '/img/el-27d234921e954ed945c93bef880a07b6.png' },
      'hu': { text: 'Magyar', flag: '/img/hu-fc4c517f481932d60d59b56a8f0c322d.png' },
      'nl': { text: 'Nederlands', flag: '/img/nl-83a65573b2d26cdce16cab98f8c38db1.png' },
      'pl': { text: 'Polski', flag: '/img/pl-f7c03eb5351f5b2e33c9b29f1e200e38.png' },
      'pt': { text: 'Português', flag: '/img/pt-997fb3879120a45e1ba507a9e060a662.png' },
      'sw': { text: 'Kiswahili', flag: '/img/sw-cdf6e2b06778f5ac662fb25f3ca8eac0.png' },
      'uk': { text: 'Українська', flag: '/img/ua-f7a81ef67d0931a29f7e358bb99ef521.png' }
    };

    const currentPath = window.location.pathname;
    let currentLang = 'en';

    // Determinare la lingua corrente dal percorso
    for (const lang in languageMap) {
      if (currentPath.includes('/' + lang)) {
        currentLang = lang;
        break;
      }
    }

    // Aggiorna la bandiera e il testo dinamicamente
    if (languageLabel && languageMap[currentLang]) {
      languageLabel.src = languageMap[currentLang].flag;
    }
  }); // Ritardo per garantire che la pagina sia completamente caricata
};
</script><script>window.__ow = window.__ow || {};
window.__ow.organizationId = "8b099b27-4836-4896-9087-a7ed505dec79";
window.__ow.template_id = "b97be07a-7dcf-48af-8d69-a9dfae5dfc29";
window.__ow.integration_name = "manual_settings";
window.__ow.product_name = "chatbot";   
;(function(n,t,c){function i(n){return e._h?e._h.apply(null,n):e._q.push(n)}var e={_q:[],_h:null,_v:"2.0",on:function(){i(["on",c.call(arguments)])},once:function(){i(["once",c.call(arguments)])},off:function(){i(["off",c.call(arguments)])},get:function(){if(!e._h)throw new Error("[OpenWidget] You can't use getters before load.");return i(["get",c.call(arguments)])},call:function(){i(["call",c.call(arguments)])},init:function(){var n=t.createElement("script");n.async=!0,n.type="text/javascript",n.src="https://cdn.openwidget.com/openwidget.js",t.head.appendChild(n)}};!n.__ow.asyncInit&&e.init(),n.OpenWidget=n.OpenWidget||e}(window,document,[].slice))</script><noscript>You need to <a href="https://www.chatbot.com/help/chat-widget/enable-javascript-in-your-browser/" rel="noopener nofollow">enable JavaScript</a> in order to use the AI chatbot tool powered by <a href="https://www.chatbot.com/" rel="noopener nofollow" target="_blank">ChatBot</a></noscript><script>(function() {
  // Funzioni di utilità per gestire i cookie
  function setCookie(name, value, days) {
    var expires = "";
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
      expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "") + expires + "; path=/";
  }

  function getCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  }

  // Controlla se il consenso è già stato dato per nascondere il banner
  function checkConsent() {
    if (getCookie('consent_necessary') === "true") {
      document.getElementById('cookie-banner').style.display = 'none';
    } else {
      document.getElementById('cookie-banner').style.display = 'flex';
    }
  }

  // Funzione per accettare tutti i cookie
  window.acceptCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'true', 365);
    setCookie('consent_marketing', 'true', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: true, consent_marketing: true});
  };

  // Funzione per rifiutare cookie opzionali (analytics e marketing)
  window.rejectCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'false', 365);
    setCookie('consent_marketing', 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: false, consent_marketing: false});
  };

  // Mostra il popup per gestire le preferenze dei cookie
  window.showCookiePopup = function(event) {
    event.preventDefault();
    document.getElementById('cookie-popup').style.display = 'flex';
  };
  window.closeCookiePopup = function() {
  document.getElementById('cookie-popup').style.display = 'none';
  };

  // Salva le preferenze impostate nel popup
  window.savePreferences = function() {
    var analyticsConsent = document.getElementById('analytics-cookies').checked;
    var marketingConsent = document.getElementById('marketing-cookies').checked;
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', analyticsConsent ? 'true' : 'false', 365);
    setCookie('consent_marketing', marketingConsent ? 'true' : 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: analyticsConsent, consent_marketing: marketingConsent});
  };

  // Inizializza il controllo del consenso al caricamento della pagina
  checkConsent();
})();</script></body></html>