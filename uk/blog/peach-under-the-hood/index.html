<!DOCTYPE html><html lang="uk"><head><meta charset="UTF-8"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><meta http-equiv="X-Frame-Options" content="DENY"/><meta http-equiv="X-XSS-Protection" content="1; mode=block"/><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/><meta name="keywords" content="[&quot;Продукт&quot;,&quot;P2P&quot;,&quot;навчання&quot;,&quot;програмування&quot;,&quot;javascript&quot;,&quot;bitcoin&quot;]"/><meta name="description" content="const { privateKey: pgpPrivateKey, publicKey: pgpPublicKey } ="/><meta property="og:locale" content="uk"/><meta property="og:site_name"/><meta property="og:title" content="Peach Bitcoin Exchange - Buy and Sell Bitcoin Anonymously and Without KYC"/><meta property="og:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta property="og:type" content="website"/><meta property="og:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:secure_url" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:width" content="1296"/><meta property="og:image:height" content="678"/><meta name="twitter:site" content="@peachbitcoin"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Peach Bitcoin під капотом: технічний погляд на те, чому це найнадійніший P2P-обмін · Peach Bitcoin"/><meta name="twitter:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and  without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta name="twitter:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta name="msapplication-TileColor" content="#F56522"/><meta name="theme-color" content="#F56522"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-regular.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-600.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-800.woff2"/><link rel="apple-touch-icon" href="/img/favicon/apple-touch-icon.png"/><link rel="icon" href="/img/favicon/favicon.svg"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/img/favicon/safari-pinned-tab.svg" color="#F56522"/><link rel="stylesheet" href="/css/main-8c7d0a0965d37fafcf6e9215d363177f.css"/><title>Peach Bitcoin під капотом: технічний погляд на те, чому це найнадійніший P2P-обмін · Peach Bitcoin</title><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KQHJRQKH');</script></head><body id="blog-peach-under-the-hood"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KQHJRQKH" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><header class="header header-container" id="header"><div class="wrap"><a class="logo-link brand" href="/uk/"><img class="logo logo" src="/img/peach-bitcoin-145cd6c0079ccacc9c70c892060964d1.svg" alt="Peach Bitcoin"/></a><input id="show-menu" type="checkbox"/><label class="nav-toggle-label" id="nav-toggle" for="show-menu"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path class="line--1" d="M0 70l28-28c2-2 2-2 7-2h64"></path><path class="line--2" d="M0 50h99"></path><path class="line--3" d="M0 30l28 28c2 2 2 2 7 2h64"></path></svg></label><nav class="nav"><a href="/uk/how-it-works/">Купуйте BTC без KYC</a><a href="/uk/for-meetups/">Купуйте BTC за готівку</a><a href="/uk/for-businesses/">Продавайте BTC</a><a href="/uk/blog/">Блог</a><a href="/uk/support/">Підтримка</a><div class="language-selector"><input class="checkbox" type="checkbox" id="language-toggle"/><label class="language-label" for="language-toggle"><img class="flag-icon" src="/img/en-872bf10f0d1ed191b502494534bb329a.png" alt="UK Flag"/><img src="/img/dropdown_icon-fcd9aa7055472ef4a4e83b593450c048.svg" style="width: 1rem;" alt="Dropdown icon"/></label><ul class="language-dropdown"><li><a href="/"><img class="flag-icon" src="/img/en-872bf10f0d1ed191b502494534bb329a.png" alt="EN Flag"/><span>English</span></a></li><li><a href="/es"><img class="flag-icon" src="/img/es-b17fc8846b93c5446b10cd7824434504.png" alt="ES Flag"/><span>Español</span></a></li><li><a href="/de"><img class="flag-icon" src="/img/de-0da84d0f3850d6e25088debeb3ade32c.png" alt="DE Flag"/><span>Deutsch</span></a></li><li><a href="/it"><img class="flag-icon" src="/img/it-299996a0097e49e1bc4f312e380d3faa.png" alt="IT Flag"/><span>Italiano</span></a></li><li><a href="/fr"><img class="flag-icon" src="/img/fr-75a63faa5728ac4175214da6cd3c47f1.png" alt="FR Flag"/><span>Français</span></a></li><li><a href="/el"><img class="flag-icon" src="/img/el-27d234921e954ed945c93bef880a07b6.png" alt="GR Flag"/><span>Ελληνικά</span></a></li><li><a href="/hu"><img class="flag-icon" src="/img/hu-fc4c517f481932d60d59b56a8f0c322d.png" alt="HU Flag"/><span>Magyar</span></a></li><li><a href="/nl"><img class="flag-icon" src="/img/nl-83a65573b2d26cdce16cab98f8c38db1.png" alt="NL Flag"/><span>Nederlands</span></a></li><li><a href="/pl"><img class="flag-icon" src="/img/pl-f7c03eb5351f5b2e33c9b29f1e200e38.png" alt="PL Flag"/><span>Polski</span></a></li><li><a href="/pt"><img class="flag-icon" src="/img/pt-997fb3879120a45e1ba507a9e060a662.png" alt="PT Flag"/><span>Português</span></a></li><li><a href="/sw"><img class="flag-icon" src="/img/sw-cdf6e2b06778f5ac662fb25f3ca8eac0.png" alt="SW Flag"/><span>Kiswahili</span></a></li><li><a href="/uk"><img class="flag-icon" src="/img/ua-f7a81ef67d0931a29f7e358bb99ef521.png" alt="UA Flag"/><span>Українська</span></a></li></ul></div></nav></div></header><main class="main" id="main"><div id="header-anchor"></div><section class="wrap"><div class="content-wrap post"><h1 id="peach-bitcoin-p2p">Peach Bitcoin під капотом: технічний погляд на те, чому це найнадійніший P2P-обмін</h1>
<div class="video-wrapper">
  <iframe
    src="https://www.youtube.com/embed/UvdbHlsPmK0"
    title="PEACH VIDEO OF Under the Hood"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>
<p>Ааааах, Bitcoin — ця чудова форма грошей, яка процвітає завдяки своїм базовим властивостям. Ми всі його любимо, але всі розуміємо, що самостійне зберігання має ризики: поділишся своїми seed-фразами — і втратиш усе. Відправиш монети на неправильну адресу — і ніколи їх не повернеш.</p>
<p>Саме тому відкритість коду програм, пов’язаних із Bitcoin, є надзвичайно важливою — і додаток Peach доступний на Github для всіх бажаючих переглянути!</p>
<p>Звісно, відкритий код не означає, що всі уважно читають його й проводять реверс-інжиніринг. Саме тому я пишу цю статтю: щоб <strong>показати, наскільки безпечна Peach</strong>, і які кроки робляться для досягнення цієї безпеки.</p>
<h2 id="1-kyc-peach">Крок 1: створення акаунта без KYC у Peach</h2>
<p>Щоб було абсолютно зрозуміло: ваш Bitcoin Seed — це ваш акаунт у Peach.</p>
<p>Якщо ви хочете користуватися Peach, потрібно створити акаунт — тобто надати Публічний ключ свого акаунта і довести, що ви його власник.</p>
<p>Для цього необхідно:</p>
<ul>
<li>1 - отримати поточну дату й час (у мілісекундах) у вигляді тексту</li>
<li>2 - використати свій Приватний ключ, щоб підписати цей текст</li>
<li>3 - надіслати Публічний ключ, поточну дату/час і підпис</li>
</ul>
<p>Також потрібно згенерувати <code>uniqueId</code>, який використовується для запобігання видаванню іншими користувачами себе за вас. Це корисно, наприклад, якщо ви втратили seed, але хочете зберегти той самий акаунт. Але не будемо заглиблюватись у це зараз.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood01.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<p>Ось код для виконання цього в Javascript:</p>
<pre><code class="language-j">
  const seed = randomBytes(64);

  const root = bip32.fromSeed(seed, bitcoin);
  const child = root.derivePath(&quot;m/0&quot;);
  const keyPair = ECPair.fromPrivateKey(child.privateKey, { network: bitcoin });

  const publicKeyHex = Buffer.from(keyPair.publicKey).toString(&quot;hex&quot;);

  const session = axios.create({
    baseURL: &quot;https://api.peachbitcoin.com/&quot;,
    httpAgent: new http.Agent({ keepAlive: false }),
    httpsAgent: new https.Agent({ keepAlive: false }),
  });

  const registerMessage = String(Date.now());
  const registerMessageSignature = signWithBtcPrivKey(registerMessage, keyPair);

  const resp = await session.post(&quot;v1/user/register&quot;, {
    publicKey: publicKeyHex,
    message: registerMessage,
    signature: registerMessageSignature,
    uniqueId: &quot;my_own_unique_id_random_12345&quot;,
  });

  const accessToken = resp.data.accessToken;

  session.defaults.headers.common[&quot;authorization&quot;] = accessToken;

</code></pre>
<p>Вітаємо! Ви щойно створили акаунт у Peach! Сервер підтвердив, що саме ви на даний момент є власником пари ключів Bitcoin, які відповідають надісланому Публічному ключу.</p>
<h2 id="2-pgp">Крок 2: надсилання вашого публічного PGP-ключа</h2>
<p>Далі буде багато шифрування — але також і розшифровки. Ключі Bitcoin дозволяють лише одностороннє шифрування, тому нам потрібні PGP-ключі для двостороннього шифрування.<br>
Це потрібно для шифрування та розшифрування банківських даних, чатів тощо.</p>
<p>Надсилання публічного PGP-ключа схоже на надсилання публічного Bitcoin-ключа.<br>
Але є додатковий крок: потрібно підписати публічний PGP-ключ своїм приватним Bitcoin-ключем, щоб підтвердити, що користувач є власником обох ключів — Bitcoin і PGP.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood02.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<pre><code class="language-j">
const { privateKey: pgpPrivateKey, publicKey: pgpPublicKey } =
    await createPGPKey();

  const pgpPublicKeyMessageSignature = signWithBtcPrivKey(
    pgpPublicKey,
    keyPair
  );
  const setPgpKeysMessage = String(Date.now());

  const setPgpKeysMessageSignature = await signPGPMessage(
    pgpPrivateKey,
    setPgpKeysMessage
  );

  await session.patch(&quot;v1/user&quot;, {
    pgpPublicKey: pgpPublicKey, // the PGP Pub key
    signature: pgpPublicKeyMessageSignature, // the above signed by the BTC Key
    message: setPgpKeysMessage, // the current timestamp
    pgpSignature: setPgpKeysMessageSignature, // the above signed by the PGP Key
  });

</code></pre>
<p>На цьому етапі Peach має обидва ваші публічні ключі — Bitcoin і PGP! Це буде дуже важливо під час торгівлі в Peach.</p>
<h2 id="">Наступні кроки</h2>
<p>Далі в туторіалі показано обидві сторони процесу: Покупця та Продавця.</p>
<p>Послідовність буде така:</p>
<ul>
<li>3.S Продавець створює пропозицію на продаж</li>
<li>4.S Продавець фінансує Escrow у Peach</li>
<li>5.B Покупець надсилає запит на угоду до пропозиції продажу</li>
<li>5.S Продавець приймає запит від Покупця</li>
<li>6.B Покупець оголошує, що фіат-переказ виконано</li>
<li>6.S Продавець підтверджує отримання платежу</li>
</ul>
<h2 id="3s">Крок 3.S: Продавець створює пропозицію на продаж</h2>
<p>Створення пропозиції на продаж означає, що ви оголошуєте про готовність продати певну кількість Bitcoin.<br>
Але цього недостатньо: Продавець повинен зазначити, що він приймає в обмін.<br>
Пропозиція на продаж включає:</p>
<ul>
<li>кількість Bitcoin для продажу</li>
<li>валюти, які Продавець приймає</li>
<li>способи оплати, які приймаються (готівка, банківський переказ, Revolut тощо)</li>
<li>премію (наскільки ціна Bitcoin відрізняється від ринкової)</li>
</ul>
<p>Якщо все йде добре, Покупець зацікавиться пропозицією і надішле запит на угоду.<br>
На цьому етапі він повинен обрати одну валюту та один метод оплати серед доступних. Чим більше варіантів покаже Продавець, тим більше шансів привернути Покупця.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood03.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">
const sats_to_sell = 21000;
  const sell_premium = 1; // 1%
  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

  const { address: returnAddress } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });
  const sellOfferPaymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@myWiseIdTradingBot&quot;,
  });

  const paymentDataEncryptSHA256 = await sha256(sellOfferPaymentDataToEncrypt);

  const offerCreateRes = await session.post(&quot;v1/offer&quot;, {
    type: &quot;ask&quot;,
    amount: sats_to_sell,
    meansOfPayment: { [payment_data_currency]: [payment_data_method] }, // {&quot;EUR&quot;: [&quot;wise&quot;]}
    paymentData: {
      [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
    },
    returnAddress: returnAddress,
    premium: sell_premium,
  });

</code></pre>
<p>Як видно з коду, Продавець пропонує продати 21 000 сатоші (0.00021 Bitcoin) з премією 1%. Він хоче отримати євро через свій акаунт Wise.<br>
Зверніть увагу — він <strong>НЕ</strong> надсилає свій ID акаунта Wise, лише хеш. Peach ніколи не знатиме дані платіжного методу, щоб зберегти анонімність.<br>
Також надсилається зворотна адреса — вона використовується у випадку повернення (якщо жоден покупець не зацікавиться).</p>
<h2 id="4s-escrow-peach">Крок 4.S: Продавець фінансує Escrow у Peach</h2>
<p>Після успішного запиту до API Peach для створення пропозиції продажу, Продавець отримує ID пропозиції:</p>
<pre><code class="language-j">const sellOfferId = offerCreateRes.data.id;

</code></pre>
<p>Це значення важливе — збережіть його. Є інші способи отримати його, але поки просто збережіть.<br>
Пропозиція створена, але ще не опублікована — жоден покупець не може з нею взаємодіяти. Спочатку Продавець повинен профінансувати Escrow.</p>
<p>Escrow — це як сейф, який вимагає дозволу і Продавця, і Peach, щоб відкритися.<br>
Bitcoin розміщується всередині сейфа і залишається там у безпеці до завершення угоди.<br>
Оскільки він вимагає дозволу Продавця, а Escrow є скриптом у блокчейні Bitcoin (адреса P2WSH), Peach потрібен публічний ключ Продавця для створення цього Escrow.</p>
<p>На цьому етапі Продавець надсилає Peach публічний ключ, який хоче використати для Escrow. Peach обирає свій власний публічний ключ і створює спільну адресу.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood04.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">const childSell = root.derivePath(`m/84'/0'/0'/${sellOfferId}'`);

  const keyPairSellOffer = ECPair.fromPrivateKey(childSell.privateKey, {
    network: bitcoin,
  });

  const sellOfferPublicKey = Buffer.from(keyPairSellOffer.publicKey).toString(
    &quot;hex&quot;
  );

  const escrowCreateRes = await session.post(
    &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;,
    {
      publicKey: sellOfferPublicKey,
    }
  );

  const escrowAddress = escrowCreateRes.data.escrows.bitcoin;

  const escrowPeachPublicKey =
    escrowCreateRes.data.escrowPeachPublicKey.bitcoin;

</code></pre>
<p>Як видно з коду, Продавець вирішив створити нову пару ключів, використовуючи ID пропозиції як шлях деривації. Це безпечний і відтворюваний підхід.<br>
Після надсилання публічного ключа API Peach повертає адресу, на яку Продавець має відправити 21 000 сатоші. Але не потрібно просто довіряти — адресу можна перевірити.</p>
<p>Перевірімо!</p>
<p>API Peach також повертає публічний ключ, який Peach використала для цього Escrow, що дозволяє нам відтворити адресу, створивши Bitcoin-скрипт:</p>
<pre><code class="language-j">   OP_IF
       ${script.number.encode(4320).toString(&quot;hex&quot;)}
       OP_CHECKSEQUENCEVERIFY
       OP_DROP
   OP_ELSE
       ${sellerPublicKey}
       OP_CHECKSIGVERIFY
   OP_ENDIF
   ${peachPublicKey}
   OP_CHECKSIG
</code></pre>
<p>Скрипт для Escrow виглядає так:</p>
<ul>
<li>завжди вимагає підпис Peach</li>
<li>і додатково:
<ul>
<li>або підпис Продавця</li>
<li>або проходження 4320 блоків з моменту надсилання Bitcoin</li>
</ul>
</li>
</ul>
<p>Чому 4320 блоків? Це 30 днів майнінгу (1 блок кожні 10 хвилин).<br>
Чому через місяць можна використати лише підпис Peach? Бо Продавці можуть бути неактивні, втратити ключі тощо.<br>
Peach має бездоганну репутацію у збереженні коштів Продавців.</p>
<p>Після створення скрипта ви можете перевірити згенеровану адресу P2WSH і переконатися, що це та сама, яку надіслала API Peach.</p>
<pre><code class="language-j">  const multisigScript = bitcoin.script.compile([
    Buffer.from(sellOfferPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIGVERIFY,
  ]);

  const timelockScript = bitcoin.script.compile([
    bitcoin.script.number.encode(4320),
    bitcoin.opcodes.OP_CHECKSEQUENCEVERIFY,
    bitcoin.opcodes.OP_DROP,
  ]);

  const redeemScript = bitcoin.script.compile([
    bitcoin.opcodes.OP_IF,
    ...timelockScript,
    bitcoin.opcodes.OP_ELSE,
    ...multisigScript,
    bitcoin.opcodes.OP_ENDIF,
    Buffer.from(escrowPeachPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIG,
  ]);

  const escrowPayment = bitcoin.payments.p2wsh({
    redeem: { output: redeemScript },
    network: bitcoin,
  });

  console.log(&quot;Addresses Match:&quot;, escrowPayment.address === escrowAddress);

</code></pre>
<p>Ідеально! Тепер просто відправте Bitcoin на цю адресу й дочекайтеся підтвердження фінансування Escrow.</p>
<pre><code class="language-j">  while (true) {
    const fundingStatusRes = await session.get(
      &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;
    );
    if (fundingStatusRes.data.funding.status === &quot;FUNDED&quot;) {
      break;
    }
  }

</code></pre>
<p>Після підтвердження (після одного блоку) пропозиція стає публічною, і покупці можуть почати взаємодію з нею.</p>
<h2 id="5b">Крок 5.B: Покупець надсилає запит на угоду до пропозиції</h2>
<p>Настав час дій для Покупця!</p>
<p>Спершу переглянемо всі доступні пропозиції продажу:</p>
<pre><code class="language-j">const sellOffers = await session.get(&quot;v069/sellOffer&quot;);
</code></pre>
<p>Для спрощення Покупець зацікавиться першою доступною пропозицією.</p>
<pre><code class="language-j">const sellOfferToTradeRequestId = sellOffers.data.offers[0].id;
</code></pre>
<p>Тепер Покупець хоче зробити запит на угоду, повідомивши Продавцю, що готовий торгувати на запропонованих умовах.<br>
Звучить просто, чи не так? Але це найскладніший крок у всьому процесі.</p>
<p>Покупець повинен надіслати:</p>
<ul>
<li>бажаний метод оплати (дозволений Продавцем)</li>
<li>бажану валюту</li>
<li>симетричний ключ (для безпосереднього спілкування з Продавцем) — зашифрований</li>
<li>підпис цього ключа</li>
<li>зашифровані платіжні дані</li>
<li>підпис платіжних даних</li>
<li>адресу отримання Bitcoin після угоди</li>
<li>підпис повідомлення про володіння адресою (BIP 322)</li>
<li>максимальну комісію за майнінг</li>
</ul>
<p>Багато, правда? Але саме це робить Peach такою безпечною!<br>
Розберімо крок за кроком.</p>
<h3 id="-2">Симетричний ключ:</h3>
<p>Симетричний ключ буде використовуватися з двостороннім шифруванням AES256:<br>
ви можете зашифрувати повідомлення й розшифрувати його тим самим ключем.</p>
<pre><code class="language-j">async function decryptDataWithSymmetricKey(encryptedMessage, symmetricKey) {
  const message = await openpgp.readMessage({
    armoredMessage: encryptedMessage,
  });

  const { data: decrypted } = await openpgp.decrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;utf8&quot;,
  });

  return decrypted;
}

async function encryptDataWithSymmetricKey(data, symmetricKey) {
  const message = await openpgp.createMessage({ text: data });
  const encrypted = await openpgp.encrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;armored&quot;,
    config: {
      preferredSymmetricAlgorithm: openpgp.enums.symmetric.aes256,
    },
  });
  return encrypted;
}

</code></pre>
<p>Щоб створити його, просто згенеруйте випадкове число:</p>
<pre><code class="language-j">  const symmetricKey = randomBytes(32);
  const symmetricKeyHex = symmetricKey.toString(&quot;hex&quot;);

</code></pre>
<p>Але не можна передавати цей ключ у відкритому вигляді — це зруйнує мету шифрування.<br>
Його потрібно зашифрувати так, щоб лише Покупець і Продавець могли його розшифрувати.<br>
Оскільки обидва надали свої публічні PGP-ключі, потрібно зашифрувати його так, щоб його можна було розшифрувати тільки за допомогою відповідного приватного PGP-ключа:</p>
<pre><code class="language-j">async function encryptForMultipleRecipients(secret, publicKeysArmored) {
  const publicKeys = await Promise.all(
    publicKeysArmored.map((armored) =&gt; openpgp.readKey({ armoredKey: armored }))
  );
  const message = await openpgp.createMessage({ text: secret });

  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: publicKeys,
  });

  return encrypted;
}

  const matchingUserPgpPubKey = sellOffers.data.offers[0].user.pgpPublicKey;

  const symmetricKeyEncrypted = await encryptForMultipleRecipients(
    symmetricKeyHex,
    [pgpPublicKey, matchingUserPgpPubKey]
  );

</code></pre>
<p>І щоб Продавець був упевнений, що симетричний ключ створив саме Покупець, той має підписати його своїм PGP-ключем:</p>
<pre><code class="language-j">  const symmetricKeySignature = await signPGPMessage(
    pgpPrivateKey,
    symmetricKeyHex
  );

</code></pre>
<h3 id="-3">Платіжні дані:</h3>
<p>Це найцінніша частина інформації — ваші платіжні дані.<br>
Це може бути ваш банківський IBAN, ім’я користувача Revolut або інші реквізити, за якими можна ідентифікувати відправника фіат-переказу.<br>
Продавець пізніше надішле свої дані Покупцю.</p>
<p>Тепер, коли у нас є симетричний ключ, ми можемо використати його для шифрування платіжних даних, які Продавець згодом розшифрує.</p>
<pre><code class="language-j">const paymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@buyerWiseId&quot;,
  });

const paymentDataEncrypted = await encryptDataWithSymmetricKey(
paymentDataToEncrypt,
symmetricKeyHex
);

const paymentDataSignature = await signPGPMessage(
pgpPrivateKey,
paymentDataToEncrypt
);

</code></pre>
<h3 id="-4">Визначення адреси отримання та підтвердження володіння:</h3>
<p>Ви повинні визначити, куди саме хочете, щоб після угоди було надіслано Bitcoin.<br>
Створити адресу просто, а от довести володіння — складніше.<br>
Це робиться для регуляторних вимог і як додатковий захід безпеки (саме він робить Peach несприйнятливою до <strong>Attack Replacement Attack</strong>, виявленої у вересні 2025 р.).</p>
<p>Доказ володіння здійснюється за допомогою <strong>BIP-322</strong>, який дозволяє підписати повідомлення приватним Bitcoin-ключем, а перевірку виконати через саму адресу.</p>
<pre><code class="language-j">  const { address } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });

  const ownershipMessage =
    &quot;I confirm that only I, peach&quot; +
    publicKeyHex.slice(0, 8) +
    &quot;, control the address &quot; +
    address;

  const releaseAddressSignature = signWithBIP322(
    wif,
    address,
    ownershipMessage
  );

</code></pre>
<h3 id="-5">І остання деталь: максимальна комісія майнерів</h3>
<p>Як Покупець, ви можете не захотіти витрачати надто багато на комісію за транзакцію.<br>
У такому випадку можна вказати <strong>максимальну комісію за майнінг</strong>, яку ви готові “заплатити”, щоб отримати Bitcoin.</p>
<h3 id="-6">Нарешті, створюємо запит на угоду</h3>
<p>Оце так процес, га? Але ось ми й дійшли до моменту надсилання запиту:</p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; + sellOfferToTradeRequestId + &quot;/tradeRequestPerformed&quot;,
    {
      paymentMethod: payment_data_method,
      currency: payment_data_currency,
      paymentDataHashed: paymentDataToEncryptSHA256,
      paymentDataEncrypted: paymentDataEncrypted,
      paymentDataSignature: paymentDataSignature,
      symmetricKeyEncrypted: symmetricKeyEncrypted,
      symmetricKeySignature: symmetricKeySignature,
      maxMiningFeeRate: 2, // sats/vb
      releaseAddress: address,
      releaseAddressMessageSignature: releaseAddressSignature,
    }
  );

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood05.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Тепер черга Продавця прийняти його.</p>
<h2 id="5s">Крок 5.S: Продавець приймає запит на угоду</h2>
<p>Продавець чекав, поки хтось відреагує на його пропозицію продажу.<br>
Він перевіряє список запитів на угоду:</p>
<pre><code class="language-j">const receivedTradeRequestRequest = await session.get(
    &quot;v069/sellOffer/&quot; + sellOfferId + &quot;/tradeRequestReceived&quot;
  );

  const tradeReq = receivedTradeRequestRequest.data[0];

</code></pre>
<p>Якщо Продавець хоче прийняти запит, він повинен поділитися своїми платіжними даними з Покупцем, щоб той знав, куди надсилати фіат-платіж.</p>
<p>Оскільки симетричний ключ уже був створений і надісланий Покупцем, Продавець може його розшифрувати (адже він був зашифрований його публічним PGP-ключем) і використати цей самий ключ для шифрування своїх платіжних даних.</p>
<pre><code class="language-j">  const receivedSymmetricKey = await decryptWithPrivateKey(
    tradeReq.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  const sellOfferPaymentDataEncrypted = await encryptDataWithSymmetricKey(
    sellOfferPaymentDataToEncrypt,
    receivedSymmetricKey
  );

  const sellOfferPaymentDataSignature = await signPGPMessage(
    pgpPrivateKey,
    sellOfferPaymentDataToEncrypt
  );

</code></pre>
<p>І все! Тепер Продавець може прийняти запит — і офіційна торгівля розпочинається!</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood06.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; +
      sellOfferId +
      &quot;/tradeRequestReceived/&quot; +
      tradeReq.userId +
      &quot;/accept&quot;,
    {
      paymentDataEncrypted: sellOfferPaymentDataEncrypted,
      paymentDataSignature: sellOfferPaymentDataSignature,
      paymentData: {
        [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
      },
    }
  );

</code></pre>
<p>Якщо весь процес здається складним — ось схема, що ілюструє його:</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood07.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 90%;">
<br><br></p>
<h2 id="6b">Крок 6.B: Покупець оголошує, що платіж виконано</h2>
<p>Покупець може перевірити, чи має він активні контракти (тобто угоди, які погоджені обома сторонами) через запит до <code>contract summaries</code> у API:</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data.find((obj) =&gt;
    obj.id.startsWith(sellOfferToTradeRequestId + &quot;-&quot;)
  );

  if (contract.tradeStatus !== &quot;paymentRequired&quot;) throw Error;
</code></pre>
<p>У відповідь він отримає список усіх контрактів, у яких бере участь.<br>
Якщо один із них має статус <strong>“paymentRequired”</strong>, це означає, що зараз його черга здійснити фіат-переказ.</p>
<p>Для цього він повинен розшифрувати платіжні дані Продавця за допомогою симетричного ключа, створеного під час запиту на угоду.<br>
Якщо він не зберіг ключ — не страшно, його можна розшифрувати за допомогою приватного PGP-ключа Покупця.</p>
<pre><code class="language-j">
  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

  const receivedSymmetricKey = await decryptWithPrivateKey(
    contractRes.data.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  if (receivedSymmetricKey !== symmetricKeyHex) throw Error;

  const decryptedSellerPaymentData = await decryptDataWithSymmetricKey(
    contractRes.data.paymentDataEncrypted,
    receivedSymmetricKey
  );

  console.log(&quot;Seller Payment Data &quot;, JSON.parse(decryptedSellerPaymentData));
</code></pre>
<p>Далі все відбувається поза межами Peach:<br>
Покупець відкриває свій банківський застосунок (або аналог) і здійснює переказ фіатних коштів за реквізитами Продавця.</p>
<p>Якщо ви, читаючи це, сумніваєтеся — пам’ятайте: Bitcoin уже знаходиться в Escrow, який контролюється Peach і Продавцем.<br>
Можна навіть перевірити адресу Escrow (вона є у даних контракту, що повертає API) і через блокчейн-експлорер переконатися, що Bitcoin там.</p>
<p>Після здійснення фіат-переказу Покупець має повідомити, що платіж виконано:</p>
<pre><code class="language-j">  const confirmPaymentRes = await session.post(
    &quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;
  );
</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood08.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Це був останній крок Покупця.<br>
Тепер Продавець має підтвердити, що отримав фіат, і відпустити Bitcoin із Escrow на адресу Покупця.</p>
<h2 id="6s">Крок 6.S: Продавець підтверджує отримання платежу</h2>
<p>Так само, як і Покупець, Продавець перевіряє контракти, призначені йому.</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data[0];

  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

</code></pre>
<p>У відповіді API контракту Продавець отримає <strong>PSBT</strong> (Partially Signed Bitcoin Transaction) — це частково підписана транзакція з Escrow на адресу Покупця, підписана Peach.<br>
Це означає, що для її дійсності бракує лише підпису Продавця.</p>
<pre><code class="language-j">  const releasePSBTBase64 = contractRes.data.releasePsbt;

  const parsedPSBT = bitcoin.Psbt.fromBase64(releasePSBTBase64, {
    network: bitcoin,
  });

  parsedPSBT.signInput(0, childSell);

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood09.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Тепер Продавець може фіналізувати транзакцію, передавши обидва підписи та скрипт Escrow.<br>
Оскільки ми використовуємо шлях <strong>MultiSig</strong> (другий варіант у скрипті), потрібно додати <code>OP_FALSE</code> у стек, щоб IF-умова обробилася правильно.</p>
<pre><code class="language-j">export const getFinalScript = (_inputIndex, input, bitcoinScript) =&gt; {
  const network = bitcoin;

  const payment = payments.p2wsh({
    network,
    redeem: {
      network,
      output: bitcoinScript,
      input: bitcoin.script.compile([
        input.partialSig[0].signature,
        input.partialSig[1].signature,
        opcodes.OP_FALSE,
      ]),
    },
  });

  parsedPSBT.finalizeInput(0, getFinalScript);

  const tx = parsedPSBT.extractTransaction().toHex();

</code></pre>
<p>Останній крок: надіслати фіналізовану транзакцію до API Peach:</p>
<pre><code class="language-j">  await session.post(&quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;, {
    releaseTransaction: tx,
  });

</code></pre>
<p>Пані та панове — ось як ми торгуємо на Peach із максимальною безпекою та приватністю!</p>
<p class="date">October 23rd, 2025</p><p class="tags">Tagged with:<a href="/uk/blog/tag/">Продукт</a><a href="/uk/blog/tag/p2p">P2P</a><a href="/uk/blog/tag/">Навчання</a></p><p><a href="/uk/blog/">All blog posts</a></p></div></section></main><footer class="footer" id="footer"><div class="wrap"><div class="logo-section"><div class="logo"><img class="logo-image" src="/img/peach-footer-logo-e28fd7e07f654f43afd63c9b6ace3cdb.svg" alt="Peach logo"/><span>Made in Switzerland <img src="/img/flags/switzerland-icon.svg" style="width: 1rem; margin-left .5rem;"/></span></div><div class="company-info"> <img class="polyreg-image" src="/img/polyreg-52ec37fb80d0312b219110c05567ad3d.png" alt="Polyreg logo" width="120"/><p>Peach є членом SRO (саморегулююча організація) Polyreg </p><p>Peach є ліцензованим постачальником фінансових послуг у Швейцарії та повністю відповідає Закону Швейцарії про боротьбу з відмиванням грошей. </p></div></div><div class="content"><div class="footer-box"><h6>Компанія</h6><a href="/uk/join-us/">Приєднуйтесь до нас</a><a href="/uk/terms-and-conditions/">Умови використання</a><a href="/uk/privacy-policy/">Політика конфіденційності</a><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Керувати налаштуваннями cookie</a></div><div class="footer-box"><h6>Контакт</h6><a href="mailto:hello@peachbitcoin.com">Email</a><a href="https://keys.openpgp.org/vks/v1/by-fingerprint/48339A19645E2E53488E0E5479E1B270FACD1BD2">PGP ключ</a></div><div class="footer-box"><h6>Завантажити</h6><span>0.69.0 (294)</span><a href="/uk/apk/">APK</a><a href="https://testflight.apple.com/join/wfSPFEWG">iPhone</a><a href="https://play.google.com/store/apps/details?id=com.peachbitcoin.peach.mainnet">Android</a></div><div class="footer-box"><h6>Спільнота</h6><a href="https://twitter.com/peachbitcoin" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://t.me/peachtopeach" target="_blank" rel="noreferrer noopener">Telegram</a><a href="https://discord.gg/ypeHz3SW54" target="_blank" rel="noreferrer noopener">Discord</a><a href="https://www.instagram.com/peachbitcoin/" target="_blank" rel="noreferrer noopener">Instagram</a><a href="https://snort.social/p/npub15369wu3wzzar5fclhecyqfv683x69n6nhlg7rxqnsg2dydgxflpq3apswl" target="_blank" rel="noreferrer noopener">Nostr</a><a href="https://github.com/Peach2Peach" target="_blank" rel="noreferrer noopener">Github</a><a href="https://www.youtube.com/@peachbitcoin" target="_blank" rel="noreferrer noopener">YouTube</a></div><div class="footer-box"><h6>Bitcoin</h6><a href="/bitcoin.pdf">Біллаін</a><a href="https://docs.peachbitcoin.com">Документація API</a></div><div class="footer-box"><h6>Зарабатуйте Bitcoin</h6><a href="/uk/new-users/">Реферальний код</a><a href="/uk/for-businesses/">Стати партнером</a></div></div></div></footer><style>#cookie-banner {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: #120A07;
  color: #fff;
  padding: 15px 0;
  z-index: 9999;
  font-size: 14px;
}
#cookie-banner .cookie-container {
  width: 90%;
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
}
#cookie-banner p {
  margin: 0;
  line-height: 1.4;
}
#cookie-banner .cookie-actions {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}
#cookie-banner button {
  padding: 10px 16px;
  color: #fff;
  background-color: #65A519;
  border: none;
  cursor: pointer;
  border-radius: 4px;
  font-size: 14px;
  transition: background-color 0.3s ease;
}
#cookie-banner button:hover {
  background-color: #65A519;
}
#cookie-banner button.reject {
  background-color: #DF321F;
}
#cookie-banner button.reject:hover {
  background-color: #DF321F;
}
#cookie-banner a.cookie-link {
  color: #fff;
  text-decoration: underline;
  font-size: 14px;
  margin-left: 8px;
  cursor: pointer;
}
#cookie-banner a.cookie-link:hover {
  text-decoration: none;
}
/* Popup overlay */
#cookie-popup {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  z-index: 10000;
  justify-content: center;
  align-items: center;
  color: #fff;
}
/* Contenitore del popup */
#cookie-popup-content {
  position: relative;
  background-color: #120A07;
  color:rgb(255, 255, 255);
  padding: 30px 20px 20px;
  border-radius: 10px;
  width: 80%;
  max-width: 600px;
  box-sizing: border-box;
}
/* Pulsante di chiusura */
#cookie-popup-content .close-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  color: #fff;
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  padding: 0 5px;
}
#cookie-popup-content .close-btn:hover {
  color: #ccc;
}
/* Stile per ciascuna categoria di cookie */
.cookie-category {
  margin-bottom: 20px;
}
/* Migliora i checkbox e le label */
.cookie-category label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 15px;
}
.cookie-category input[type="checkbox"] {
  accent-color: #4CAF50;
  margin: 0;
  cursor: pointer;
}
.cookie-category p {
  margin: 4px 0 0 28px;
  font-size: 14px;
  line-height: 1.4;
  color: #ccc;
}
/* Bottone "Salva Preferenze" */
#cookie-popup-content button.save-btn {
  background-color: #4CAF50;
  border: none;
  padding: 10px 16px;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}
#cookie-popup-content button.save-btn:hover {
  background-color: #43a047;
}
/* Media query per schermi più piccoli */
@media (max-width: 768px) {
  #cookie-banner .cookie-container {
    flex-direction: column;
    align-items: flex-start;
  }
  #cookie-banner .cookie-actions {
    margin-top: 10px;
    width: 100%;
    justify-content: flex-start;
    gap: 8px;
    flex-wrap: wrap;
  }
}

</style><div id="cookie-banner" style="display: none;"><div class="cookie-container"><p>Ми використовуємо файли cookie, щоб покращити ваш досвід. <a href="/privacy-policy" style="color: #4CAF50;">Дізнатися більше</a></p><div class="cookie-actions"><button class="cookie-btn" onclick="acceptCookies()">Прийняти файли cookie та продовжити</button><button class="cookie-btn reject" onclick="rejectCookies()">Відхилити файли cookie</button><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Керування файлами cookie</a></div></div></div><div id="cookie-popup"><div id="cookie-popup-content"><button class="close-btn" type="button" onclick="closeCookiePopup()">×</button><h2>Керування налаштуваннями файлів cookie</h2><div class="cookie-category"><div class="switch-container"><span class="label-text">Необхідні файли cookie</span><label class="switch" for="necessary-cookies"><input type="checkbox" id="necessary-cookies" checked="checked" disabled="disabled"/><span class="slider"></span></label></div><p>Ці файли cookie є необхідними для роботи вебсайту.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Аналітичні файли cookie</span><label class="switch" for="analytics-cookies"><input type="checkbox" id="analytics-cookies"/><span class="slider"></span></label></div><p>Аналітичні файли cookie допомагають нам зрозуміти, як користувачі взаємодіють із сайтом.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Маркетингові файли cookie</span><label class="switch" for="marketing-cookies"><input type="checkbox" id="marketing-cookies"/><span class="slider"></span></label></div><p>Маркетингові файли cookie використовуються для збирання інформації про користувачів</p></div><div style="text-align: right; margin-top: 20px;"><button class="save-btn" type="button" onclick="savePreferences()">Зберегти налаштування</button></div></div></div><script src="/js/main-15c0432b5e5f06cbab9e3fedcaae3032.js"></script><script>if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/service-worker.js')
      .then(function(registration) {
        console.log('Service Worker registrato con successo:', registration);
      })
      .catch(function(error) {
        console.log('Registrazione del Service Worker fallita:', error);
      });
  });
} else {
  console.log('Service Worker non supportato in questo browser.');
}</script><script>window.onload = function() {
  setTimeout(function() {
    const languageLabel = document.querySelector('.language-label img');

    const languageMap = {
      'en': { text: 'English', flag: '/img/en-872bf10f0d1ed191b502494534bb329a.png' },
      'es': { text: 'Español', flag: '/img/es-b17fc8846b93c5446b10cd7824434504.png' },
      'de': { text: 'Deutsch', flag: '/img/de-0da84d0f3850d6e25088debeb3ade32c.png' },
      'it': { text: 'Italiano', flag: '/img/it-299996a0097e49e1bc4f312e380d3faa.png' },
      'fr': { text: 'Français', flag: '/img/fr-75a63faa5728ac4175214da6cd3c47f1.png' },
      'el': { text: 'Ελληνικά', flag: '/img/el-27d234921e954ed945c93bef880a07b6.png' },
      'hu': { text: 'Magyar', flag: '/img/hu-fc4c517f481932d60d59b56a8f0c322d.png' },
      'nl': { text: 'Nederlands', flag: '/img/nl-83a65573b2d26cdce16cab98f8c38db1.png' },
      'pl': { text: 'Polski', flag: '/img/pl-f7c03eb5351f5b2e33c9b29f1e200e38.png' },
      'pt': { text: 'Português', flag: '/img/pt-997fb3879120a45e1ba507a9e060a662.png' },
      'sw': { text: 'Kiswahili', flag: '/img/sw-cdf6e2b06778f5ac662fb25f3ca8eac0.png' },
      'uk': { text: 'Українська', flag: '/img/ua-f7a81ef67d0931a29f7e358bb99ef521.png' }
    };

    const currentPath = window.location.pathname;
    let currentLang = 'en';

    // Determinare la lingua corrente dal percorso
    for (const lang in languageMap) {
      if (currentPath.includes('/' + lang)) {
        currentLang = lang;
        break;
      }
    }

    // Aggiorna la bandiera e il testo dinamicamente
    if (languageLabel && languageMap[currentLang]) {
      languageLabel.src = languageMap[currentLang].flag;
    }
  }); // Ritardo per garantire che la pagina sia completamente caricata
};
</script><script>window.__ow = window.__ow || {};
window.__ow.organizationId = "8b099b27-4836-4896-9087-a7ed505dec79";
window.__ow.template_id = "b97be07a-7dcf-48af-8d69-a9dfae5dfc29";
window.__ow.integration_name = "manual_settings";
window.__ow.product_name = "chatbot";   
;(function(n,t,c){function i(n){return e._h?e._h.apply(null,n):e._q.push(n)}var e={_q:[],_h:null,_v:"2.0",on:function(){i(["on",c.call(arguments)])},once:function(){i(["once",c.call(arguments)])},off:function(){i(["off",c.call(arguments)])},get:function(){if(!e._h)throw new Error("[OpenWidget] You can't use getters before load.");return i(["get",c.call(arguments)])},call:function(){i(["call",c.call(arguments)])},init:function(){var n=t.createElement("script");n.async=!0,n.type="text/javascript",n.src="https://cdn.openwidget.com/openwidget.js",t.head.appendChild(n)}};!n.__ow.asyncInit&&e.init(),n.OpenWidget=n.OpenWidget||e}(window,document,[].slice))</script><noscript>You need to <a href="https://www.chatbot.com/help/chat-widget/enable-javascript-in-your-browser/" rel="noopener nofollow">enable JavaScript</a> in order to use the AI chatbot tool powered by <a href="https://www.chatbot.com/" rel="noopener nofollow" target="_blank">ChatBot</a></noscript><script>(function() {
  // Funzioni di utilità per gestire i cookie
  function setCookie(name, value, days) {
    var expires = "";
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
      expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "") + expires + "; path=/";
  }

  function getCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  }

  // Controlla se il consenso è già stato dato per nascondere il banner
  function checkConsent() {
    if (getCookie('consent_necessary') === "true") {
      document.getElementById('cookie-banner').style.display = 'none';
    } else {
      document.getElementById('cookie-banner').style.display = 'flex';
    }
  }

  // Funzione per accettare tutti i cookie
  window.acceptCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'true', 365);
    setCookie('consent_marketing', 'true', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: true, consent_marketing: true});
  };

  // Funzione per rifiutare cookie opzionali (analytics e marketing)
  window.rejectCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'false', 365);
    setCookie('consent_marketing', 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: false, consent_marketing: false});
  };

  // Mostra il popup per gestire le preferenze dei cookie
  window.showCookiePopup = function(event) {
    event.preventDefault();
    document.getElementById('cookie-popup').style.display = 'flex';
  };
  window.closeCookiePopup = function() {
  document.getElementById('cookie-popup').style.display = 'none';
  };

  // Salva le preferenze impostate nel popup
  window.savePreferences = function() {
    var analyticsConsent = document.getElementById('analytics-cookies').checked;
    var marketingConsent = document.getElementById('marketing-cookies').checked;
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', analyticsConsent ? 'true' : 'false', 365);
    setCookie('consent_marketing', marketingConsent ? 'true' : 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: analyticsConsent, consent_marketing: marketingConsent});
  };

  // Inizializza il controllo del consenso al caricamento della pagina
  checkConsent();
})();</script></body></html>