<!DOCTYPE html><html lang="fr"><head><meta charset="UTF-8"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><meta http-equiv="X-Frame-Options" content="DENY"/><meta http-equiv="X-XSS-Protection" content="1; mode=block"/><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/><meta name="keywords" content="[&quot;Produit&quot;,&quot;P2P&quot;,&quot;tutoriel&quot;,&quot;programmation&quot;,&quot;javascript&quot;,&quot;bitcoin&quot;]"/><meta name="description" content="Aaaaah, le Bitcoin — cette merveilleuse forme de monnaie qui prospère grâce à ses caractéristiques fondamentales. Nous l’aimons tous, mais nous savons aussi qu’il comporte des risques liés à la souveraineté individuelle : partagez vos seeds, et vous perdez tout. Envoyez des fonds à la mauvaise adresse, et vous ne les reverrez jamais."/><meta property="og:locale" content="fr"/><meta property="og:site_name"/><meta property="og:title" content="Peach Bitcoin Exchange - Buy and Sell Bitcoin Anonymously and Without KYC"/><meta property="og:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta property="og:type" content="website"/><meta property="og:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:secure_url" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:width" content="1296"/><meta property="og:image:height" content="678"/><meta name="twitter:site" content="@peachbitcoin"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Peach Bitcoin sous le capot : un regard technique sur pourquoi c’est le plus sûr des échanges P2P · Peach Bitcoin"/><meta name="twitter:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and  without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta name="twitter:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta name="msapplication-TileColor" content="#F56522"/><meta name="cf-2fa-verify" content="e22767e30dc139c"/><meta name="theme-color" content="#F56522"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-regular.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-600.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-800.woff2"/><link rel="apple-touch-icon" href="/img/favicon/apple-touch-icon.png"/><link rel="icon" href="/img/favicon/favicon.svg"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/img/favicon/safari-pinned-tab.svg" color="#F56522"/><link rel="stylesheet" href="/css/main-b3f858619e229dd5f6c79ee84b2440d2.css"/><title>Peach Bitcoin sous le capot : un regard technique sur pourquoi c’est le plus sûr des échanges P2P · Peach Bitcoin</title><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KQHJRQKH');</script></head><body id="blog-peach-under-the-hood"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KQHJRQKH" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><header class="header header-container" id="header"><div class="wrap"><a class="logo-link brand" href="/fr/"><img class="logo logo" src="/img/peach-bitcoin-145cd6c0079ccacc9c70c892060964d1.svg" alt="Peach Bitcoin"/></a><input id="show-menu" type="checkbox"/><label class="nav-toggle-label" id="nav-toggle" for="show-menu"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path class="line--1" d="M0 70l28-28c2-2 2-2 7-2h64"></path><path class="line--2" d="M0 50h99"></path><path class="line--3" d="M0 30l28 28c2 2 2 2 7 2h64"></path></svg></label><nav class="nav"><a href="/fr/how-it-works/">Acheter BTC sans KYC</a><a href="/fr/for-meetups/">Acheter BTC en espèces</a><a href="/fr/for-businesses/">Vendre BTC</a><a href="/fr/blog/">Blog</a><a href="/fr/support/">Support</a><div class="language-selector"><input class="checkbox" type="checkbox" id="language-toggle"/><label class="language-label" for="language-toggle"><span class="language-text">Français</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="white" style="margin-left: .25rem;"><path d="M7 10l5 5 5-5z"></path></svg></label><ul class="language-dropdown"><li><a href="/"> <span>English</span></a></li><li><a href="/es"> <span>Español</span></a></li><li><a href="/de"> <span>Deutsch</span></a></li><li><a href="/it"> <span>Italiano</span></a></li><li><a href="/fr"> <span>Français</span></a></li><li><a href="/pt"> <span>Português</span></a></li></ul></div></nav></div></header><main class="main" id="main"><div id="header-anchor"></div><section class="wrap"><div class="content-wrap post"><h1 id="peach-bitcoin-sous-le-capot-un-regard-technique-sur-pourquoi-cest-le-plus-sr-des-changes-p2p">Peach Bitcoin sous le capot : un regard technique sur pourquoi c’est le plus sûr des échanges P2P</h1>
<div class="video-wrapper">
  <iframe
    src="https://www.youtube.com/embed/UvdbHlsPmK0"
    title="PEACH VIDEO OF Under the Hood"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>
<p>Aaaaah, le Bitcoin — cette merveilleuse forme de monnaie qui prospère grâce à ses caractéristiques fondamentales. Nous l’aimons tous, mais nous savons aussi qu’il comporte des risques liés à la souveraineté individuelle : partagez vos seeds, et vous perdez tout. Envoyez des fonds à la mauvaise adresse, et vous ne les reverrez jamais.</p>
<p>C’est pourquoi le code open source dans l’écosystème Bitcoin est si important — et l’application Peach est disponible sur Github pour que tout le monde puisse la consulter !</p>
<p>Bien sûr, open source ne veut pas dire que tout le monde lira le code avec attention ou analysera son fonctionnement en détail.<br>
C’est pourquoi j’écris cet article : pour <strong>montrer à quel point Peach est sécurisé</strong> et quelles sont les étapes mises en place pour y parvenir.</p>
<h2 id="tape-1-crer-un-compte-sans-kyc-sur-peach">Étape 1 : créer un compte sans KYC sur Peach</h2>
<p>Soyons clairs : votre seed Bitcoin <strong>est</strong> votre compte Peach.</p>
<p>Si vous souhaitez utiliser Peach, vous devez créer un compte, ce qui consiste à partager la clé publique de votre compte et à prouver que vous en êtes le propriétaire.</p>
<p>Pour cela, il faut :</p>
<ul>
<li>1 - obtenir la date et l’heure actuelles (en millisecondes) sous forme de texte</li>
<li>2 - utiliser votre clé privée pour générer une signature de ce texte</li>
<li>3 - soumettre la clé publique, la date/heure actuelle et la signature</li>
</ul>
<p>Vous devez également générer un <code>uniqueId</code>, qui servira à empêcher d’autres utilisateurs de se faire passer pour vous.<br>
Cela est utile dans des cas comme la perte de vos seeds tout en souhaitant garder le même compte.<br>
Mais ne nous attardons pas trop là-dessus.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood01.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<p>Voici le code Javascript correspondant :</p>
<pre><code class="language-j">
  const seed = randomBytes(64);

  const root = bip32.fromSeed(seed, bitcoin);
  const child = root.derivePath(&quot;m/0&quot;);
  const keyPair = ECPair.fromPrivateKey(child.privateKey, { network: bitcoin });

  const publicKeyHex = Buffer.from(keyPair.publicKey).toString(&quot;hex&quot;);

  const session = axios.create({
    baseURL: &quot;https://api.peachbitcoin.com/&quot;,
    httpAgent: new http.Agent({ keepAlive: false }),
    httpsAgent: new https.Agent({ keepAlive: false }),
  });

  const registerMessage = String(Date.now());
  const registerMessageSignature = signWithBtcPrivKey(registerMessage, keyPair);

  const resp = await session.post(&quot;v1/user/register&quot;, {
    publicKey: publicKeyHex,
    message: registerMessage,
    signature: registerMessageSignature,
    uniqueId: &quot;my_own_unique_id_random_12345&quot;,
  });

  const accessToken = resp.data.accessToken;

  session.defaults.headers.common[&quot;authorization&quot;] = accessToken;

</code></pre>
<p>Félicitations ! Vous venez de créer un compte sur Peach !<br>
Le serveur a validé que vous êtes, à ce moment précis, le propriétaire de la paire de clés Bitcoin correspondant à la clé publique soumise.</p>
<h2 id="tape-2-soumettre-votre-cl-publique-pgp">Étape 2 : soumettre votre clé publique PGP</h2>
<p>Il y aura beaucoup de chiffrement… mais aussi un peu de déchiffrement.<br>
Les clés Bitcoin ne permettent qu’un chiffrement à sens unique, donc nous aurons besoin de clés PGP pour permettre le chiffrement et le déchiffrement bidirectionnels.<br>
C’est essentiel pour sécuriser les données bancaires, les messages de chat, etc.</p>
<p>Soumettre la clé publique PGP est similaire au processus de soumission de la clé publique Bitcoin, mais il y a une étape supplémentaire :<br>
vous devez <strong>signer la clé publique PGP avec votre clé privée Bitcoin</strong>, afin de confirmer que vous êtes bien le propriétaire des deux clés (Bitcoin et PGP).</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood02.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<pre><code class="language-j">
const { privateKey: pgpPrivateKey, publicKey: pgpPublicKey } =
    await createPGPKey();

  const pgpPublicKeyMessageSignature = signWithBtcPrivKey(
    pgpPublicKey,
    keyPair
  );
  const setPgpKeysMessage = String(Date.now());

  const setPgpKeysMessageSignature = await signPGPMessage(
    pgpPrivateKey,
    setPgpKeysMessage
  );

  await session.patch(&quot;v1/user&quot;, {
    pgpPublicKey: pgpPublicKey, // the PGP Pub key
    signature: pgpPublicKeyMessageSignature, // the above signed by the BTC Key
    message: setPgpKeysMessage, // the current timestamp
    pgpSignature: setPgpKeysMessageSignature, // the above signed by the PGP Key
  });

</code></pre>
<p>À ce stade, Peach possède vos deux clés publiques — Bitcoin et PGP !<br>
Cela sera très important pour le trading sur Peach.</p>
<h2 id="tapes-suivantes">Étapes suivantes</h2>
<p>À partir de maintenant, le tutoriel va présenter les deux côtés : celui de l’Acheteur et celui du Vendeur.</p>
<p>Les étapes seront les suivantes :</p>
<ul>
<li>3.S Le Vendeur crée une offre de vente</li>
<li>4.S Le Vendeur alimente l’Escrow de Peach</li>
<li>5.B L’Acheteur fait une demande d’échange sur l’offre de vente</li>
<li>5.S Le Vendeur accepte la demande d’échange</li>
<li>6.B L’Acheteur déclare que le paiement fiat a été effectué</li>
<li>6.S Le Vendeur confirme qu’il a reçu le paiement</li>
</ul>
<h2 id="tape-3s-le-vendeur-cre-une-offre-de-vente">Étape 3.S : le Vendeur crée une offre de vente</h2>
<p>Créer une offre de vente revient à annoncer que vous êtes prêt à vendre un certain montant de Bitcoin.<br>
Mais ce n’est pas tout : le Vendeur doit également préciser ce qu’il accepte en échange.</p>
<p>Une offre de vente comprend :</p>
<ul>
<li>le montant de Bitcoin à vendre</li>
<li>les devises acceptées par le Vendeur</li>
<li>les méthodes de paiement acceptées (espèces, virement bancaire, Revolut, etc.)</li>
<li>la prime (le pourcentage au-dessus du prix du marché actuel)</li>
</ul>
<p>Si tout se passe bien, un Acheteur sera intéressé par cette offre et demandera à échanger.<br>
À ce moment-là, il devra sélectionner une seule devise et une seule méthode de paiement parmi celles proposées.<br>
Plus le Vendeur en propose, plus il a de chances d’attirer un Acheteur.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood03.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">
const sats_to_sell = 21000;
  const sell_premium = 1; // 1%
  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

  const { address: returnAddress } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });
  const sellOfferPaymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@myWiseIdTradingBot&quot;,
  });

  const paymentDataEncryptSHA256 = await sha256(sellOfferPaymentDataToEncrypt);

  const offerCreateRes = await session.post(&quot;v1/offer&quot;, {
    type: &quot;ask&quot;,
    amount: sats_to_sell,
    meansOfPayment: { [payment_data_currency]: [payment_data_method] }, // {&quot;EUR&quot;: [&quot;wise&quot;]}
    paymentData: {
      [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
    },
    returnAddress: returnAddress,
    premium: sell_premium,
  });

</code></pre>
<p>Comme on peut le voir dans le code, le Vendeur annonce qu’il vend 21 000 sats (0.00021 Bitcoin) avec une prime de 1%.<br>
Il souhaite recevoir des euros via son compte Wise.<br>
Remarquez qu’il <strong>ne soumet pas</strong> son identifiant Wise — seulement un hash.<br>
Peach ne connaîtra donc jamais les détails de sa méthode de paiement, afin de préserver l’anonymat.<br>
Il soumet également une <strong>adresse de retour</strong>, utilisée en cas de remboursement.</p>
<h2 id="tape-4s-le-vendeur-alimente-lescrow-de-peach">Étape 4.S : le Vendeur alimente l’Escrow de Peach</h2>
<p>Après une requête réussie à l’API Peach pour créer l’offre de vente, le Vendeur reçoit l’ID de l’offre :</p>
<pre><code class="language-j">const sellOfferId = offerCreateRes.data.id;

</code></pre>
<p>Cet identifiant est important — conservez-le précieusement.<br>
L’offre est créée, mais elle n’est pas encore publique : aucun acheteur ne peut encore interagir avec elle.<br>
Le Vendeur doit d’abord alimenter l’Escrow.</p>
<p>L’Escrow agit comme un coffre-fort nécessitant <strong>l’autorisation du Vendeur et de Peach</strong> pour être ouvert.<br>
Les Bitcoins y sont placés et y restent en sécurité jusqu’à la fin de la transaction.<br>
Comme il s’agit d’un script sur la blockchain Bitcoin (une adresse P2WSH), Peach a besoin de la clé publique du Vendeur pour le créer.</p>
<p>À ce moment-là, le Vendeur soumet à Peach la clé publique qu’il souhaite utiliser pour l’Escrow.<br>
Peach choisit ensuite sa propre clé publique et construit l’adresse correspondante.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood04.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">const childSell = root.derivePath(`m/84'/0'/0'/${sellOfferId}'`);

  const keyPairSellOffer = ECPair.fromPrivateKey(childSell.privateKey, {
    network: bitcoin,
  });

  const sellOfferPublicKey = Buffer.from(keyPairSellOffer.publicKey).toString(
    &quot;hex&quot;
  );

  const escrowCreateRes = await session.post(
    &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;,
    {
      publicKey: sellOfferPublicKey,
    }
  );

  const escrowAddress = escrowCreateRes.data.escrows.bitcoin;

  const escrowPeachPublicKey =
    escrowCreateRes.data.escrowPeachPublicKey.bitcoin;

</code></pre>
<p>Comme montré dans le code, le Vendeur dérive une nouvelle paire de clés à partir de l’ID de l’offre.<br>
C’est une approche sûre, car elle est facilement reproductible.</p>
<p>Une fois la clé publique envoyée, l’API Peach renvoie l’adresse où le Vendeur doit envoyer les 21 000 sats.<br>
Mais inutile de faire aveuglément confiance — vous pouvez vérifier vous-même l’adresse.</p>
<p>Vérifions !</p>
<p>L’API Peach renvoie également la clé publique utilisée par Peach pour cet Escrow, ce qui nous permet de <strong>recréer l’adresse</strong> en construisant le script Bitcoin correspondant.</p>
<pre><code class="language-j">   OP_IF
       ${script.number.encode(4320).toString(&quot;hex&quot;)}
       OP_CHECKSEQUENCEVERIFY
       OP_DROP
   OP_ELSE
       ${sellerPublicKey}
       OP_CHECKSIGVERIFY
   OP_ENDIF
   ${peachPublicKey}
   OP_CHECKSIG
</code></pre>
<p>Voici le script utilisé pour l’Escrow :</p>
<ul>
<li>il nécessite toujours la signature de Peach</li>
<li>et ensuite :
<ul>
<li>soit la signature du Vendeur</li>
<li>soit que 4 320 blocs aient été minés depuis le dépôt des fonds</li>
</ul>
</li>
</ul>
<p>Pourquoi 4 320 blocs ?<br>
Parce que cela correspond à environ <strong>30 jours</strong> de minage (1 bloc toutes les 10 minutes).<br>
Pourquoi cette alternative permettant à Peach de signer seul après 1 mois ?<br>
Parce que certains Vendeurs peuvent être inactifs, perdre leurs clés, etc.</p>
<p>Peach a une réputation irréprochable pour la gestion des fonds des Vendeurs.</p>
<p>Une fois le script construit, vous pouvez vérifier l’adresse P2WSH qu’il génère — et constater qu’elle correspond bien à celle retournée par l’API Peach.</p>
<pre><code class="language-j">  const multisigScript = bitcoin.script.compile([
    Buffer.from(sellOfferPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIGVERIFY,
  ]);

  const timelockScript = bitcoin.script.compile([
    bitcoin.script.number.encode(4320),
    bitcoin.opcodes.OP_CHECKSEQUENCEVERIFY,
    bitcoin.opcodes.OP_DROP,
  ]);

  const redeemScript = bitcoin.script.compile([
    bitcoin.opcodes.OP_IF,
    ...timelockScript,
    bitcoin.opcodes.OP_ELSE,
    ...multisigScript,
    bitcoin.opcodes.OP_ENDIF,
    Buffer.from(escrowPeachPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIG,
  ]);

  const escrowPayment = bitcoin.payments.p2wsh({
    redeem: { output: redeemScript },
    network: bitcoin,
  });

  console.log(&quot;Addresses Match:&quot;, escrowPayment.address === escrowAddress);

</code></pre>
<p>Parfait !<br>
Il ne reste plus qu’à envoyer la transaction Bitcoin vers cette adresse et attendre la confirmation de financement de l’Escrow.</p>
<pre><code class="language-j">  while (true) {
    const fundingStatusRes = await session.get(
      &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;
    );
    if (fundingStatusRes.data.funding.status === &quot;FUNDED&quot;) {
      break;
    }
  }

</code></pre>
<p>Dès qu’elle est confirmée (après un bloc), l’offre devient publique, et les Acheteurs peuvent commencer à interagir avec elle.</p>
<h2 id="tape-5b-lacheteur-fait-une-demande-dchange">Étape 5.B : l’Acheteur fait une demande d’échange</h2>
<p>C’est maintenant au tour de l’Acheteur d’agir !</p>
<p>Commençons par consulter les offres de vente disponibles :</p>
<pre><code class="language-j">const sellOffers = await session.get(&quot;v069/sellOffer&quot;);
</code></pre>
<p>Pour simplifier, supposons que l’Acheteur s’intéresse à la première offre disponible.</p>
<pre><code class="language-j">const sellOfferToTradeRequestId = sellOffers.data.offers[0].id;
</code></pre>
<p>L’Acheteur souhaite alors faire une demande d’échange, pour informer le Vendeur qu’il est prêt à acheter selon ses conditions.<br>
Cela semble simple, non ? Mais c’est <strong>l’étape la plus complexe</strong> du processus.</p>
<p>L’Acheteur doit soumettre :</p>
<ul>
<li>la méthode de paiement souhaitée (parmi celles autorisées par le Vendeur)</li>
<li>la devise souhaitée</li>
<li>une clé symétrique (pour communiquer directement avec le Vendeur) — chiffrée</li>
<li>la signature de cette clé symétrique</li>
<li>les données de paiement chiffrées avec cette clé</li>
<li>la signature des données de paiement</li>
<li>l’adresse de réception du Bitcoin acheté</li>
<li>la preuve de possession de cette adresse (via BIP 322)</li>
<li>les frais de minage maximum que l’Acheteur est prêt à payer</li>
</ul>
<p>Ça fait beaucoup, n’est-ce pas ?<br>
Mais c’est exactement ce qui rend Peach extrêmement sûr !<br>
Voyons tout cela pas à pas.</p>
<h3 id="mthode-de-paiement-et-devise">Méthode de paiement et devise :</h3>
<p>C’est la partie la plus simple :</p>
<pre><code class="language-j">  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

</code></pre>
<h3 id="la-cl-symtrique">La clé symétrique :</h3>
<p>La clé symétrique sera utilisée pour un chiffrement bidirectionnel AES256 : vous pouvez chiffrer un message et le déchiffrer avec la même clé.</p>
<pre><code class="language-j">async function decryptDataWithSymmetricKey(encryptedMessage, symmetricKey) {
  const message = await openpgp.readMessage({
    armoredMessage: encryptedMessage,
  });

  const { data: decrypted } = await openpgp.decrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;utf8&quot;,
  });

  return decrypted;
}

async function encryptDataWithSymmetricKey(data, symmetricKey) {
  const message = await openpgp.createMessage({ text: data });
  const encrypted = await openpgp.encrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;armored&quot;,
    config: {
      preferredSymmetricAlgorithm: openpgp.enums.symmetric.aes256,
    },
  });
  return encrypted;
}

</code></pre>
<p>Pour en créer une, générez simplement un nombre aléatoire :</p>
<pre><code class="language-j">  const symmetricKey = randomBytes(32);
  const symmetricKeyHex = symmetricKey.toString(&quot;hex&quot;);

</code></pre>
<p>Mais attention : vous ne pouvez pas envoyer cette clé en clair.<br>
Elle doit être chiffrée de manière à ce que seuls l’Acheteur et le Vendeur puissent la déchiffrer.<br>
Puisque les deux ont soumis leurs clés publiques PGP, il faut la chiffrer de manière à ce qu’elle ne puisse être déchiffrée qu’avec <strong>l’une des clés privées correspondantes</strong>.</p>
<pre><code class="language-j">async function encryptForMultipleRecipients(secret, publicKeysArmored) {
  const publicKeys = await Promise.all(
    publicKeysArmored.map((armored) =&gt; openpgp.readKey({ armoredKey: armored }))
  );
  const message = await openpgp.createMessage({ text: secret });

  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: publicKeys,
  });

  return encrypted;
}

  const matchingUserPgpPubKey = sellOffers.data.offers[0].user.pgpPublicKey;

  const symmetricKeyEncrypted = await encryptForMultipleRecipients(
    symmetricKeyHex,
    [pgpPublicKey, matchingUserPgpPubKey]
  );

</code></pre>
<p>Et pour que le Vendeur sache que la clé vient bien de l’Acheteur, celui-ci doit la signer avec sa clé PGP :</p>
<pre><code class="language-j">  const symmetricKeySignature = await signPGPMessage(
    pgpPrivateKey,
    symmetricKeyHex
  );

</code></pre>
<h3 id="les-donnes-de-paiement">Les données de paiement :</h3>
<p>C’est la partie la plus sensible : vos données de paiement — IBAN, identifiant Revolut, etc.<br>
Elles permettent d’identifier la provenance du paiement fiat.<br>
Le Vendeur partagera ensuite les siennes.</p>
<p>Maintenant que nous avons la clé symétrique, nous pouvons l’utiliser pour <strong>chiffrer les données de paiement</strong>, que le Vendeur pourra déchiffrer plus tard.</p>
<pre><code class="language-j">const paymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@buyerWiseId&quot;,
  });

const paymentDataEncrypted = await encryptDataWithSymmetricKey(
paymentDataToEncrypt,
symmetricKeyHex
);

const paymentDataSignature = await signPGPMessage(
pgpPrivateKey,
paymentDataToEncrypt
);

</code></pre>
<h3 id="dfinir-ladresse-de-rception-et-prouver-la-proprit">Définir l’adresse de réception et prouver la propriété :</h3>
<p>Vous devez indiquer où vous souhaitez recevoir les Bitcoins achetés.<br>
Créer une adresse est facile, mais <strong>prouver que vous en êtes le propriétaire</strong> est plus subtil.<br>
C’est à la fois une exigence de conformité et une mesure de sécurité supplémentaire (ce qui rend Peach résistant à l’attaque de remplacement d’adresse découverte en septembre 2025).</p>
<p>La preuve de propriété se fait via <strong>BIP-322</strong>, qui permet de signer un message avec votre clé privée Bitcoin, puis de le vérifier à partir de l’adresse.</p>
<pre><code class="language-j">  const { address } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });

  const ownershipMessage =
    &quot;I confirm that only I, peach&quot; +
    publicKeyHex.slice(0, 8) +
    &quot;, control the address &quot; +
    address;

  const releaseAddressSignature = signWithBIP322(
    wif,
    address,
    ownershipMessage
  );

</code></pre>
<h3 id="dernier-dtail-les-frais-de-minage-maximum">Dernier détail : les frais de minage maximum</h3>
<p>En tant qu’Acheteur, vous pouvez ne pas vouloir payer trop de frais pour recevoir votre Bitcoin.<br>
Dans ce cas, vous pouvez définir le <strong>frais de minage maximum</strong> que vous êtes prêt à « céder » pour la transaction finale.</p>
<h3 id="enfin-soumettre-la-demande-dchange">Enfin, soumettre la demande d’échange</h3>
<p>Quelle aventure, non ? Mais nous y voilà, et vous pouvez maintenant soumettre la demande.</p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; + sellOfferToTradeRequestId + &quot;/tradeRequestPerformed&quot;,
    {
      paymentMethod: payment_data_method,
      currency: payment_data_currency,
      paymentDataHashed: paymentDataToEncryptSHA256,
      paymentDataEncrypted: paymentDataEncrypted,
      paymentDataSignature: paymentDataSignature,
      symmetricKeyEncrypted: symmetricKeyEncrypted,
      symmetricKeySignature: symmetricKeySignature,
      maxMiningFeeRate: 2, // sats/vb
      releaseAddress: address,
      releaseAddressMessageSignature: releaseAddressSignature,
    }
  );

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood05.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>C’est maintenant au Vendeur de jouer.</p>
<h2 id="tape-5s-le-vendeur-accepte-la-demande-dchange">Étape 5.S : le Vendeur accepte la demande d’échange</h2>
<p>Le Vendeur a attendu qu’un Acheteur interagisse avec son offre.<br>
Il consulte la liste des demandes d’échange :</p>
<pre><code class="language-j">const receivedTradeRequestRequest = await session.get(
    &quot;v069/sellOffer/&quot; + sellOfferId + &quot;/tradeRequestReceived&quot;
  );

  const tradeReq = receivedTradeRequestRequest.data[0];

</code></pre>
<p>S’il souhaite en accepter une, il doit partager <strong>ses propres données de paiement</strong> avec l’Acheteur, pour que celui-ci sache où envoyer le paiement fiat.</p>
<p>Puisqu’une clé symétrique a déjà été créée et envoyée par l’Acheteur, le Vendeur peut la déchiffrer (elle a été chiffrée avec sa clé publique PGP) et l’utiliser pour chiffrer ses propres données de paiement.</p>
<pre><code class="language-j">  const receivedSymmetricKey = await decryptWithPrivateKey(
    tradeReq.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  const sellOfferPaymentDataEncrypted = await encryptDataWithSymmetricKey(
    sellOfferPaymentDataToEncrypt,
    receivedSymmetricKey
  );

  const sellOfferPaymentDataSignature = await signPGPMessage(
    pgpPrivateKey,
    sellOfferPaymentDataToEncrypt
  );

</code></pre>
<p>Et voilà ! Le Vendeur peut maintenant accepter la demande, et l’échange officiel commence !</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood06.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; +
      sellOfferId +
      &quot;/tradeRequestReceived/&quot; +
      tradeReq.userId +
      &quot;/accept&quot;,
    {
      paymentDataEncrypted: sellOfferPaymentDataEncrypted,
      paymentDataSignature: sellOfferPaymentDataSignature,
      paymentData: {
        [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
      },
    }
  );

</code></pre>
<p>Si tout cela semble complexe, voici un schéma pour l’illustrer :</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood07.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 90%;">
<br><br></p>
<h2 id="tape-6b-lacheteur-dclare-que-le-paiement-a-t-effectu">Étape 6.B : l’Acheteur déclare que le paiement a été effectué</h2>
<p>L’Acheteur peut vérifier s’il a des <strong>contrats actifs</strong> (des échanges acceptés par les deux parties) via l’endpoint <code>contract summaries</code> de l’API :</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data.find((obj) =&gt;
    obj.id.startsWith(sellOfferToTradeRequestId + &quot;-&quot;)
  );

  if (contract.tradeStatus !== &quot;paymentRequired&quot;) throw Error;
</code></pre>
<p>Cela lui renverra la liste de tous les contrats où il est impliqué.<br>
Si un contrat a le statut <strong>“paymentRequired”</strong>, cela signifie que c’est à lui d’effectuer le paiement fiat.</p>
<p>Pour cela, il doit <strong>déchiffrer les données de paiement du Vendeur</strong> à l’aide de la clé symétrique utilisée lors de la demande d’échange.<br>
S’il ne l’a pas sauvegardée, pas de souci — il peut la déchiffrer avec sa clé privée PGP.</p>
<pre><code class="language-j">
  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

  const receivedSymmetricKey = await decryptWithPrivateKey(
    contractRes.data.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  if (receivedSymmetricKey !== symmetricKeyHex) throw Error;

  const decryptedSellerPaymentData = await decryptDataWithSymmetricKey(
    contractRes.data.paymentDataEncrypted,
    receivedSymmetricKey
  );

  console.log(&quot;Seller Payment Data &quot;, JSON.parse(decryptedSellerPaymentData));
</code></pre>
<p>Cette étape se déroule en dehors de Peach :<br>
l’Acheteur ouvre son application bancaire (ou équivalent) et effectue le virement fiat au bénéficiaire indiqué.</p>
<p>Si vous hésitez à ce stade, rappelez-vous que les Bitcoins sont déjà dans l’Escrow, contrôlé conjointement par Peach et le Vendeur.<br>
Vous pouvez même consulter l’adresse de l’Escrow (fournie par l’API du contrat) et vérifier sur la blockchain que les fonds s’y trouvent.</p>
<p>Une fois le paiement fiat effectué, l’Acheteur doit le déclarer :</p>
<pre><code class="language-j">  const confirmPaymentRes = await session.post(
    &quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;
  );
</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood08.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>C’était la dernière étape pour l’Acheteur.<br>
Désormais, le Vendeur doit confirmer qu’il a bien reçu le paiement et libérer les Bitcoins dans l’Escrow vers l’adresse de l’Acheteur.</p>
<h2 id="tape-6s-le-vendeur-confirme-la-rception-du-paiement">Étape 6.S : le Vendeur confirme la réception du paiement</h2>
<p>Comme pour l’Acheteur, le Vendeur consulte les contrats qui lui sont assignés.</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data[0];

  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

</code></pre>
<p>Dans la réponse de l’API du contrat, le Vendeur reçoit une <strong>transaction Bitcoin partiellement signée (PSBT)</strong>.<br>
Il s’agit de la transaction de transfert des Bitcoins de l’Escrow vers l’adresse de l’Acheteur, déjà signée par Peach.<br>
Elle n’a besoin que de la signature du Vendeur pour devenir valide.</p>
<pre><code class="language-j">  const releasePSBTBase64 = contractRes.data.releasePsbt;

  const parsedPSBT = bitcoin.Psbt.fromBase64(releasePSBTBase64, {
    network: bitcoin,
  });

  parsedPSBT.signInput(0, childSell);

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood09.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Le Vendeur peut alors finaliser la transaction, en ajoutant les deux signatures et le script de l’Escrow.<br>
Comme nous passons par le chemin <strong>MultiSig</strong> du script (le second), il faut ajouter <code>OP_FALSE</code> dans la pile afin que la condition IF soit correctement évaluée.</p>
<pre><code class="language-j">export const getFinalScript = (_inputIndex, input, bitcoinScript) =&gt; {
  const network = bitcoin;

  const payment = payments.p2wsh({
    network,
    redeem: {
      network,
      output: bitcoinScript,
      input: bitcoin.script.compile([
        input.partialSig[0].signature,
        input.partialSig[1].signature,
        opcodes.OP_FALSE,
      ]),
    },
  });

  parsedPSBT.finalizeInput(0, getFinalScript);

  const tx = parsedPSBT.extractTransaction().toHex();

</code></pre>
<p>Dernière étape : soumettre la transaction finalisée à l’API de Peach :</p>
<pre><code class="language-j">  await session.post(&quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;, {
    releaseTransaction: tx,
  });

</code></pre>
<p>Mesdames et Messieurs, voici comment nous échangeons sur Peach avec <strong>un maximum de sécurité et de confidentialité !</strong></p>
<p class="date">October 23rd, 2025</p><p class="tags">Tagged with:<a href="/fr/blog/tag/produit">Produit</a><a href="/fr/blog/tag/p2p">P2P</a><a href="/fr/blog/tag/tutoriel">Tutoriel</a></p><p><a href="/fr/blog/">All blog posts</a></p></div></section></main><footer class="footer" id="footer"><div class="wrap"><div class="logo-section"><div class="logo"><img class="logo-image" src="/img/peach-footer-logo-e28fd7e07f654f43afd63c9b6ace3cdb.svg" alt="Peach logo"/><span>Made in Switzerland <img src="/img/flags/switzerland-icon.svg" style="width: 1rem; margin-left .5rem;"/></span></div><div class="company-info"> <img class="polyreg-image" src="/img/polyreg-52ec37fb80d0312b219110c05567ad3d.png" alt="Polyreg logo" width="120"/><p>Peach est membre de la SRO (Organisation d'Autorégulation) de Polyreg </p><p>Peach est un prestataire de services financiers agréé en Suisse et est entièrement conforme à la Loi Suisse sur le Blanchiment d'Argent. </p></div></div><div class="content"><div class="footer-box"><h6>Entreprise</h6><a href="/fr/join-us/">Rejoignez-nous</a><a href="/fr/terms-and-conditions/">Termes et Conditions</a><a href="/fr/privacy-policy/">Politique de Confidentialité</a><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Gérer les préférences de cookies</a></div><div class="footer-box"><h6>Contact</h6><a href="mailto:hello@peachbitcoin.com">Email</a><a href="https://keys.openpgp.org/vks/v1/by-fingerprint/48339A19645E2E53488E0E5479E1B270FACD1BD2">Clé PGP</a></div><div class="footer-box"><h6>Télécharger</h6><span>0.69.0 (306)</span><a href="/fr/apk/">APK</a><a href="https://testflight.apple.com/join/wfSPFEWG">iPhone</a><a href="https://play.google.com/store/apps/details?id=com.peachbitcoin.peach.mainnet">Android</a></div><div class="footer-box"><h6>Communauté</h6><a href="https://twitter.com/peachbitcoin" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://t.me/peachtopeach" target="_blank" rel="noreferrer noopener">Telegram</a><a href="https://discord.gg/ypeHz3SW54" target="_blank" rel="noreferrer noopener">Discord</a><a href="https://www.instagram.com/peachbitcoin/" target="_blank" rel="noreferrer noopener">Instagram</a><a href="https://snort.social/p/npub15369wu3wzzar5fclhecyqfv683x69n6nhlg7rxqnsg2dydgxflpq3apswl" target="_blank" rel="noreferrer noopener">Nostr</a><a href="https://github.com/Peach2Peach" target="_blank" rel="noreferrer noopener">Github</a><a href="https://www.youtube.com/@peachbitcoin" target="_blank" rel="noreferrer noopener">YouTube</a></div><div class="footer-box"><h6>Bitcoin</h6><a href="/bitcoin.pdf">Livre Blanc</a><a href="https://docs.peachbitcoin.com">Documentation API</a></div><div class="footer-box"><h6>Gagner des Bitcoins</h6><a href="/fr/new-users/">Code de Parrainage</a><a href="/fr/for-businesses/">Devenir Affilié</a></div></div></div></footer><style>#cookie-banner {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: #120A07;
  color: #fff;
  padding: 15px 0;
  z-index: 9999;
  font-size: 14px;
}
#cookie-banner .cookie-container {
  width: 90%;
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
}
#cookie-banner p {
  margin: 0;
  line-height: 1.4;
}
#cookie-banner .cookie-actions {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}
#cookie-banner button {
  padding: 10px 16px;
  color: #fff;
  background-color: #65A519;
  border: none;
  cursor: pointer;
  border-radius: 4px;
  font-size: 14px;
  transition: background-color 0.3s ease;
}
#cookie-banner button:hover {
  background-color: #65A519;
}
#cookie-banner button.reject {
  background-color: #DF321F;
}
#cookie-banner button.reject:hover {
  background-color: #DF321F;
}
#cookie-banner a.cookie-link {
  color: #fff;
  text-decoration: underline;
  font-size: 14px;
  margin-left: 8px;
  cursor: pointer;
}
#cookie-banner a.cookie-link:hover {
  text-decoration: none;
}
/* Popup overlay */
#cookie-popup {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  z-index: 10000;
  justify-content: center;
  align-items: center;
  color: #fff;
}
/* Contenitore del popup */
#cookie-popup-content {
  position: relative;
  background-color: #120A07;
  color:rgb(255, 255, 255);
  padding: 30px 20px 20px;
  border-radius: 10px;
  width: 80%;
  max-width: 600px;
  box-sizing: border-box;
}
/* Pulsante di chiusura */
#cookie-popup-content .close-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  color: #fff;
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  padding: 0 5px;
}
#cookie-popup-content .close-btn:hover {
  color: #ccc;
}
/* Stile per ciascuna categoria di cookie */
.cookie-category {
  margin-bottom: 20px;
}
/* Migliora i checkbox e le label */
.cookie-category label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 15px;
}
.cookie-category input[type="checkbox"] {
  accent-color: #4CAF50;
  margin: 0;
  cursor: pointer;
}
.cookie-category p {
  margin: 4px 0 0 28px;
  font-size: 14px;
  line-height: 1.4;
  color: #ccc;
}
/* Bottone "Salva Preferenze" */
#cookie-popup-content button.save-btn {
  background-color: #4CAF50;
  border: none;
  padding: 10px 16px;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}
#cookie-popup-content button.save-btn:hover {
  background-color: #43a047;
}
/* Media query per schermi più piccoli */
@media (max-width: 768px) {
  #cookie-banner .cookie-container {
    flex-direction: column;
    align-items: flex-start;
  }
  #cookie-banner .cookie-actions {
    margin-top: 10px;
    width: 100%;
    justify-content: flex-start;
    gap: 8px;
    flex-wrap: wrap;
  }
}

</style><div id="cookie-banner" style="display: none;"><div class="cookie-container"><p>Nous utilisons des cookies pour améliorer votre expérience. <a href="/privacy-policy" style="color: #4CAF50;">En savoir plus</a></p><div class="cookie-actions"><button class="cookie-btn" onclick="acceptCookies()">Accepter les cookies &amp; Continuer</button><button class="cookie-btn reject" onclick="rejectCookies()">Refuser les cookies</button><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Gérer les cookies</a></div></div></div><div id="cookie-popup"><div id="cookie-popup-content"><button class="close-btn" type="button" onclick="closeCookiePopup()">×</button><h2>Gérer les préférences de cookies</h2><div class="cookie-category"><div class="switch-container"><span class="label-text">Cookies nécessaires</span><label class="switch" for="necessary-cookies"><input type="checkbox" id="necessary-cookies" checked="checked" disabled="disabled"/><span class="slider"></span></label></div><p>Ces cookies sont essentiels au fonctionnement du site.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Cookies d'analyse</span><label class="switch" for="analytics-cookies"><input type="checkbox" id="analytics-cookies"/><span class="slider"></span></label></div><p>Les cookies d'analyse nous aident à comprendre comment les utilisateurs interagissent avec le site.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Cookies de marketing</span><label class="switch" for="marketing-cookies"><input type="checkbox" id="marketing-cookies"/><span class="slider"></span></label></div><p>Les cookies de marketing sont utilisés pour collecter des informations sur les utilisateurs</p></div><div style="text-align: right; margin-top: 20px;"><button class="save-btn" type="button" onclick="savePreferences()">Enregistrer les préférences</button></div></div></div><script src="/js/main-15c0432b5e5f06cbab9e3fedcaae3032.js"></script><script>if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/service-worker.js')
      .then(function(registration) {
        console.log('Service Worker registrato con successo:', registration);
      })
      .catch(function(error) {
        console.log('Registrazione del Service Worker fallita:', error);
      });
  });
} else {
  console.log('Service Worker non supportato in questo browser.');
}
</script><script>document.addEventListener('DOMContentLoaded', function () {
  // Map of language codes to display names
  const languageMap = {
    en: 'English',
    es: 'Español',
    de: 'Deutsch',
    it: 'Italiano',
    fr: 'Français',
    el: 'Ελληνικά',
    hu: 'Magyar',
    nl: 'Nederlands',
    pl: 'Polski',
    pt: 'Português',
    sw: 'Kiswahili',
    uk: 'Українська'
  };

  // Detect current lang from path
  const path = window.location.pathname.replace(/\/+$/, ''); // trim trailing slash
  let currentLang = 'en';
  for (const code in languageMap) {
    if (path === '/' && code === 'en') { currentLang = 'en'; break; }
    if (path === `/${code}` || path.startsWith(`/${code}/`)) { currentLang = code; break; }
  }

  const label = document.querySelector('.language-label');
  if (!label) return;

  // Ensure there is a span.language-text, create it if missing
  let textNode = label.querySelector('.language-text');
  if (!textNode) {
    textNode = document.createElement('span');
    textNode.className = 'language-text';
    // insert before the dropdown chevron if present
    // const chevron = Array.from(label.querySelectorAll('img')).find(img => /dropdown_icon\.svg(\?.*)?$/i.test(img.getAttribute('src') || ''));
    label.insertBefore(textNode, chevron || null);
  }

  // Set the text
  textNode.textContent = languageMap[currentLang] || currentLang.toUpperCase();

  // Remove any flag images inside the label (keep the chevron)
  //- Array.from(label.querySelectorAll('img')).forEach(img => {
  //-   const src = img.getAttribute('src') || '';
  //-   const isChevron = /dropdown_icon\.svg(\?.*)?$/i.test(src);
  //-   if (!isChevron) {
  //-     img.remove();
  //-   }
  //- });

  // Also nuke any pseudo-element flags applied via CSS (belt & suspenders)
  label.style.backgroundImage = 'none';
});

</script><script>window.__ow = window.__ow || {};
window.__ow.organizationId = "8b099b27-4836-4896-9087-a7ed505dec79";
window.__ow.template_id = "b97be07a-7dcf-48af-8d69-a9dfae5dfc29";
window.__ow.integration_name = "manual_settings";
window.__ow.product_name = "chatbot";   
;(function(n,t,c){function i(n){return e._h?e._h.apply(null,n):e._q.push(n)}var e={_q:[],_h:null,_v:"2.0",on:function(){i(["on",c.call(arguments)])},once:function(){i(["once",c.call(arguments)])},off:function(){i(["off",c.call(arguments)])},get:function(){if(!e._h)throw new Error("[OpenWidget] You can't use getters before load.");return i(["get",c.call(arguments)])},call:function(){i(["call",c.call(arguments)])},init:function(){var n=t.createElement("script");n.async=!0,n.type="text/javascript",n.src="https://cdn.openwidget.com/openwidget.js",t.head.appendChild(n)}};!n.__ow.asyncInit&&e.init(),n.OpenWidget=n.OpenWidget||e}(window,document,[].slice))</script><noscript>You need to <a href="https://www.chatbot.com/help/chat-widget/enable-javascript-in-your-browser/" rel="noopener nofollow">enable JavaScript</a> in order to use the AI chatbot tool powered by <a href="https://www.chatbot.com/" rel="noopener nofollow" target="_blank">ChatBot</a></noscript><script>(function() {
  // Funzioni di utilità per gestire i cookie
  function setCookie(name, value, days) {
    var expires = "";
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
      expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "") + expires + "; path=/";
  }

  function getCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  }

  // Controlla se il consenso è già stato dato per nascondere il banner
  function checkConsent() {
    if (getCookie('consent_necessary') === "true") {
      document.getElementById('cookie-banner').style.display = 'none';
    } else {
      document.getElementById('cookie-banner').style.display = 'flex';
    }
  }

  // Funzione per accettare tutti i cookie
  window.acceptCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'true', 365);
    setCookie('consent_marketing', 'true', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: true, consent_marketing: true});
  };

  // Funzione per rifiutare cookie opzionali (analytics e marketing)
  window.rejectCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'false', 365);
    setCookie('consent_marketing', 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: false, consent_marketing: false});
  };

  // Mostra il popup per gestire le preferenze dei cookie
  window.showCookiePopup = function(event) {
    event.preventDefault();
    document.getElementById('cookie-popup').style.display = 'flex';
  };
  window.closeCookiePopup = function() {
  document.getElementById('cookie-popup').style.display = 'none';
  };

  // Salva le preferenze impostate nel popup
  window.savePreferences = function() {
    var analyticsConsent = document.getElementById('analytics-cookies').checked;
    var marketingConsent = document.getElementById('marketing-cookies').checked;
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', analyticsConsent ? 'true' : 'false', 365);
    setCookie('consent_marketing', marketingConsent ? 'true' : 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: analyticsConsent, consent_marketing: marketingConsent});
  };

  // Inizializza il controllo del consenso al caricamento della pagina
  checkConsent();
})();</script></body></html>