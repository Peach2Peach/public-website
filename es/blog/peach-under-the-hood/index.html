<!DOCTYPE html><html lang="es"><head><meta charset="UTF-8"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><meta http-equiv="X-Frame-Options" content="DENY"/><meta http-equiv="X-XSS-Protection" content="1; mode=block"/><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/><meta name="keywords" content="[&quot;Producto&quot;,&quot;P2P&quot;,&quot;tutorial&quot;,&quot;programación&quot;,&quot;javascript&quot;,&quot;bitcoin&quot;]"/><meta name="description" content="Aaaaah Bitcoin, esta maravillosa forma de dinero que prospera gracias a sus características esenciales. Todos la amamos, pero también reconocemos que existen riesgos en la parte de la soberanía propia: compartes tus semillas y lo pierdes todo. Envías algo a la dirección equivocada y nunca lo recuperarás."/><meta property="og:locale" content="es"/><meta property="og:site_name"/><meta property="og:title" content="Peach Bitcoin Exchange - Buy and Sell Bitcoin Anonymously and Without KYC"/><meta property="og:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta property="og:type" content="website"/><meta property="og:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:secure_url" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta property="og:image:width" content="1296"/><meta property="og:image:height" content="678"/><meta name="twitter:site" content="@peachbitcoin"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Peach Bitcoin bajo el capó: una mirada técnica a por qué es el intercambio P2P más seguro · Peach Bitcoin"/><meta name="twitter:description" content="Peach Bitcoin - Buy Bitcoin with gift card, no verification. Exchange peer to peer for anonymous transactions. Learn how to buy and sell Bitcoin privately and  without KYC. Manage your Bitcoin securely with our non-KYC platform."/><meta name="twitter:image" content="/img/blog/under-the-hood/peachmechanic2.png"/><meta name="msapplication-TileColor" content="#F56522"/><meta name="cf-2fa-verify" content="e22767e30dc139c"/><meta name="theme-color" content="#F56522"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-regular.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-600.woff2"/><link rel="preload" as="font" crossorigin="crossorigin" href="/fonts/baloo-2-v16-latin-800.woff2"/><link rel="apple-touch-icon" href="/img/favicon/apple-touch-icon.png"/><link rel="icon" href="/img/favicon/favicon.svg"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/img/favicon/safari-pinned-tab.svg" color="#F56522"/><link rel="stylesheet" href="/css/main-fadd3e7623af117338aa3005f4c1cd65.css"/><title>Peach Bitcoin bajo el capó: una mirada técnica a por qué es el intercambio P2P más seguro · Peach Bitcoin</title><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KQHJRQKH');</script></head><body id="blog-peach-under-the-hood"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KQHJRQKH" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><header class="header header-container" id="header"><div class="wrap"><a class="logo-link brand" href="/es/"><img class="logo logo" src="/img/peach-bitcoin-145cd6c0079ccacc9c70c892060964d1.svg" alt="Peach Bitcoin"/></a><input id="show-menu" type="checkbox"/><label class="nav-toggle-label" id="nav-toggle" for="show-menu"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path class="line--1" d="M0 70l28-28c2-2 2-2 7-2h64"></path><path class="line--2" d="M0 50h99"></path><path class="line--3" d="M0 30l28 28c2 2 2 2 7 2h64"></path></svg></label><nav class="nav"><a href="/es/how-it-works/">Compra BTC sin KYC</a><a href="/es/for-meetups/">Compra BTC con efectivo</a><a href="/es/for-businesses/">Vende BTC</a><a href="/es/blog/">Blog</a><a href="/es/support/">Soporte</a><div class="language-selector"><input class="checkbox" type="checkbox" id="language-toggle"/><label class="language-label" for="language-toggle"><span class="language-text">Español</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="white" style="margin-left: .25rem;"><path d="M7 10l5 5 5-5z"></path></svg></label><ul class="language-dropdown"><li><a href="/"> <span>English</span></a></li><li><a href="/es"> <span>Español</span></a></li><li><a href="/de"> <span>Deutsch</span></a></li><li><a href="/it"> <span>Italiano</span></a></li><li><a href="/fr"> <span>Français</span></a></li><li><a href="/pt"> <span>Português</span></a></li></ul></div></nav></div></header><main class="main" id="main"><div id="header-anchor"></div><section class="wrap"><div class="content-wrap post"><h1 id="peach-bitcoin-bajo-el-cap-una-mirada-tcnica-a-por-qu-es-el-intercambio-p2p-ms-seguro">Peach Bitcoin bajo el capó: una mirada técnica a por qué es el intercambio P2P más seguro</h1>
<div class="video-wrapper">
  <iframe
    src="https://www.youtube.com/embed/UvdbHlsPmK0"
    title="PEACH VIDEO OF Under the Hood"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  ></iframe>
</div>
<p>Aaaaah Bitcoin, esta maravillosa forma de dinero que prospera gracias a sus características esenciales. Todos la amamos, pero también reconocemos que existen riesgos en la parte de la soberanía propia: compartes tus semillas y lo pierdes todo. Envías algo a la dirección equivocada y nunca lo recuperarás.</p>
<p>Por eso es tan importante que el software relacionado con Bitcoin sea de código abierto, ¡y la App de Peach está disponible en Github para que cualquiera la revise!</p>
<p>Por supuesto, que sea de código abierto no significa que todo el mundo vaya a leer cuidadosamente el código y hacer ingeniería inversa del mecanismo. Por eso escribo este artículo: para <strong>mostrar cuán segura es Peach</strong> y cuáles son los pasos realizados para lograrlo.</p>
<h2 id="paso-1-crear-una-cuenta-sin-kyc-en-peach">Paso 1: crear una cuenta sin KYC en Peach</h2>
<p>Para dejarlo muy claro: tu Bitcoin Seed es tu cuenta de Peach.</p>
<p>Si quieres usar Peach, necesitas crear una cuenta, y eso consiste en compartir la Clave Pública de tu cuenta y demostrar que eres su propietario.</p>
<p>Para hacerlo, debes:</p>
<ul>
<li>
<p>1 - obtener la fecha y hora actuales (en milisegundos) como texto</p>
</li>
<li>
<p>2 - usar tu Clave Privada para generar una firma del texto anterior</p>
</li>
<li>
<p>3 - enviar la Clave Pública, la fecha y hora actuales, y la firma.</p>
</li>
</ul>
<p>También necesitas generar un uniqueId (identificador único) que se usará para evitar que otros usuarios finjan ser tú. Esto es útil en casos como la pérdida de las semillas y mantener la misma cuenta. Pero no nos enfoquemos demasiado en eso.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood01.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<p>Aquí está el código para realizar esto en Javascript:</p>
<pre><code class="language-j">
  const seed = randomBytes(64);

  const root = bip32.fromSeed(seed, bitcoin);
  const child = root.derivePath(&quot;m/0&quot;);
  const keyPair = ECPair.fromPrivateKey(child.privateKey, { network: bitcoin });

  const publicKeyHex = Buffer.from(keyPair.publicKey).toString(&quot;hex&quot;);

  const session = axios.create({
    baseURL: &quot;https://api.peachbitcoin.com/&quot;,
    httpAgent: new http.Agent({ keepAlive: false }),
    httpsAgent: new https.Agent({ keepAlive: false }),
  });

  const registerMessage = String(Date.now());
  const registerMessageSignature = signWithBtcPrivKey(registerMessage, keyPair);

  const resp = await session.post(&quot;v1/user/register&quot;, {
    publicKey: publicKeyHex,
    message: registerMessage,
    signature: registerMessageSignature,
    uniqueId: &quot;my_own_unique_id_random_12345&quot;,
  });

  const accessToken = resp.data.accessToken;

  session.defaults.headers.common[&quot;authorization&quot;] = accessToken;

</code></pre>
<p>¡Felicidades! Acabas de crear una cuenta en Peach. El servidor ha validado que, en este momento, eres el propietario del Par de Claves Bitcoin correspondiente a la Clave Pública enviada.</p>
<h2 id="paso-2-enviar-tu-clave-pblica-pgp">Paso 2: enviar tu Clave Pública PGP</h2>
<p>Habrá mucha encriptación, pero también algo de desencriptación. Las Claves Bitcoin solo permiten encriptación unidireccional, por lo que necesitaremos Claves PGP para realizar encriptación bidireccional. Esto es fundamental para cifrar y descifrar datos bancarios, mensajes de chat, etc.</p>
<p>Enviar la Clave Pública PGP es similar al proceso de enviar la Clave Pública Bitcoin. Sin embargo, hay un paso adicional: firmar la Clave Pública PGP con la Clave Privada Bitcoin, para verificar doblemente que el usuario es propietario de ambas claves, la Bitcoin y la PGP.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood02.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 70%;">
<br><br></p>
<pre><code class="language-j">
const { privateKey: pgpPrivateKey, publicKey: pgpPublicKey } =
    await createPGPKey();

  const pgpPublicKeyMessageSignature = signWithBtcPrivKey(
    pgpPublicKey,
    keyPair
  );
  const setPgpKeysMessage = String(Date.now());

  const setPgpKeysMessageSignature = await signPGPMessage(
    pgpPrivateKey,
    setPgpKeysMessage
  );

  await session.patch(&quot;v1/user&quot;, {
    pgpPublicKey: pgpPublicKey, // the PGP Pub key
    signature: pgpPublicKeyMessageSignature, // the above signed by the BTC Key
    message: setPgpKeysMessage, // the current timestamp
    pgpSignature: setPgpKeysMessageSignature, // the above signed by the PGP Key
  });

</code></pre>
<p>En este momento, ¡Peach tiene tus Claves Públicas Bitcoin y PGP! Esto será extremadamente relevante para comerciar en Peach.</p>
<h2 id="prximos-pasos">Próximos pasos</h2>
<p>A partir de aquí, el tutorial mostrará ambos lados: el del Comprador y el del Vendedor.</p>
<p>Los pasos serán los siguientes:</p>
<ul>
<li>
<p>3.S El Vendedor crea una Oferta de Venta</p>
</li>
<li>
<p>4.S El Vendedor financia el Escrow de Peach</p>
</li>
<li>
<p>5.B El Comprador realiza una Solicitud de Comercio a la Oferta de Venta</p>
</li>
<li>
<p>5.S El Vendedor acepta la Solicitud de Comercio del Comprador</p>
</li>
<li>
<p>6.B El Comprador declara que la transferencia Fiat ha sido realizada</p>
</li>
<li>
<p>6.S El Vendedor confirma que ha recibido el Pago</p>
</li>
</ul>
<h2 id="paso-3s-el-vendedor-crea-una-oferta-de-venta">Paso 3.S: el Vendedor crea una Oferta de Venta</h2>
<p>Crear una Oferta de Venta equivale a anunciar que estás dispuesto a vender una cantidad específica de Bitcoin. Pero eso no es todo: el Vendedor debe aceptar algo a cambio. En resumen, una Oferta de Venta es:</p>
<ul>
<li>
<p>una cantidad de Bitcoin a vender</p>
</li>
<li>
<p>las Monedas que el Vendedor acepta</p>
</li>
<li>
<p>los Métodos de Pago que el Vendedor acepta (efectivo, Transferencia Bancaria, una transacción de Revolut, etc.)</p>
</li>
<li>
<p>la Prima (qué tan caro es el Bitcoin respecto al valor de mercado actual)</p>
</li>
</ul>
<p>Si todo va bien, un Comprador se interesará en la oferta y solicitará comerciar con ella. En ese momento, tendrá que seleccionar una sola Moneda y un solo Método de Pago de entre los disponibles, pero mientras más opciones muestre el Vendedor, mayores serán sus posibilidades de atraer a un Comprador.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood03.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">
const sats_to_sell = 21000;
  const sell_premium = 1; // 1%
  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

  const { address: returnAddress } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });
  const sellOfferPaymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@myWiseIdTradingBot&quot;,
  });

  const paymentDataEncryptSHA256 = await sha256(sellOfferPaymentDataToEncrypt);

  const offerCreateRes = await session.post(&quot;v1/offer&quot;, {
    type: &quot;ask&quot;,
    amount: sats_to_sell,
    meansOfPayment: { [payment_data_currency]: [payment_data_method] }, // {&quot;EUR&quot;: [&quot;wise&quot;]}
    paymentData: {
      [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
    },
    returnAddress: returnAddress,
    premium: sell_premium,
  });

</code></pre>
<p>Como puedes ver en el código, el Vendedor está anunciando que vende 21,000 sats (0.00021 Bitcoin) con una prima del 1%. Quiere recibir Euros a través de su cuenta Wise.<br>
Si prestas atención, NO está enviando su ID de cuenta Wise, solo está enviando un Hash. Peach nunca conocerá los Detalles del Método de Pago, para mantener el anonimato.<br>
También se envía una Dirección de Retorno. Esto se usa en caso de reembolso: si ningún Comprador quiere tu Bitcoin, puedes recuperarlo.</p>
<h2 id="paso-4s-el-vendedor-financia-el-escrow-de-peach">Paso 4.S: el Vendedor financia el Escrow de Peach</h2>
<p>Después de una solicitud exitosa a la API de Peach para crear la Oferta de Venta, el Vendedor obtiene el ID de la Oferta de Venta:</p>
<pre><code class="language-j">const sellOfferId = offerCreateRes.data.id;

</code></pre>
<p>Este valor es importante, guárdalo. Hay otras formas de obtenerlo, pero por ahora consérvalo. La Oferta de Venta fue creada, pero aún no es pública: ningún Comprador puede interactuar con ella. Primero, el Vendedor necesita financiar el Escrow.</p>
<p>El Escrow es como una bóveda que requiere la autorización tanto del Vendedor como de Peach para abrirse. El Bitcoin se introduce en la bóveda y permanece allí de forma segura hasta el final del intercambio.<br>
Como requiere la autorización del Vendedor, y el Escrow es un Script en la Blockchain de Bitcoin (una dirección P2WSH), Peach necesita la Clave Pública del Vendedor para crear este Escrow.</p>
<p>En este momento, el Vendedor envía la Clave Pública que desea usar para el Escrow a Peach, Peach selecciona su propia Clave Pública para la bóveda y la construye, generando una dirección.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood04.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">const childSell = root.derivePath(`m/84'/0'/0'/${sellOfferId}'`);

  const keyPairSellOffer = ECPair.fromPrivateKey(childSell.privateKey, {
    network: bitcoin,
  });

  const sellOfferPublicKey = Buffer.from(keyPairSellOffer.publicKey).toString(
    &quot;hex&quot;
  );

  const escrowCreateRes = await session.post(
    &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;,
    {
      publicKey: sellOfferPublicKey,
    }
  );

  const escrowAddress = escrowCreateRes.data.escrows.bitcoin;

  const escrowPeachPublicKey =
    escrowCreateRes.data.escrowPeachPublicKey.bitcoin;

</code></pre>
<p>Como puedes ver en el código, el Vendedor decidió derivar un nuevo Par de Claves usando el ID de la Oferta de Venta en la ruta de derivación. Este es un enfoque seguro, porque es fácilmente reproducible.<br>
Después de enviar la Clave Pública, la API de Peach devuelve la dirección a la que el Vendedor debe enviar los 21,000 sats. Sin embargo, no necesitas confiar ciegamente en que esta dirección es válida: puedes verificarla.</p>
<p>¡Así que verifiquémosla!</p>
<p>La API de Peach también devuelve la Clave Pública que Peach usó para este Escrow específico, y esto nos permitirá recrear la dirección escribiendo el Script de Bitcoin:</p>
<pre><code class="language-j">   OP_IF
       ${script.number.encode(4320).toString(&quot;hex&quot;)}
       OP_CHECKSEQUENCEVERIFY
       OP_DROP
   OP_ELSE
       ${sellerPublicKey}
       OP_CHECKSIGVERIFY
   OP_ENDIF
   ${peachPublicKey}
   OP_CHECKSIG
</code></pre>
<p>Este es el Script que usamos para el Escrow:</p>
<ul>
<li>
<p>siempre requiere la firma de Peach</p>
</li>
<li>
<p>además, requiere:</p>
<ul>
<li>la firma del Vendedor</li>
<li>o que se hayan minado 4320 bloques desde que el Bitcoin fue enviado a esa dirección</li>
</ul>
</li>
</ul>
<p>¿Por qué 4320 bloques? Eso equivale a 30 días de bloques minados, a un promedio de 1 bloque cada 10 minutos.<br>
¿Y por qué existe esa alternativa de requerir solo la firma de Peach después de un mes? Porque los Vendedores podrían no cooperar, perder sus claves, etc.<br>
Algo es cierto: Peach tiene una reputación impecable en el manejo de los fondos de los Vendedores.</p>
<p>Después de construir el script, puedes verificar la dirección P2WSH que genera y comprobar que es la misma que la API de Peach envió como respuesta al crear el Escrow.</p>
<pre><code class="language-j">  const multisigScript = bitcoin.script.compile([
    Buffer.from(sellOfferPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIGVERIFY,
  ]);

  const timelockScript = bitcoin.script.compile([
    bitcoin.script.number.encode(4320),
    bitcoin.opcodes.OP_CHECKSEQUENCEVERIFY,
    bitcoin.opcodes.OP_DROP,
  ]);

  const redeemScript = bitcoin.script.compile([
    bitcoin.opcodes.OP_IF,
    ...timelockScript,
    bitcoin.opcodes.OP_ELSE,
    ...multisigScript,
    bitcoin.opcodes.OP_ENDIF,
    Buffer.from(escrowPeachPublicKey, &quot;hex&quot;),
    bitcoin.opcodes.OP_CHECKSIG,
  ]);

  const escrowPayment = bitcoin.payments.p2wsh({
    redeem: { output: redeemScript },
    network: bitcoin,
  });

  console.log(&quot;Addresses Match:&quot;, escrowPayment.address === escrowAddress);

</code></pre>
<p>¡Perfecto! Ahora solo realiza una transacción Bitcoin a esa dirección y espera hasta que el Escrow sea declarado como financiado.</p>
<pre><code class="language-j">  while (true) {
    const fundingStatusRes = await session.get(
      &quot;v1/offer/&quot; + sellOfferId + &quot;/escrow&quot;
    );
    if (fundingStatusRes.data.funding.status === &quot;FUNDED&quot;) {
      break;
    }
  }

</code></pre>
<p>Una vez declarado como financiado (después de que se mine 1 bloque), la Oferta de Venta se vuelve pública y los Compradores pueden empezar a interactuar con ella.</p>
<h2 id="paso-5b-el-comprador-realiza-una-solicitud-de-comercio-a-la-oferta-de-venta">Paso 5.B: el Comprador realiza una Solicitud de Comercio a la Oferta de Venta</h2>
<p>¡Ahora es el momento de que el Comprador entre en acción!</p>
<p>Primero, revisemos todas las Ofertas de Venta disponibles:</p>
<pre><code class="language-j">const sellOffers = await session.get(&quot;v069/sellOffer&quot;);
</code></pre>
<p>Para simplificar, el Comprador se interesará en la primera Oferta de Venta disponible.</p>
<pre><code class="language-j">const sellOfferToTradeRequestId = sellOffers.data.offers[0].id;
</code></pre>
<p>Ahora, el Comprador quiere realizar una Solicitud de Comercio, informando al Vendedor que está dispuesto a comerciar bajo sus condiciones.<br>
Suena simple, ¿verdad? Pero este es el paso más complejo de todo el proceso.</p>
<p>Desglosemos lo que el Comprador necesita enviar:</p>
<ul>
<li>el Método de Pago preferido (uno de los permitidos por el Vendedor)</li>
<li>la Moneda preferida (igual que arriba)</li>
<li>una Clave Simétrica (para que el Comprador y el Vendedor se comuniquen directamente) Encriptada</li>
<li>la firma de la Clave Simétrica</li>
<li>los Datos de Pago Encriptados usando la Clave Simétrica</li>
<li>una firma de los Datos de Pago</li>
<li>la Dirección de Liberación: donde el Comprador quiere recibir el Bitcoin comprado</li>
<li>la Firma del Mensaje de la Dirección de Liberación: una prueba de que el Comprador posee esa dirección, usando BIP 322</li>
<li>la tarifa máxima de minería: cuánto está dispuesto el Comprador a descontar de su Bitcoin final para pagar las tarifas mineras de la transacción final</li>
</ul>
<p>Es mucho, ¿verdad? ¡Pero por eso Peach es tan segura! Vamos paso a paso.</p>
<h3 id="el-mtodo-de-pago-y-la-moneda-preferidos">El Método de Pago y la Moneda preferidos:</h3>
<p>Este es el más simple:</p>
<pre><code class="language-j">  const payment_data_currency = &quot;EUR&quot;;
  const payment_data_method = &quot;wise&quot;;

</code></pre>
<h3 id="la-clave-simtrica">La Clave Simétrica:</h3>
<p>La Clave Simétrica se utilizará con cifrado bidireccional AES256: puedes cifrar un mensaje y luego descifrarlo usando la misma clave.</p>
<pre><code class="language-j">async function decryptDataWithSymmetricKey(encryptedMessage, symmetricKey) {
  const message = await openpgp.readMessage({
    armoredMessage: encryptedMessage,
  });

  const { data: decrypted } = await openpgp.decrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;utf8&quot;,
  });

  return decrypted;
}

async function encryptDataWithSymmetricKey(data, symmetricKey) {
  const message = await openpgp.createMessage({ text: data });
  const encrypted = await openpgp.encrypt({
    message,
    passwords: [symmetricKey],
    format: &quot;armored&quot;,
    config: {
      preferredSymmetricAlgorithm: openpgp.enums.symmetric.aes256,
    },
  });
  return encrypted;
}

</code></pre>
<p>Para crear una, simplemente genera un número aleatorio:</p>
<pre><code class="language-j">  const symmetricKey = randomBytes(32);
  const symmetricKeyHex = symmetricKey.toString(&quot;hex&quot;);

</code></pre>
<p>No vas a enviar esta clave a simple vista: eso arruinaría su propósito.<br>
Debes cifrarla de manera que solo el Comprador y el Vendedor puedan descifrarla.<br>
Como ambos usuarios enviaron sus Claves Públicas PGP, necesitamos cifrarla de modo que solo se pueda descifrar usando una de las Claves Privadas PGP correspondientes:</p>
<pre><code class="language-j">async function encryptForMultipleRecipients(secret, publicKeysArmored) {
  const publicKeys = await Promise.all(
    publicKeysArmored.map((armored) =&gt; openpgp.readKey({ armoredKey: armored }))
  );
  const message = await openpgp.createMessage({ text: secret });

  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: publicKeys,
  });

  return encrypted;
}

  const matchingUserPgpPubKey = sellOffers.data.offers[0].user.pgpPublicKey;

  const symmetricKeyEncrypted = await encryptForMultipleRecipients(
    symmetricKeyHex,
    [pgpPublicKey, matchingUserPgpPubKey]
  );

</code></pre>
<p>Y para que el Vendedor esté seguro de que la Clave Simétrica fue creada por el Comprador, este también debe firmarla usando su clave PGP:</p>
<pre><code class="language-j">  const symmetricKeySignature = await signPGPMessage(
    pgpPrivateKey,
    symmetricKeyHex
  );

</code></pre>
<h3 id="los-datos-de-pago">Los Datos de Pago:</h3>
<p>Esta es la información más valiosa: tus Datos de Pago. Puede ser tu IBAN bancario, tu nombre de usuario de Revolut, cualquier dato que identifique el origen de tu pago Fiat.<br>
El Vendedor más tarde compartirá su información con el Comprador.</p>
<p>Ahora que tenemos una Clave Simétrica, podemos usarla para cifrar los Datos de Pago, y luego el Vendedor la usará para descifrarlos.</p>
<pre><code class="language-j">const paymentDataToEncrypt = JSON.stringify({
    reference: &quot;&quot;,
    userName: &quot;@buyerWiseId&quot;,
  });

const paymentDataEncrypted = await encryptDataWithSymmetricKey(
paymentDataToEncrypt,
symmetricKeyHex
);

const paymentDataSignature = await signPGPMessage(
pgpPrivateKey,
paymentDataToEncrypt
);

</code></pre>
<h3 id="definir-la-direccin-de-liberacin-y-probar-la-propiedad">Definir la Dirección de Liberación y probar la propiedad:</h3>
<p>Debes definir a qué dirección quieres que se envíe el Bitcoin de la transacción una vez completada. Crear una dirección es la parte fácil.<br>
La parte difícil es probar la propiedad de la dirección.<br>
Hacemos esto por motivos regulatorios, para asegurar que el Comprador es realmente el propietario, y además actúa como una precaución extra (esto por sí solo hace que Peach sea inmune al ataque de sustitución de direcciones usando librerías Javascript de septiembre de 2025).</p>
<p>La prueba de propiedad se realiza usando BIP-322, que te permite usar tu Clave Privada Bitcoin para firmar un mensaje que puede validarse usando la Dirección.</p>
<pre><code class="language-j">  const { address } = bitcoin.payments.p2wpkh({
    pubkey: Buffer.from(keyPair.publicKey),
    network: bitcoin,
  });

  const ownershipMessage =
    &quot;I confirm that only I, peach&quot; +
    publicKeyHex.slice(0, 8) +
    &quot;, control the address &quot; +
    address;

  const releaseAddressSignature = signWithBIP322(
    wif,
    address,
    ownershipMessage
  );

</code></pre>
<h3 id="un-ltimo-detalle-la-tarifa-mxima-de-minera">Un último detalle: la tarifa máxima de minería:</h3>
<p>Como Comprador, puede que no quieras gastar demasiado en tarifas para recibir tu Bitcoin, y prefieras esperar a que las tarifas bajen antes de recibir los fondos.<br>
En este caso, puedes definir la Tarifa Máxima de Minería que estás dispuesto a “pagar” para que te envíen el Bitcoin.</p>
<h3 id="finalmente-realizas-la-solicitud-de-comercio-a-la-oferta-de-venta">Finalmente, realizas la Solicitud de Comercio a la Oferta de Venta</h3>
<p>¡Vaya recorrido! Pero aquí está, y puedes enviarla.</p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; + sellOfferToTradeRequestId + &quot;/tradeRequestPerformed&quot;,
    {
      paymentMethod: payment_data_method,
      currency: payment_data_currency,
      paymentDataHashed: paymentDataToEncryptSHA256,
      paymentDataEncrypted: paymentDataEncrypted,
      paymentDataSignature: paymentDataSignature,
      symmetricKeyEncrypted: symmetricKeyEncrypted,
      symmetricKeySignature: symmetricKeySignature,
      maxMiningFeeRate: 2, // sats/vb
      releaseAddress: address,
      releaseAddressMessageSignature: releaseAddressSignature,
    }
  );

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood05.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Ahora es el turno del Vendedor de aceptarla.</p>
<h2 id="paso-5s-el-vendedor-acepta-la-solicitud-de-comercio">Paso 5.S: el Vendedor acepta la Solicitud de Comercio</h2>
<p>El Vendedor ha estado esperando que un Comprador interactúe con su Oferta de Venta.<br>
Revisa la lista de Solicitudes de Comercio:</p>
<pre><code class="language-j">const receivedTradeRequestRequest = await session.get(
    &quot;v069/sellOffer/&quot; + sellOfferId + &quot;/tradeRequestReceived&quot;
  );

  const tradeReq = receivedTradeRequestRequest.data[0];

</code></pre>
<p>Si el Vendedor desea aceptar la Solicitud de Comercio, debe compartir sus Datos de Pago con el Comprador, para que este sepa a dónde debe enviarse el pago Fiat.</p>
<p>Como el Comprador ya creó y envió una Clave Simétrica, el Vendedor puede descifrarla (porque fue cifrada con su propia Clave Pública PGP) y usarla para cifrar sus propios Datos de Pago.</p>
<pre><code class="language-j">  const receivedSymmetricKey = await decryptWithPrivateKey(
    tradeReq.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  const sellOfferPaymentDataEncrypted = await encryptDataWithSymmetricKey(
    sellOfferPaymentDataToEncrypt,
    receivedSymmetricKey
  );

  const sellOfferPaymentDataSignature = await signPGPMessage(
    pgpPrivateKey,
    sellOfferPaymentDataToEncrypt
  );

</code></pre>
<p>¡Y eso es todo! Ahora el Vendedor puede aceptar la Solicitud de Comercio y comienza una transacción oficial.</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood06.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<pre><code class="language-j">  await session.post(
    &quot;v069/sellOffer/&quot; +
      sellOfferId +
      &quot;/tradeRequestReceived/&quot; +
      tradeReq.userId +
      &quot;/accept&quot;,
    {
      paymentDataEncrypted: sellOfferPaymentDataEncrypted,
      paymentDataSignature: sellOfferPaymentDataSignature,
      paymentData: {
        [payment_data_method]: { hashes: [paymentDataEncryptSHA256] },
      },
    }
  );

</code></pre>
<p>Si entender todo el proceso fue difícil, aquí hay una imagen para ilustrarlo:</p>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood07.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 90%;">
<br><br></p>
<h2 id="paso-6b-el-comprador-declara-que-el-pago-ha-sido-realizado">Paso 6.B: el Comprador declara que el Pago ha sido realizado</h2>
<p>El Comprador puede verificar si tiene Contratos (que son intercambios acordados entre un Comprador y un Vendedor) consultando el endpoint de resúmenes de Contrato:</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data.find((obj) =&gt;
    obj.id.startsWith(sellOfferToTradeRequestId + &quot;-&quot;)
  );

  if (contract.tradeStatus !== &quot;paymentRequired&quot;) throw Error;
</code></pre>
<p>Esto le proporcionará una lista de todos los Contratos en los que participa.<br>
Si hay un Contrato con el estado de intercambio “paymentRequired”, entonces es su turno de realizar el pago Fiat.</p>
<p>Para que eso suceda, debe descifrar los Datos de Pago del Vendedor usando la Clave Simétrica del momento en que se realizó la Solicitud de Comercio.<br>
Si no la guardó, no hay problema, porque está disponible para él y puede descifrarla con su Clave Privada PGP.</p>
<pre><code class="language-j">
  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

  const receivedSymmetricKey = await decryptWithPrivateKey(
    contractRes.data.symmetricKeyEncrypted,
    pgpPrivateKey
  );

  if (receivedSymmetricKey !== symmetricKeyHex) throw Error;

  const decryptedSellerPaymentData = await decryptDataWithSymmetricKey(
    contractRes.data.paymentDataEncrypted,
    receivedSymmetricKey
  );

  console.log(&quot;Seller Payment Data &quot;, JSON.parse(decryptedSellerPaymentData));
</code></pre>
<p>Ahora esto debe ocurrir fuera de Peach: el Comprador abre su aplicación bancaria (u otra similar) y realiza una transferencia Fiat al destinatario de los Datos de Pago del Vendedor.</p>
<p>Si este paso, como lector, te genera dudas, recuerda que el Bitcoin ya está en el Escrow, controlado por Peach y el Vendedor.<br>
Incluso puedes acceder a la dirección del Escrow, que está disponible en los datos del Contrato devueltos por la API, y usar un explorador de Blockchain para verificar si el Bitcoin está allí.</p>
<p>Después de realizar la transferencia Fiat, el Comprador debe declarar que el Pago fue realizado:</p>
<pre><code class="language-j">  const confirmPaymentRes = await session.post(
    &quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;
  );
</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood08.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Este fue el último paso del Comprador.<br>
Ahora el Vendedor debe confirmar que ha recibido el pago Fiat y liberar el Bitcoin del Escrow a la dirección del Comprador.</p>
<h2 id="paso-6s-el-vendedor-confirma-que-ha-recibido-el-pago">Paso 6.S: el Vendedor confirma que ha recibido el Pago</h2>
<p>De manera similar al Comprador, el Vendedor revisa los Contratos que le han sido asignados.</p>
<pre><code class="language-j">  const contractsRes = await session.get(&quot;v1/contracts/summary&quot;);
  const contract = contractsRes.data[0];

  const contractRes = await session.get(&quot;v1/contract/&quot; + contract.id);

</code></pre>
<p>En la respuesta de la API del Contrato, el Vendedor obtendrá una Transacción Bitcoin Parcialmente Firmada (PSBT), que es una transacción del Bitcoin en el Escrow hacia la dirección del Comprador, con una firma de Peach.<br>
Esto significa que solo necesita la firma del Vendedor para convertirse en una transacción válida:</p>
<pre><code class="language-j">  const releasePSBTBase64 = contractRes.data.releasePsbt;

  const parsedPSBT = bitcoin.Psbt.fromBase64(releasePSBTBase64, {
    network: bitcoin,
  });

  parsedPSBT.signInput(0, childSell);

</code></pre>
<p><br><br>
<img src="/img/blog/under-the-hood/underthehood09.png" alt="this is the power of p2p exchanger" style="display:block; margin: auto; width: 40%;">
<br><br></p>
<p>Ahora el Vendedor puede finalizar la Transacción, pasando las dos firmas y el Script Bitcoin del Escrow.<br>
Como estamos usando la ruta MultiSig del script (escrita como la segunda ruta), debemos pasar OP_FALSE a la pila para que la instrucción IF se evalúe correctamente.</p>
<pre><code class="language-j">export const getFinalScript = (_inputIndex, input, bitcoinScript) =&gt; {
  const network = bitcoin;

  const payment = payments.p2wsh({
    network,
    redeem: {
      network,
      output: bitcoinScript,
      input: bitcoin.script.compile([
        input.partialSig[0].signature,
        input.partialSig[1].signature,
        opcodes.OP_FALSE,
      ]),
    },
  });

  parsedPSBT.finalizeInput(0, getFinalScript);

  const tx = parsedPSBT.extractTransaction().toHex();

</code></pre>
<p>El último paso: enviar la Transacción finalizada a la API de Peach:</p>
<pre><code class="language-j">  await session.post(&quot;v1/contract/&quot; + contract.id + &quot;/payment/confirm&quot;, {
    releaseTransaction: tx,
  });

</code></pre>
<p>¡Damas y caballeros, así es como comerciamos en Peach con la máxima seguridad y privacidad!</p>
<p class="date">October 23rd, 2025</p><p class="tags">Tagged with:<a href="/es/blog/tag/producto">Producto</a><a href="/es/blog/tag/p2p">P2P</a><a href="/es/blog/tag/tutorial">Tutorial</a></p><p><a href="/es/blog/">All blog posts</a></p></div></section></main><footer class="footer" id="footer"><div class="wrap"><div class="logo-section"><div class="logo"><img class="logo-image" src="/img/peach-footer-logo-e28fd7e07f654f43afd63c9b6ace3cdb.svg" alt="Peach logo"/><span>Made in Switzerland <img src="/img/flags/switzerland-icon.svg" style="width: 1rem; margin-left .5rem;"/></span></div><div class="company-info"> <img class="polyreg-image" src="/img/polyreg-52ec37fb80d0312b219110c05567ad3d.png" alt="Polyreg logo" width="120"/><p>Peach es un miembro de SRO (Organización de Autorregulación) de Polyreg </p><p>Peach es un proveedor de servicios financieros con licencia en Suiza y cumple completamente con la Ley Suiza contra el Lavado de Dinero. </p></div></div><div class="content"><div class="footer-box"><h6>Empresa</h6><a href="/es/join-us/">Únete a nosotros</a><a href="/es/terms-and-conditions/">Términos y Condiciones</a><a href="/es/privacy-policy/">Política de Privacidad</a><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Gestionar preferencias de cookies</a></div><div class="footer-box"><h6>Contacto</h6><a href="mailto:hello@peachbitcoin.com">Email</a><a href="https://keys.openpgp.org/vks/v1/by-fingerprint/48339A19645E2E53488E0E5479E1B270FACD1BD2">Clave PGP</a></div><div class="footer-box"><h6>Descargar</h6><span>0.69.0 (311)</span><a href="/es/apk/">APK</a><a href="https://testflight.apple.com/join/wfSPFEWG">iPhone</a><a href="https://play.google.com/store/apps/details?id=com.peachbitcoin.peach.mainnet">Android</a></div><div class="footer-box"><h6>Comunidad</h6><a href="https://twitter.com/peachbitcoin" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://t.me/peachtopeach" target="_blank" rel="noreferrer noopener">Telegram</a><a href="https://discord.gg/ypeHz3SW54" target="_blank" rel="noreferrer noopener">Discord</a><a href="https://www.instagram.com/peachbitcoin/" target="_blank" rel="noreferrer noopener">Instagram</a><a href="https://snort.social/p/npub15369wu3wzzar5fclhecyqfv683x69n6nhlg7rxqnsg2dydgxflpq3apswl" target="_blank" rel="noreferrer noopener">Nostr</a><a href="https://github.com/Peach2Peach" target="_blank" rel="noreferrer noopener">Github</a><a href="https://www.youtube.com/@peachbitcoin" target="_blank" rel="noreferrer noopener">YouTube</a></div><div class="footer-box"><h6>Bitcoin</h6><a href="/bitcoin.pdf">Whitepaper</a><a href="https://docs.peachbitcoin.com">Documentación API</a></div><div class="footer-box"><h6>Gana Bitcoin</h6><a href="/es/new-users/">Código de Referencia</a><a href="/es/for-businesses/">Conviértete en Afiliado</a></div></div></div></footer><style>#cookie-banner {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: #120A07;
  color: #fff;
  padding: 15px 0;
  z-index: 9999;
  font-size: 14px;
}
#cookie-banner .cookie-container {
  width: 90%;
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
}
#cookie-banner p {
  margin: 0;
  line-height: 1.4;
}
#cookie-banner .cookie-actions {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}
#cookie-banner button {
  padding: 10px 16px;
  color: #fff;
  background-color: #65A519;
  border: none;
  cursor: pointer;
  border-radius: 4px;
  font-size: 14px;
  transition: background-color 0.3s ease;
}
#cookie-banner button:hover {
  background-color: #65A519;
}
#cookie-banner button.reject {
  background-color: #DF321F;
}
#cookie-banner button.reject:hover {
  background-color: #DF321F;
}
#cookie-banner a.cookie-link {
  color: #fff;
  text-decoration: underline;
  font-size: 14px;
  margin-left: 8px;
  cursor: pointer;
}
#cookie-banner a.cookie-link:hover {
  text-decoration: none;
}
/* Popup overlay */
#cookie-popup {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  z-index: 10000;
  justify-content: center;
  align-items: center;
  color: #fff;
}
/* Contenitore del popup */
#cookie-popup-content {
  position: relative;
  background-color: #120A07;
  color:rgb(255, 255, 255);
  padding: 30px 20px 20px;
  border-radius: 10px;
  width: 80%;
  max-width: 600px;
  box-sizing: border-box;
}
/* Pulsante di chiusura */
#cookie-popup-content .close-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  color: #fff;
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  padding: 0 5px;
}
#cookie-popup-content .close-btn:hover {
  color: #ccc;
}
/* Stile per ciascuna categoria di cookie */
.cookie-category {
  margin-bottom: 20px;
}
/* Migliora i checkbox e le label */
.cookie-category label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 15px;
}
.cookie-category input[type="checkbox"] {
  accent-color: #4CAF50;
  margin: 0;
  cursor: pointer;
}
.cookie-category p {
  margin: 4px 0 0 28px;
  font-size: 14px;
  line-height: 1.4;
  color: #ccc;
}
/* Bottone "Salva Preferenze" */
#cookie-popup-content button.save-btn {
  background-color: #4CAF50;
  border: none;
  padding: 10px 16px;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}
#cookie-popup-content button.save-btn:hover {
  background-color: #43a047;
}
/* Media query per schermi più piccoli */
@media (max-width: 768px) {
  #cookie-banner .cookie-container {
    flex-direction: column;
    align-items: flex-start;
  }
  #cookie-banner .cookie-actions {
    margin-top: 10px;
    width: 100%;
    justify-content: flex-start;
    gap: 8px;
    flex-wrap: wrap;
  }
}

</style><div id="cookie-banner" style="display: none;"><div class="cookie-container"><p>Usamos cookies para mejorar tu experiencia. <a href="/privacy-policy" style="color: #4CAF50;">Leer más</a></p><div class="cookie-actions"><button class="cookie-btn" onclick="acceptCookies()">Aceptar cookies y continuar</button><button class="cookie-btn reject" onclick="rejectCookies()">Rechazar cookies</button><a class="cookie-link" href="#" onclick="showCookiePopup(event)">Administrar cookies</a></div></div></div><div id="cookie-popup"><div id="cookie-popup-content"><button class="close-btn" type="button" onclick="closeCookiePopup()">×</button><h2>Administrar preferencias de cookies</h2><div class="cookie-category"><div class="switch-container"><span class="label-text">Cookies necesarias</span><label class="switch" for="necessary-cookies"><input type="checkbox" id="necessary-cookies" checked="checked" disabled="disabled"/><span class="slider"></span></label></div><p>Estas cookies son esenciales para el funcionamiento del sitio.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Cookies de análisis</span><label class="switch" for="analytics-cookies"><input type="checkbox" id="analytics-cookies"/><span class="slider"></span></label></div><p>Las cookies de análisis nos ayudan a entender cómo los usuarios interactúan con el sitio.</p></div><div class="cookie-category"><div class="switch-container"><span class="label-text">Cookies de marketing</span><label class="switch" for="marketing-cookies"><input type="checkbox" id="marketing-cookies"/><span class="slider"></span></label></div><p>Las cookies de marketing se utilizan para recopilar información de los usuarios</p></div><div style="text-align: right; margin-top: 20px;"><button class="save-btn" type="button" onclick="savePreferences()">Guardar preferencias</button></div></div></div><script src="/js/main-15c0432b5e5f06cbab9e3fedcaae3032.js"></script><script>if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/service-worker.js')
      .then(function(registration) {
        console.log('Service Worker registrato con successo:', registration);
      })
      .catch(function(error) {
        console.log('Registrazione del Service Worker fallita:', error);
      });
  });
} else {
  console.log('Service Worker non supportato in questo browser.');
}
</script><script>document.addEventListener('DOMContentLoaded', function () {
  // Map of language codes to display names
  const languageMap = {
    en: 'English',
    es: 'Español',
    de: 'Deutsch',
    it: 'Italiano',
    fr: 'Français',
    el: 'Ελληνικά',
    hu: 'Magyar',
    nl: 'Nederlands',
    pl: 'Polski',
    pt: 'Português',
    sw: 'Kiswahili',
    uk: 'Українська'
  };

  // Detect current lang from path
  const path = window.location.pathname.replace(/\/+$/, ''); // trim trailing slash
  let currentLang = 'en';
  for (const code in languageMap) {
    if (path === '/' && code === 'en') { currentLang = 'en'; break; }
    if (path === `/${code}` || path.startsWith(`/${code}/`)) { currentLang = code; break; }
  }

  const label = document.querySelector('.language-label');
  if (!label) return;

  // Ensure there is a span.language-text, create it if missing
  let textNode = label.querySelector('.language-text');
  if (!textNode) {
    textNode = document.createElement('span');
    textNode.className = 'language-text';
    // insert before the dropdown chevron if present
    // const chevron = Array.from(label.querySelectorAll('img')).find(img => /dropdown_icon\.svg(\?.*)?$/i.test(img.getAttribute('src') || ''));
    label.insertBefore(textNode, chevron || null);
  }

  // Set the text
  textNode.textContent = languageMap[currentLang] || currentLang.toUpperCase();

  // Remove any flag images inside the label (keep the chevron)
  //- Array.from(label.querySelectorAll('img')).forEach(img => {
  //-   const src = img.getAttribute('src') || '';
  //-   const isChevron = /dropdown_icon\.svg(\?.*)?$/i.test(src);
  //-   if (!isChevron) {
  //-     img.remove();
  //-   }
  //- });

  // Also nuke any pseudo-element flags applied via CSS (belt & suspenders)
  label.style.backgroundImage = 'none';
});

</script><script>(function() {
  // Funzioni di utilità per gestire i cookie
  function setCookie(name, value, days) {
    var expires = "";
    if (days) {
      var date = new Date();
      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
      expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "") + expires + "; path=/";
  }

  function getCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  }

  // Controlla se il consenso è già stato dato per nascondere il banner
  function checkConsent() {
    if (getCookie('consent_necessary') === "true") {
      document.getElementById('cookie-banner').style.display = 'none';
    } else {
      document.getElementById('cookie-banner').style.display = 'flex';
    }
  }

  // Funzione per accettare tutti i cookie
  window.acceptCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'true', 365);
    setCookie('consent_marketing', 'true', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: true, consent_marketing: true});
  };

  // Funzione per rifiutare cookie opzionali (analytics e marketing)
  window.rejectCookies = function() {
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', 'false', 365);
    setCookie('consent_marketing', 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: false, consent_marketing: false});
  };

  // Mostra il popup per gestire le preferenze dei cookie
  window.showCookiePopup = function(event) {
    event.preventDefault();
    document.getElementById('cookie-popup').style.display = 'flex';
  };
  window.closeCookiePopup = function() {
  document.getElementById('cookie-popup').style.display = 'none';
  };

  // Salva le preferenze impostate nel popup
  window.savePreferences = function() {
    var analyticsConsent = document.getElementById('analytics-cookies').checked;
    var marketingConsent = document.getElementById('marketing-cookies').checked;
    setCookie('consent_necessary', 'true', 365);
    setCookie('consent_analytics', analyticsConsent ? 'true' : 'false', 365);
    setCookie('consent_marketing', marketingConsent ? 'true' : 'false', 365);
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookie-popup').style.display = 'none';
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event: 'cookie_consent', consent_analytics: analyticsConsent, consent_marketing: marketingConsent});
  };

  // Inizializza il controllo del consenso al caricamento della pagina
  checkConsent();
})();</script></body></html>